{"meta":{"title":"๑Charles✦ˑ̫✦Vincent๑","subtitle":"基于Linux && Android 源代码，详细分析Linux && Android 系统内部实现机制","description":null,"author":"๑Charles✦ˑ̫✦Vincent๑","url":"http://zhoujinjian.cc"},"pages":[{"title":"Categories","date":"2018-01-04T16:00:00.000Z","updated":"2018-03-27T10:19:32.000Z","comments":true,"path":"categories/index.html","permalink":"http://zhoujinjian.cc/categories/index.html","excerpt":"","text":"title: Androiddate: 2018-01-05 00:00:00 type: “categories” title: Hexodate: 2018-01-05 00:00:00 type: “categories”"},{"title":"Tags","date":"2018-01-04T16:00:00.000Z","updated":"2018-01-19T09:56:44.000Z","comments":true,"path":"tags/index.html","permalink":"http://zhoujinjian.cc/tags/index.html","excerpt":"","text":""},{"title":"Android","date":"2018-01-04T16:00:00.000Z","updated":"2018-01-12T11:33:56.000Z","comments":true,"path":"categories/Android/index.html","permalink":"http://zhoujinjian.cc/categories/Android/index.html","excerpt":"","text":""},{"title":"Hexo","date":"2018-01-04T16:00:00.000Z","updated":"2018-01-19T09:55:08.000Z","comments":true,"path":"categories/Hexo/index.html","permalink":"http://zhoujinjian.cc/categories/Hexo/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux内核（Kernel-3.18） - Linux Input 子系统分析 [i.wonder~]","slug":"Linux内核（Kernel-3-18）-Input-子系统分析-i-wonder","date":"2018-03-31T16:00:00.000Z","updated":"2018-03-23T07:33:30.000Z","comments":true,"path":"2018/04/01/Linux内核（Kernel-3-18）-Input-子系统分析-i-wonder/","link":"","permalink":"http://zhoujinjian.cc/2018/04/01/Linux内核（Kernel-3-18）-Input-子系统分析-i-wonder/","excerpt":"Linux输入子系统对Linux的输入设备驱动进行了高度抽象，总共分为5 层，从上到下分别是：用户空间层（User Space）事件处理层(Event Handler)、输入子系统核心层(Input Core)、硬件驱动层(Input Driver) 、硬件设备层（Hardware）.","text":"Linux输入子系统对Linux的输入设备驱动进行了高度抽象，总共分为5 层，从上到下分别是：用户空间层（User Space）事件处理层(Event Handler)、输入子系统核心层(Input Core)、硬件驱动层(Input Driver) 、硬件设备层（Hardware）. 【博客原图链接】源码（部分）：kernel/msm-3.18/include/linux Input.h evdev.h kernel/msm-3.18/drivers/input Input.c evdev.c gpio_keys.c kernel/msm-3.18/drivers/input/touchscreen/synaptics_dsx_htc_2.6 Makefile Kconfig synaptics_dsx_core.c 【博客原图链接】Google Pixel、Pixel XL 内核代码（Kernel-3.18）： Kernel source for Pixel and Pixel XL - Google Kernel source for Pixel and Pixel XL - GitHub （一）、Linux Input 子系统框架输入(Input)子系统是分层架构的，总共分为5 层，从上到下分别是：用户空间层（User Space）事件处理层(Event Handler)、输入子系统核心层(Input Core)、硬件驱动层(Input Driver) 、硬件设备层（Hardware）。 驱动根据CORE提供的接口，向上报告发生的按键动作。然后CORE根据驱动的类型，分派这个报告给对应的事件处理层进行处理。事件处理层把数据变化反应到设备模型的文件中（事件缓冲区）。并通知在这些设备模型文件上等待的进程。 input子系统框架： (1) “硬件驱动层”负责操作具体的硬件设备，这层的代码是针对具体的驱动程序的，比如你的设备是触摸输入设备，还是鼠标输入设备，还是键盘输入设备，这些不同的设备，自然有不同的硬件操作，驱动工程师往往只需要完成这层的代码编写。 (2) “输入子系统核心层”是链接其他两层之间的纽带与桥梁，向下提供硬件驱动层的接口，向上提供事件处理层的接口。 (3) “事件处理层” 负责与用户程序打交道，将硬件驱动层传来的事件报告给用户程序。 各层之间通信的基本单位就是事件，任何一个输入设备的动作都可以抽象成一种事件，如键盘的按下，触摸屏的按下，鼠标的移动等。事件有三种属性：类型（type），编码(code)，值(value)， Input 子系统支持的所有事件都定义在 input.h中，包括所有支持的类型，所属类型支持的编码等。事件传送的方向是 硬件驱动层–&gt;子系统核心–&gt;事件处理层–&gt;用户空间。 （二）、Input 主要通用数据结构2.1、input_dev输入设备 input_dev，这是input设备基本的设备结构，每个input驱动程序中都必须分配初始化这样一个结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071[-&gt;input.h]struct input_dev &#123; const char *name; //输入设备的名称 const char *phys; //输入设备节点名称 const char *uniq; //指定唯一的ID号，就像MAC地址一样 struct input_id id; //输入设备标识ID，用于和事件处理层进行匹配 unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; //位图，记录设备支持的事件类型 unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; //位图，记录设备支持的按键类型 unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; //位图，记录设备支持的相对坐标 unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; //位图，记录设备支持的绝对坐标 unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; //位图，记录设备支持的其他功能 unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; //位图，记录设备支持的指示灯 unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; //位图，记录设备支持的声音或警报 unsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; //位图，记录设备支持的作用力功能 unsigned long swbit[BITS_TO_LONGS(SW_CNT)]; //位图，记录设备支持的开关功能 unsigned int hint_events_per_packet; unsigned int keycodemax; //设备支持的最大按键值个数 unsigned int keycodesize; //每个按键的字节大小 void *keycode; //指向按键池，即指向按键值数组首地址 int (*setkeycode)(struct input_dev *dev, const struct input_keymap_entry *ke, unsigned int *old_keycode); //修改按键值 int (*getkeycode)(struct input_dev *dev, struct input_keymap_entry *ke); //获取按键值 struct ff_device *ff; //用于强制更新输入设备的部分内容 unsigned int repeat_key; //重复按键的键值 struct timer_list timer; //设置当有连击时的延时定时器 int rep[REP_CNT]; struct input_mt *mt; struct input_absinfo *absinfo; unsigned long key[BITS_TO_LONGS(KEY_CNT)]; //位图，按键的状态 unsigned long led[BITS_TO_LONGS(LED_CNT)]; //位图，led的状态 unsigned long snd[BITS_TO_LONGS(SND_CNT)]; //位图，声音的状态 unsigned long sw[BITS_TO_LONGS(SW_CNT)]; //位图，开关的状态 int (*open)(struct input_dev *dev); void (*close)(struct input_dev *dev); int (*flush)(struct input_dev *dev, struct file *file); int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value); struct input_handle __rcu *grab; //类似私有指针，可以直接访问到事件处理接口event spinlock_t event_lock; struct mutex mutex; unsigned int users; bool going_away; struct device dev; struct list_head h_list; //该链表头用于链接此设备所关联的input_handle struct list_head node; //用于将此设备链接到input_dev_list(链接了所有注册到内核的事件处理器) unsigned int num_vals; unsigned int max_vals; struct input_value *vals; bool devres_managed;&#125;; 2.1、input_handler input_handler 这是事件处理器的数据结构，代表一个事件处理器12345678910111213141516171819202122232425262728293031[-&gt;input.h]struct input_handler &#123; void *private; /* 当事件处理器接收到来自Input设备传来的事件时调用的处理函数, event、events用于处理事件 */ void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value); void (*events)(struct input_handle *handle, const struct input_value *vals, unsigned int count); bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value); /* 比较 device's id with handler's id_table ，匹配device and handler*/ bool (*match)(struct input_handler *handler, struct input_dev *dev); /* connect用于建立intput_handler和input_dev的联系, 当一个Input设备注册到内核的时候被调用,将输入设备与事件处理器联结起来 */ int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id); /* disconnect用于解除handler和device的联系 */ void (*disconnect)(struct input_handle *handle); void (*start)(struct input_handle *handle); bool legacy_minors; int minor; //次设备号 const char *name; //次设备号 const struct input_device_id *id_table; //用于和device匹配 ,这个是事件处理器所支持的input设备 //这个链表用来链接他所支持的input_handle结构,input_dev与input_handler配对之后就会生成一个input_handle结构 struct list_head h_list; //链接到input_handler_list，这个链表链接了所有注册到内核的事件处理器 struct list_head node;&#125;; 2.3、input_handle123456789101112131415161718192021222324[-&gt;input.h]struct input_handle &#123; /* 每个配对的事件处理器都会分配一个对应的设备结构，如evdev事件处理器的evdev结构， 注意这个结构与设备驱动层的input_dev不同，初始化handle时，保存到这里。 */ void *private; /* 打开标志，每个input_handle 打开后才能操作， 这个一般通过事件处理器的open方法间接设置 */ int open; const char *name; /* 指向Input_dev结构实体 */ struct input_dev *dev; /* 指向Input_Hander结构实体 */ struct input_handler *handler; /* input_handle通过d_node连接到了input_dev上的h_list链表上 */ struct list_head d_node; /* input_handle通过h_node连接到了input_handler的h_list链表上 */ struct list_head h_node;&#125;; 2.4、三个数据结构之间的关系 input_dev: 是硬件驱动层，代表一个input设备。 input_handler: 是事件处理层，代表一个事件处理器。 input_handle: 属于核心层，代表一个配对的input_dev与input_handler input_dev 通过全局的input_dev_list链接在一起。设备注册的时候实现这个操作。注：（稍后详细分析） 1234567891011121314151617181920[-&gt;input.c]static LIST_HEAD(input_dev_list);static LIST_HEAD(input_handler_list);int input_register_device(struct input_dev *dev)&#123; struct input_devres *devres = NULL; struct input_handler *handler; unsigned int packet_size; const char *path; int error; ...... list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list); list_for_each_entry(handler, &amp;input_handler_list, node) input_attach_handler(dev, handler); ......&#125; input_handler 通过全局的input_handler_list链接在一起。事件处理器注册的时候实现这个操作（事件处理器一般内核自带，一般不需要我们来写）注：（稍后详细分析） 12345678910111213141516[-&gt;input.c]static LIST_HEAD(input_dev_list);static LIST_HEAD(input_handler_list);int input_register_handler(struct input_handler *handler)&#123; struct input_dev *dev; int error; ...... list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list); list_for_each_entry(dev, &amp;input_dev_list, node) input_attach_handler(dev, handler); ...... return 0;&#125; input_hande 没有一个全局的链表，它注册的时候将自己分别挂在了input_dev 和 input_handler 的h_list上了。通过input_dev 和input_handler就可以找到input_handle在设备注册和事件处理器，注册的时候都要进行配对工作(input_match_device)，配对后就会实现链接(handler-&gt;connect)通过input_handle也可以找到input_dev和input_handler。注：（稍后详细分析） 123456789101112[-&gt;input.c]static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)&#123; const struct input_device_id *id; int error; id = input_match_device(handler, dev); ...... error = handler-&gt;connect(handler, dev, id); ...... return error;&#125; 我们可以看到，input_device和input_handler中都有一个h_list,而input_handle拥有指向input_dev和input_handler的指针，也就是说input_handle是用来关联input_dev和input_handler的。 那么为什么一个input_device和input_handler中拥有的是h_list而不是一个handle呢？因为一个device可能对应多个handler,而一个handler也不能只处理一个device,比如说一个鼠标，它可以对应even handler，也可以对应mouse handler,因此当其注册时与系统中的handler进行匹配，就有可能产生两个实例，一个是evdev,另一个是mousedev,而任何一个实例中都只有一个handle。至于以何种方式来传递事件，就由用户程序打开哪个实例来决定。后面一个情况很容易理解，一个事件驱动不能只为一个甚至一种设备服务，系统中可能有多种设备都能使用这类handler,比如event handler就可以匹配所有的设备。在input子系统中，有8种事件驱动，每种事件驱动最多可以对应32个设备，因此dev实例总数最多可以达到256个。 （三）、Input 核心层（Input.c）这一节主要介绍核心层的初始化，input_device、input_handle、input_handler之间的关系(稍后回头看更佳)。总体概览图： 3.1、输入核心层：初始化首先从驱动“入口函数”开始查看 1234567891011121314151617[-&gt;input.c]static int __init input_init(void)&#123; int err; //注册input类，可在/sys/class下看到对应节点文件 err = class_register(&amp;input_class); ...... err = input_proc_init();/*创建/proc中的项，查看/proc/bus/input */ ...... /*注册设备/dev/input，主设备号为INPUT_MAJOR，就是13，后面注册的输入设备都使用该主设备号*/ err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0), INPUT_MAX_CHAR_DEVICES, \"input\"); ...... return 0; ...... return err;&#125; 在入口函数里面创建了一个input_class类，其实就在/sys/class下创建了一个目录input.当然对于一个新设备，可以注册进一个class也可以不注册进去，如果存在对应class的话注册进去更好，另外在/proc创建了入口项,这样就可以/proc目录看到input的信息，然后就注册设备，可以看出输入子系统的主设备号是13，在这里并没有生成设备文件。只是在/dev/目录下创建了input目录，以后所有注册进系统的输入设备文件都放在这个目录下。 相应的对应关系可以使用adb 命令进入文件系统之后，cat /proc/bus/input/devices ，查看各个设备对应的event多少，比如Google Pixel 手机： 12345678910I: Bus=0000 Vendor=0000 Product=0003 Version=2066N: Name=\"synaptics_dsxv26\"P: Phys=synaptics_dsx/touch_inputS: Sysfs=/devices/soc/7577000.i2c/i2c-3/3-0020/input/input3U: Uniq=H: Handlers=mdss_fb kgsl event3 B: PROP=2B: EV=bB: KEY=8000 0 0B: ABS=663800000000000 event3 就是事件序号， 我们在调试的时候直接 adb shell getevent /dev/input/event3，来实时捕捉 event3 中储存的数据。 那么接下来看看怎么注册input设备的.我们需要在设备驱动层中完成输入设备的注册，通过调用input_register_device()函数来完成，该函数的一个重要任务就是完成设备与事件驱动的匹配 3.2、输入核心层：注册设备input_dev123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384[-&gt;input.c]int input_register_device(struct input_dev *dev)&#123; struct input_devres *devres = NULL; struct input_handler *handler; unsigned int packet_size; const char *path; int error; if (dev-&gt;devres_managed) &#123; devres = devres_alloc(devm_input_device_unregister, sizeof(struct input_devres), GFP_KERNEL); ...... devres-&gt;input = dev; &#125; //EN_SYN这个是设备都要支持的事件类型，所以要设置 /* Every input device generates EV_SYN/SYN_REPORT events. */ __set_bit(EV_SYN, dev-&gt;evbit); /* KEY_RESERVED is not supposed to be transmitted to userspace. */ __clear_bit(KEY_RESERVED, dev-&gt;keybit); /* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. */ input_cleanse_bitmasks(dev); packet_size = input_estimate_events_per_packet(dev); if (dev-&gt;hint_events_per_packet &lt; packet_size) dev-&gt;hint_events_per_packet = packet_size; dev-&gt;max_vals = dev-&gt;hint_events_per_packet + 2; dev-&gt;vals = kcalloc(dev-&gt;max_vals, sizeof(*dev-&gt;vals), GFP_KERNEL); ...... /* * If delay and period are pre-set by the driver, then autorepeating * is handled by the driver itself and we don't do it in input.c. */ // 这个定时器是为了重复按键而设置的 if (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123; dev-&gt;timer.data = (long) dev; dev-&gt;timer.function = input_repeat_key; dev-&gt;rep[REP_DELAY] = 250; dev-&gt;rep[REP_PERIOD] = 33; &#125; /* 如果设备驱动没有设置自己的获取键值的函数，系统默认 */ if (!dev-&gt;getkeycode) dev-&gt;getkeycode = input_default_getkeycode; /* 如果设备驱动没有指定按键重置函数，系统默认 */ if (!dev-&gt;setkeycode) dev-&gt;setkeycode = input_default_setkeycode; error = device_add(&amp;dev-&gt;dev); ...... path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL); pr_info(\"%s as %s\\n\", dev-&gt;name ? dev-&gt;name : \"Unspecified device\", path ? path : \"N/A\"); kfree(path); error = mutex_lock_interruptible(&amp;input_mutex); ...... // 将新分配的input设备连接到input_dev_list链表上 list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list); /* 核心重点，input设备在增加到input_dev_list链表上之后，会查找 * input_handler_list事件处理链表上的handler进行匹配，这里的匹配 * 方式与设备模型的device和driver匹配过程很相似，所有的input * 都挂在input_dev_list上，所有类型的事件都挂在input_handler_list * 上，进行“匹配相亲”，list_for_each_entry就是个for循环，跳出条件遍历了一遍，又回到链表头 */ list_for_each_entry(handler, &amp;input_handler_list, node) input_attach_handler(dev, handler); input_wakeup_procfs_readers(); mutex_unlock(&amp;input_mutex); if (dev-&gt;devres_managed) &#123; dev_dbg(dev-&gt;dev.parent, \"%s: registering %s with devres.\\n\", __func__, dev_name(&amp;dev-&gt;dev)); devres_add(dev-&gt;dev.parent, devres); &#125; return 0;......&#125; 上面的代码主要的功能有以下几个功能，也是设备驱动注册为输入设备委托内核做的事情： 1、进一步初始化输入设备，例如连击事件2、注册输入设备到input类中，把输入设备挂到输入设备链表input_dev_list中3、查找并匹配输入设备对应的事件处理层，通过input_handler_list链表 我们需要再分析下这个匹配的过程，input_attach_handler()匹配过程如下： 12345678910111213[-&gt;input.c]static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)&#123; const struct input_device_id *id; int error; /* input_dev 和 input_handler 进行匹配,返回匹配的id，类型是struct input_device_id */ id = input_match_device(handler, dev); ...... /* 匹配成功，调用handler里面的connect函数,这个函数在事件处理器中定义，主要生成一个input_handle结构，并初始化，还生成一个事件处理器相关的设备结构 */ error = handler-&gt;connect(handler, dev, id); ...... return error;&#125; 我们先来看下input_match_device（）函数，看一下这个匹配的条件是什么，如何匹配的过程是怎样的，匹配的结果会是什么12345678910111213141516171819202122232425262728293031323334353637[-&gt;input.c]static const struct input_device_id *input_match_device(struct input_handler *handler, struct input_dev *dev)&#123; const struct input_device_id *id; for (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123; if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS) if (id-&gt;bustype != dev-&gt;id.bustype) //匹配总线id continue; if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR) if (id-&gt;vendor != dev-&gt;id.vendor) //匹配生产商id continue; if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT) if (id-&gt;product != dev-&gt;id.product) //匹配产品id continue; if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION) if (id-&gt;version != dev-&gt;id.version) //匹配版本 continue; //匹配id的evbit和input_dev中evbit的各个位，如果不匹配则continue，数组中下一个设备 if (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX)) continue; ...... if (!bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX)) continue; if (!handler-&gt;match || handler-&gt;match(handler, dev)) return id;//匹配成功,返回id &#125; return NULL;&#125; input_match_device() 到最合适的事件处理层驱动时，便执行handler-&gt;connect() 函数进行连接了，看下面这部分代码（以evdev类型驱动为例，在input/evdev.c中） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[-&gt;evdev.c]static int evdev_connect(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id)&#123; struct evdev *evdev; int minor; int dev_no; int error; /* EVDEV_MINORS为32，代表共能容纳32个evdev事件层设备，下面代码在找到空的地方，用于保存evdev事件层的数据，即上面定义的evdev */ minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, true); ...... /* 开始给evdev事件层驱动分配空间了 */ evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL); ...... /* 初始化client_list列表和evdev_wait队列，后面介绍 */ INIT_LIST_HEAD(&amp;evdev-&gt;client_list); spin_lock_init(&amp;evdev-&gt;client_lock); mutex_init(&amp;evdev-&gt;mutex); init_waitqueue_head(&amp;evdev-&gt;wait); evdev-&gt;exist = true; /* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 */ dev_no = minor; /* Normalize device number if it falls into legacy range */ if (dev_no &lt; EVDEV_MINOR_BASE + EVDEV_MINORS) dev_no -= EVDEV_MINOR_BASE; dev_set_name(&amp;evdev-&gt;dev, \"event%d\", dev_no); /*这里就将handle的dev指针指向了input_dev*/ evdev-&gt;handle.dev = input_get_device(dev); evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev); evdev-&gt;handle.handler = handler;/*这里将handle的handler指向了当前的input_handler.注意本函数evdev_connect,可能是在在输入设备注册的时候38 在input_register_device函数中调用input_attach_handler的时候调用;也可能是在输入设备的处理方法input_handler时在input_register_handler39 函数中也会用到input_attach_handler函数,就会调用本函数.这里就很明显了,本函数就将input_handler和input_dev都放在input_handle中统一管理*/ evdev-&gt;handle.private = evdev; /*初始化evdev中的内嵌device*/ evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, minor); evdev-&gt;dev.class = &amp;input_class; evdev-&gt;dev.parent = &amp;dev-&gt;dev; evdev-&gt;dev.release = evdev_free; device_initialize(&amp;evdev-&gt;dev); /* input_dev设备驱动层和input_handler事件处理层的关联，由input_handle完成(不要和handler搞混淆了，这不是一个概念～) */ error = input_register_handle(&amp;evdev-&gt;handle); ...... cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops); evdev-&gt;cdev.kobj.parent = &amp;evdev-&gt;dev.kobj; error = cdev_add(&amp;evdev-&gt;cdev, evdev-&gt;dev.devt, 1); ...... error = device_add(&amp;evdev-&gt;dev); ...... return 0; ......&#125; 3.3、输入核心层：注册input_handler为了逻辑更清新，我们稍后再来看input_register_handle() 程，先来了解input_handler的注册过程。要了解input_handler的注册过程，又需要先了解evdev初始化过程（以evdev为例）： /kernel/drivers/input下众多事件处理器handler其中的一个，可以看下源码/kernel/drivers/input/evdev.c中的模块init 12345[-&gt;edev.c]static int __init evdev_init(void)&#123; return input_register_handler(&amp;evdev_handler);&#125; 这个初始化就是往input核心中注册一个input_handler类型的evdev_handler，调用的是input.c提供的接口，input_handler结构前面有介绍，看下evdev_handler的赋值： 1234567891011[-&gt;edev.c]static struct input_handler evdev_handler = &#123; .event = evdev_event, .events = evdev_events, .connect = evdev_connect, .disconnect = evdev_disconnect, .legacy_minors = true, .minor = EVDEV_MINOR_BASE, .name = \"evdev\", .id_table = evdev_ids,&#125;; 可以注意的是evdev是匹配所有设备的，因为： 12345[-&gt;edev.c]static const struct input_device_id evdev_ids[] = &#123; &#123; .driver_info = 1 &#125;, /* Matches all devices */ &#123; &#125;, /* Terminating zero entry */&#125;; 123456789101112131415161718192021[-&gt;input.c]int input_register_handler(struct input_handler *handler)&#123; struct input_dev *dev; int error; error = mutex_lock_interruptible(&amp;input_mutex); ...... INIT_LIST_HEAD(&amp;handler-&gt;h_list); //添加进input_handler_list全局链表 list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list); //同样遍历input_dev这个链表，依次调用下面的input_attach_handler去匹配input_dev,这个跟input_dev注册的时候的情形类似 list_for_each_entry(dev, &amp;input_dev_list, node) input_attach_handler(dev, handler); input_wakeup_procfs_readers(); mutex_unlock(&amp;input_mutex); return 0;&#125; 3.4、输入核心层：注册input_handle（不要和handler搞混淆了哦，这不是一个概念～）input_handle关联匹配input_dev和input_handler继续分析input_dev和input_handler 是如何关联上的123456789101112131415161718192021222324252627282930313233[-&gt;input.c]int input_register_handle(struct input_handle *handle)&#123; struct input_handler *handler = handle-&gt;handler; struct input_dev *dev = handle-&gt;dev; int error; ...... error = mutex_lock_interruptible(&amp;dev-&gt;mutex); ...... /* 将d_node链接到输入设备的h_list，h_node链接到事件层的h_list链表上 * 因此，在handle中是输入设备和事件层的关联结构体，通过输入设备可以 * 找到对应的事件处理层接口，通过事件处理层也可找到匹配的输入设备 */ //把这个handle的d_node 加到对应input_dev的h_list链表里面 if (handler-&gt;filter) list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list); else list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list); mutex_unlock(&amp;dev-&gt;mutex); ...... //把这个handle的h_node 加到对应input_handler的h_list链表里面 list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list); if (handler-&gt;start) handler-&gt;start(handle); return 0;&#125; 这个注册是把handle 本身的链表加入到它自己的input_dev 以及 input_handler的h_list链表中，这样以后就可以通过h_list遍历到这个handle，这样就实现了三者的绑定联系。 以上是输入设备驱动注册的全过程，纵观整个过程，输入设备驱动最终的目的就是能够与事件处理层的事件驱动相互匹配，但是在drivers/input目录下有evdev.c事件驱动、mousedev.c事件驱动、joydev.c事件驱动等等，我们的输入设备产生的事件应该最终上报给谁，然后让事件被谁去处理呢？知道了这么个原因再看上面代码就会明白，其实evdev.c、mousedev.c等根据硬件输入设备的处理方式的不同抽象出了不同的事件处理接口帮助上层去调用，而我们写的设备驱动程序只不过是完成了硬件寄存器中数据的读写，但提交给用户的事件必须是经过事件处理层的封装和同步才能够完成的，事件处理层提供给用户一个统一的界面来操作。整个关联注册的过程： （四）、Input 事件处理层 Event handler （以evdev事件处理器为例）举例说明如何读取事件：input数据最终是应用程序读，最终会导致 handler 中的“read”函数。读的过程中，没有数据可读时就休眠，有休眠就会唤醒，搜索的结果是“event”函数来唤醒。分析到这里就没有接着去分析而是猜测是由“硬件”调用的“event”函数，硬件则指“input_dev”层的设备中断服务程序调用了“event”函数。通过这个“event”函数可以最终追踪到“纯软件”部分的“input_handler”结构体中的“.event”成员。 4.1、主要数据结构（1） evdev设备结构 12345678910111213[evdev.h]struct evdev &#123; int exist; int open; //打开标志 int minor; //次设备号 struct input_handle handle; //关联的input_handle wait_queue_head_t wait; //等待队列，当进程读取设备，而没有事件产生的时候，进程就会睡在其上面 struct evdev_client *grab; //强制绑定的evdev_client结构，这个结构后面再分析 struct list_head client_list; //evdev_client 链表，这说明一个evdev设备可以处理多个evdev_client，可以有多个进程访问evdev设备 spinlock_t client_lock; /* protects client_list */ struct mutex mutex; struct device dev; //device结构，说明这是一个设备结构 &#125;; evdev结构体在配对成功的时候生成，由handler-&gt;connect生成，对应设备文件为/class/input/event(n)，如触摸屏驱动的event3，这个设备是用户空间要访问的设备，可以理解它是一个虚拟设备，因为没有对应的硬件，但是通过handle-&gt;dev 就可以找到input_dev结构，而它对应着触摸屏，设备文件为/class/input/input3。这个设备结构生成之后保存在evdev_table中，索引值是minor。（2）evdev用户端结构123456789101112131415[evdev.h]struct evdev_client &#123; unsigned int head; //buffer数组的索引头 unsigned int tail; //buffer数组的索引尾 unsigned int packet_head; /* [future] position of the first element of next packet */ spinlock_t buffer_lock; /* protects access to buffer, head and tail */ struct wake_lock wake_lock; bool use_wake_lock; char name[28]; struct fasync_struct *fasync; //异步通知函数 struct evdev *evdev; //包含一个evdev变量 struct list_head node; //链表 unsigned int bufsize; struct input_event buffer[]; //input_event数据结构的数组，input_event代表一个事件，基本成员：类型（type），编码（code），值（value） &#125;; 这个结构在进程打开event3设备的时候调用evdev的open方法，在open中创建这个结构，并初始化。在关闭设备文件的时候释放这个结构。（3）input_event结构 1234567[input.h]struct input_event &#123; struct timeval time; //事件发生的时间 __u16 type; //事件类型 __u16 code; //子事件 __s32 value; //事件的value &#125;; 4.2、事件处理层evdev事件处理层与用户程序和输入子系统核心打交道，是他们两层的桥梁。一般内核有好几个事件处理器，像evdev mousedev jotdev。evdev事件处理器可以处理所有的事件，触摸屏驱动就是用的这个，所以下面分析这个事件处理器的实现。它也是作为模块注册到内核中的,前面已经分析过它的模块初始化函数 12345678910111213141516[-&gt;evdev.c]static const struct file_operations evdev_fops = &#123; .owner = THIS_MODULE, .read = evdev_read, .write = evdev_write, .poll = evdev_poll, .open = evdev_open, .release = evdev_release, .unlocked_ioctl = evdev_ioctl,#ifdef CONFIG_COMPAT .compat_ioctl = evdev_ioctl_compat,#endif .fasync = evdev_fasync, .flush = evdev_flush, .llseek = no_llseek,&#125;; 如果匹配上了就会创建一个evdev，它里边封装了一个handle，会把input_dev和input_handler关联到一起。关系如下： 4.3、evdev设备结点的open()操作我们知道.对主设备号为INPUT_MAJOR的设备节点进行操作，会将操作集转换成handler的操作集。在evdev中，这个操作集就是evdev_fops。对应的open函数如下示： 首先来看打开event(x)设备文件，evdev_open函数. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677[-&gt;evdev.c]static int evdev_open(struct inode *inode, struct file *file)&#123; struct evdev *evdev = container_of(inode-&gt;i_cdev, struct evdev, cdev); //evdev_client的buffer大小 unsigned int bufsize = evdev_compute_buffer_size(evdev-&gt;handle.dev); unsigned int size = sizeof(struct evdev_client) + bufsize * sizeof(struct input_event); struct evdev_client *client; int error; //打开的时候创建一个evdev_client client = kzalloc(size, GFP_KERNEL | __GFP_NOWARN); ...... client-&gt;bufsize = bufsize; spin_lock_init(&amp;client-&gt;buffer_lock); snprintf(client-&gt;name, sizeof(client-&gt;name), \"%s-%d\", dev_name(&amp;evdev-&gt;dev), task_tgid_vnr(current)); client-&gt;evdev = evdev; evdev_attach_client(evdev, client); //调用打开真正的底层设备函数 error = evdev_open_device(evdev); ...... file-&gt;private_data = client; nonseekable_open(inode, file); return 0; ......&#125;static int evdev_open_device(struct evdev *evdev)&#123; int retval; retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex); if (retval)/*如果设备不存在，返回错误*/ return retval; if (!evdev-&gt;exist) retval = -ENODEV; else if (!evdev-&gt;open++) &#123;//递增打开计数 retval = input_open_device(&amp;evdev-&gt;handle);//如果是被第一次打开，则调用input_open_device if (retval) evdev-&gt;open--; &#125; mutex_unlock(&amp;evdev-&gt;mutex); return retval;&#125;int input_open_device(struct input_handle *handle)&#123; struct input_dev *dev = handle-&gt;dev;//根据input_handle找到对应的input_dev设备 int retval; retval = mutex_lock_interruptible(&amp;dev-&gt;mutex); ...... handle-&gt;open++;//递增handle的打开计数 if (!dev-&gt;users++ &amp;&amp; dev-&gt;open) retval = dev-&gt;open(dev);//如果是第一次打开.则调用input device的open()函数 if (retval) &#123; dev-&gt;users--; if (!--handle-&gt;open) &#123; synchronize_rcu(); &#125; &#125; out: mutex_unlock(&amp;dev-&gt;mutex); return retval;&#125; 4.4、用户进程读取event的底层实现至于具体的如何初始化input_dev，这个是具体的输入设备去实现的，稍后具体实例再分析，现在来看看，对于一个event(x)设备文件的，应用程序来读，最终会导致“handler”里面的的“读函数”被调用。 evdev_fops 结 构 体 是 一 个 file_operations 的 类 型 。 当 用 户 层 调 用 类 似 代 码open(“/dev/input/event3” , O_RDONLY) 函 数 打 开 设 备 结 点 时 , 会 调 用 evdev_fops 中 的evdev_read()函数,该函数的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586[-&gt;evdev.c]static ssize_t evdev_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)&#123; struct evdev_client *client = file-&gt;private_data;//就是刚才在open函数中保存的evdev_client struct evdev *evdev = client-&gt;evdev; struct input_event event; size_t read = 0; int error; for (;;) &#123; ...... //如果获得了数据则取出来，调用evdev_fetch_next_event while (read + input_event_size() &lt;= count &amp;&amp; evdev_fetch_next_event(client, &amp;event)) &#123; //input_event_to_user调用copy_to_user传入用户程序中，这样读取完成 if (input_event_to_user(buffer + read, &amp;event)) return -EFAULT; read += input_event_size(); &#125; ...... /*如果是可阻塞状态的话,则等待在wait队列上.直到有数据要被处理,当前进程才被唤醒.这很好理解,既然是 输入设备,读的话比如读按键,那么必须要有硬件设备有按键按下才会返回按键值,这里还是处于事件处理层,应用程序在这里休眠,那么谁来唤醒? 当然是有按键按下才去唤醒,因此这个工作就交给了设备驱动层,那么找到这个唤醒呢,直接去找不好找,那么可以直接搜索evdev-&gt;wait,搜索结果 可知evdev-&gt;wait在evdev_event()函数中被唤醒*/ if (!(file-&gt;f_flags &amp; O_NONBLOCK)) &#123; error = wait_event_interruptible(evdev-&gt;wait, client-&gt;packet_head != client-&gt;tail || !evdev-&gt;exist || client-&gt;revoked); if (error) return error; &#125; &#125; return read;&#125;static int evdev_fetch_next_event(struct evdev_client *client, struct input_event *event)&#123; int have_event; spin_lock_irq(&amp;client-&gt;buffer_lock); /*先判断一下是否有数据*/ have_event = client-&gt;packet_head != client-&gt;tail; /*如果有就从环形缓冲区的取出来，记得是从head存储，tail取出*/ if (have_event) &#123; *event = client-&gt;buffer[client-&gt;tail++]; client-&gt;tail &amp;= client-&gt;bufsize - 1; if (client-&gt;use_wake_lock &amp;&amp; client-&gt;packet_head == client-&gt;tail) wake_unlock(&amp;client-&gt;wake_lock); &#125; spin_unlock_irq(&amp;client-&gt;buffer_lock); return have_event;&#125;int input_event_to_user(char __user *buffer, const struct input_event *event)&#123; /*如果设置了标志INPUT_COMPAT_TEST就将事件event包装成结构体compat_event*/ if (INPUT_COMPAT_TEST &amp;&amp; !COMPAT_USE_64BIT_TIME) &#123; struct input_event_compat compat_event; compat_event.time.tv_sec = event-&gt;time.tv_sec; compat_event.time.tv_usec = event-&gt;time.tv_usec; compat_event.type = event-&gt;type; compat_event.code = event-&gt;code; compat_event.value = event-&gt;value; /*将包装成的compat_event拷贝到用户空间*/ if (copy_to_user(buffer, &amp;compat_event, sizeof(struct input_event_compat))) return -EFAULT; &#125; else &#123; /*否则，将event拷贝到用户空间*/ if (copy_to_user(buffer, event, sizeof(struct input_event))) return -EFAULT; &#125; return 0;&#125; 如果是可阻塞状态的话，则等待在wait队列上。直到有数据要被处理，当前进程才被唤醒。这很好理解，既然是输入设备，读的话比如读按键，那么必须要有硬件设备有按键按下才会返回按键值，这里还是处于事件处理层，应用程序在这里休眠，那么谁来唤醒? 当然是有按键按下才去唤醒，因此这个工作就交给了设备驱动层。那么找到这个唤醒呢，直接去找不好找。那么可以直接搜索evdev-&gt;wait，搜索结果可知evdev-&gt;wait在evdev_event()函数中被唤醒 注释中说的很清楚，evdev_event()会唤醒此处的读按键进程。那么evdev_event()又是被谁调用?显然是设备驱动层，现在看一个设备层例子，内核中有个按键的例子，gpiokey.c，这只是个例子不针对任何设备，在gpio_keys.c终端处理函数里面 1234567891011121314[-&gt;gpio_keys.c]static irqreturn_t gpio_keys_irq_isr(int irq, void *dev_id)&#123; ...... if (!bdata-&gt;key_pressed) &#123; ...... input_event(input, EV_KEY, button-&gt;code, 1); input_sync(input); ...... &#125; ......&#125; 如此可以看出 在设备的中断服务程序里面，确定事件是什么，然后调用相应的input_handler的event处理函数实际上这就是我们的核心 input_event()是用来上报事件的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263[-&gt;input.c]void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)&#123; unsigned long flags; if (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123; spin_lock_irqsave(&amp;dev-&gt;event_lock, flags); input_handle_event(dev, type, code, value); spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags); &#125;&#125;static void input_handle_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)&#123; ...... if (disposition &amp; INPUT_FLUSH) &#123; if (dev-&gt;num_vals &gt;= 2) input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals); dev-&gt;num_vals = 0; &#125; else if (dev-&gt;num_vals &gt;= dev-&gt;max_vals - 2) &#123; dev-&gt;vals[dev-&gt;num_vals++] = input_value_sync; input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals); dev-&gt;num_vals = 0; &#125;&#125;static void input_pass_values(struct input_dev *dev, struct input_value *vals, unsigned int count)&#123; struct input_handle *handle; struct input_value *v; ...... handle = rcu_dereference(dev-&gt;grab); if (handle) &#123; count = input_to_handler(handle, vals, count); &#125; else &#123; list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node) if (handle-&gt;open) count = input_to_handler(handle, vals, count); &#125; ......&#125;static unsigned int input_to_handler(struct input_handle *handle, struct input_value *vals, unsigned int count)&#123; struct input_handler *handler = handle-&gt;handler; struct input_value *end = vals; struct input_value *v; ...... if (handler-&gt;events) handler-&gt;events(handle, vals, count); else if (handler-&gt;event) for (v = vals; v != end; v++) handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value); return count;&#125; 可以看到最终调用handler-&gt;event()来处理，此处handler即对应evdev。 12[-&gt;input.c]handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value) 所以会调用evdev_event()函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657[-&gt;evdev.c]static void evdev_pass_values(struct evdev_client *client, const struct input_value *vals, unsigned int count, ktime_t mono, ktime_t real)&#123; struct evdev *evdev = client-&gt;evdev; const struct input_value *v; struct input_event event; bool wakeup = false; if (client-&gt;revoked) return; event.time = ktime_to_timeval(client-&gt;clkid == CLOCK_MONOTONIC ? mono : real); /* Interrupts are disabled, just acquire the lock. */ spin_lock(&amp;client-&gt;buffer_lock); for (v = vals; v != vals + count; v++) &#123; event.type = v-&gt;type; event.code = v-&gt;code; event.value = v-&gt;value; __pass_event(client, &amp;event); if (v-&gt;type == EV_SYN &amp;&amp; v-&gt;code == SYN_REPORT) wakeup = true; &#125; spin_unlock(&amp;client-&gt;buffer_lock); if (wakeup) wake_up_interruptible(&amp;evdev-&gt;wait);&#125;static void evdev_events(struct input_handle *handle, const struct input_value *vals, unsigned int count)&#123; struct evdev *evdev = handle-&gt;private; struct evdev_client *client; ...... if (client) evdev_pass_values(client, vals, count, time_mono, time_real); else list_for_each_entry_rcu(client, &amp;evdev-&gt;client_list, node) evdev_pass_values(client, vals, count, time_mono, time_real); rcu_read_unlock();&#125;static void evdev_event(struct input_handle *handle, unsigned int type, unsigned int code, int value)&#123; struct input_value vals[] = &#123; &#123; type, code, value &#125; &#125;; evdev_events(handle, vals, 1);&#125; 最终唤醒evdev_read()将数据拷贝到用户空间。 （五）、Input 事件上报过程5.1、Input 事件产生当按下触摸屏时，进入触摸屏按下中断，开始ad转换，ad转换完成进入ad完成中断，在这个终端中将事件发送出去，会调用以下函数上报事件: 12345678910input_report_key(input_dev, BTN_TOUCH, 1); input_report_abs(input_dev, ABS_POSITION_X, x); input_report_abs(input_dev, ABS_POSITION_Y, y); input_sync(input_dev); 这两个函数调用了 input_event(dev, EV_ABS, code, value) 所有的事件报告函数都调用这个函数。 123456789101112131415[-&gt;input.h]static inline void input_report_key(struct input_dev *dev, unsigned int code, int value)&#123; input_event(dev, EV_KEY, code, !!value);&#125;static inline void input_report_abs(struct input_dev *dev, unsigned int code, int value)&#123; input_event(dev, EV_ABS, code, value);&#125;static inline void input_sync(struct input_dev *dev)&#123; input_event(dev, EV_SYN, SYN_REPORT, 0);&#125; 5.2、Input 事件报告input_event 函数前面已经分析过，这里不再分析。 123[-&gt;input.c:input_pass_values]for (v = vals; v != end; v++) handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value); 最终会调用handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value) 来将数据传递给用户空间等待读取数据的进程 1copy_to_user(buffer, event, sizeof(struct input_event)) （六）、Android Input子系统输入子系统的系统架构如下图所示：详细分析请参考：Android 7.1.2 (Android N) Android 输入子系统-Input System 分析 （七）、Input 设备驱动层实例（Synaptics）触摸屏也是用上面这一套框架来操作的。右边需要一个“evdev.c”文件。左边要分配一个“input_dev”结构。接着就看上图的硬件设备左边的过程：分配一个“input_dev”结构体 –&gt; 设置这个”input_dev”结构体 –&gt; 注册这个”input_dev”结构体 –&gt; 硬件相关的操作。 编写Input驱动一般框架: Google Pixel、Pixel XL 触控驱动模块型号为Synaptics（ClearPad S3708），源码：Synaptics 触摸屏驱动源码 Makefile： 123456789101112[-&gt;drivers/input/touchscreen/synaptics_dsx_htc_2.6/Makefile]## Makefile for the Synaptics DSX touchscreen driver.## Each configuration option enables a list of files.obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_I2C_HTC_v26) += synaptics_dsx_i2c.oobj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_SPI_HTC_v26) += synaptics_dsx_spi.oobj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_CORE_HTC_v26) += synaptics_dsx_core.oobj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV_HTC_v26) += synaptics_dsx_rmi_dev.o...... 抓取kernel log：可知input 驱动名为synaptics_dsxv26，全局搜索可知synaptics_rmi4_f12_init在[-&gt;synaptics_dsx_core.c]中。 123456[ 1.362728] c3 1 [TP]:synaptics_rmi4_f12_init: Function 12 max x = 1079 max y = 1919 Rx: 16 Tx: 28[ 1.363344] c3 1 [TP]synaptics_rmi4_f12_init:Wakeup Gesture range (0,0) -&gt; (1079,1919)[ 1.363623] c3 1 [TP]:synaptics_rmi4_f12_init report data init done[ 1.371945] c3 1 [TP]:synaptics_rmi4_query_device: chip_id:3708, firmware_id:2433782[ 1.372865] c3 1 [TP]:synaptics_rmi4_query_device: config_version: 5331763200190000000000000000000000000000000000000000000000000000[ 1.373249] c3 1 input: synaptics_dsxv26 as /devices/soc/7577000.i2c/i2c-3/3-0020/input/input3 查看input设备：adb shell cat /proc/bus/input/devices123456789101112I: Bus=0000 Vendor=0000 Product=0003 Version=2066N: Name=&quot;synaptics_dsxv26&quot;P: Phys=synaptics_dsx/touch_inputS: Sysfs=/devices/soc/7577000.i2c/i2c-3/3-0020/input/input3U: Uniq=H: Handlers=mdss_fb kgsl event3 B: PROP=2B: EV=bB: KEY=8000 0 0B: ABS=663800000000000对应：/dev/input/event3 7.1、分配Input_dev结构体7.1.1、synaptics_rmi4_f12_init()首先看一下初始化过程： 123456789101112131415161718192021222324[-&gt;synaptics_dsx_core.c]static struct platform_driver synaptics_rmi4_driver = &#123; .driver = &#123; .name = PLATFORM_DRIVER_NAME, .owner = THIS_MODULE,#ifdef CONFIG_PM .pm = &amp;synaptics_rmi4_dev_pm_ops,#endif &#125;, .probe = synaptics_rmi4_probe, .remove = synaptics_rmi4_remove,&#125;;static int __init synaptics_rmi4_init(void)&#123; int retval; retval = synaptics_rmi4_bus_init(); if (retval) return retval; return platform_driver_register(&amp;synaptics_rmi4_driver);&#125;module_init(synaptics_rmi4_init); 首先注册平台驱动，当驱动和设备匹配成功，继续看一下synaptics_rmi4_probe()函数 7.1.2、synaptics_rmi4_probe()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394[-&gt;synaptics_dsx_core.c]static int synaptics_rmi4_probe(struct platform_device *pdev)&#123; int retval, len; unsigned char attr_count; struct synaptics_rmi4_data *rmi4_data; const struct synaptics_dsx_hw_interface *hw_if; const struct synaptics_dsx_board_data *bdata; struct dentry *temp; //初始化platform_data、board_data、rmi4_data hw_if = pdev-&gt;dev.platform_data; bdata = hw_if-&gt;board_data; rmi4_data = kzalloc(sizeof(*rmi4_data), GFP_KERNEL); rmi4_data-&gt;pdev = pdev; rmi4_data-&gt;current_page = MASK_8BIT; rmi4_data-&gt;hw_if = hw_if; rmi4_data-&gt;touch_stopped = false; rmi4_data-&gt;sensor_sleep = false; rmi4_data-&gt;irq_enabled = false; rmi4_data-&gt;fw_updating = false; rmi4_data-&gt;fingers_on_2d = false; rmi4_data-&gt;update_coords = true; rmi4_data-&gt;write_buf = devm_kzalloc(&amp;pdev-&gt;dev, I2C_WRITE_BUF_MAX_LEN, GFP_KERNEL); rmi4_data-&gt;write_buf_len = I2C_WRITE_BUF_MAX_LEN; rmi4_data-&gt;irq_enable = synaptics_rmi4_irq_enable; rmi4_data-&gt;reset_device = synaptics_rmi4_reset_device; mutex_init(&amp;(rmi4_data-&gt;rmi4_io_ctrl_mutex)); mutex_init(&amp;(rmi4_data-&gt;rmi4_reset_mutex)); retval = synaptics_dsx_regulator_configure(rmi4_data); retval = synaptics_dsx_regulator_enable(rmi4_data, true); platform_set_drvdata(pdev, rmi4_data); if (bdata-&gt;gpio_config) &#123; retval = synaptics_rmi4_set_gpio(rmi4_data); &#125; else &#123; retval = synaptics_dsx_pinctrl_init(rmi4_data); if (!retval &amp;&amp; rmi4_data-&gt;ts_pinctrl) &#123; retval = pinctrl_select_state(rmi4_data-&gt;ts_pinctrl, rmi4_data-&gt;pinctrl_state_active); &#125; retval = synaptics_dsx_gpio_configure(rmi4_data, true); &#125; if (bdata-&gt;fw_name) &#123; len = strlen(bdata-&gt;fw_name); strlcpy(rmi4_data-&gt;fw_name, bdata-&gt;fw_name, len + 1); &#125; //分配Input_dev结构体，设置，注册 retval = synaptics_rmi4_set_input_dev(rmi4_data); ...... rmi4_data-&gt;irq = gpio_to_irq(bdata-&gt;irq_gpio); //请求中断，并设置中断处理函数synaptics_rmi4_irq retval = synaptics_rmi4_irq_enable(rmi4_data, true); if (!exp_data.initialized) &#123; mutex_init(&amp;exp_data.mutex); INIT_LIST_HEAD(&amp;exp_data.list); exp_data.initialized = true; &#125; exp_data.workqueue = create_singlethread_workqueue(\"dsx_exp_workqueue\"); INIT_DELAYED_WORK(&amp;exp_data.work, synaptics_rmi4_exp_fn_work); exp_data.rmi4_data = rmi4_data; exp_data.queue_work = true; queue_delayed_work(exp_data.workqueue, &amp;exp_data.work, msecs_to_jiffies(EXP_FN_WORK_DELAY_MS)); rmi4_data-&gt;dir = debugfs_create_dir(DEBUGFS_DIR_NAME, NULL); ...... for (attr_count = 0; attr_count &lt; ARRAY_SIZE(attrs); attr_count++) &#123; retval = sysfs_create_file(&amp;rmi4_data-&gt;input_dev-&gt;dev.kobj, &amp;attrs[attr_count].attr); ...... &#125; synaptics_secure_touch_init(rmi4_data); synaptics_secure_touch_stop(rmi4_data, 1); return retval; .......&#125; 7.1.3、分配Input_dev结构体12345678910[-&gt;synaptics_dsx_core.c]static int synaptics_rmi4_set_input_dev(struct synaptics_rmi4_data *rmi4_data)&#123; int retval; const struct synaptics_dsx_board_data *bdata = rmi4_data-&gt;hw_if-&gt;board_data; rmi4_data-&gt;input_dev = input_allocate_device(); ......&#125; 7.2、设置支持事件类型 set_bit(EV_SYN, evbit)、set_bit(EV_KEY, evbit)、set_bit(EV_ABS,evbit) ……1234567891011121314151617181920212223242526272829[-&gt;synaptics_dsx_core.c]static int synaptics_rmi4_set_input_dev(struct synaptics_rmi4_data *rmi4_data)&#123; int retval; const struct synaptics_dsx_board_data *bdata = rmi4_data-&gt;hw_if-&gt;board_data; rmi4_data-&gt;input_dev = input_allocate_device(); ...... retval = synaptics_rmi4_query_device(rmi4_data); .... //#define PLATFORM_DRIVER_NAME \"synaptics_dsxv26\"(synaptics_dsx_v2_6.h) rmi4_data-&gt;input_dev-&gt;name = PLATFORM_DRIVER_NAME; rmi4_data-&gt;input_dev-&gt;phys = INPUT_PHYS_NAME; rmi4_data-&gt;input_dev-&gt;id.product = SYNAPTICS_DSX_DRIVER_PRODUCT; rmi4_data-&gt;input_dev-&gt;id.version = SYNAPTICS_DSX_DRIVER_VERSION; rmi4_data-&gt;input_dev-&gt;dev.parent = rmi4_data-&gt;pdev-&gt;dev.parent; input_set_drvdata(rmi4_data-&gt;input_dev, rmi4_data); set_bit(EV_SYN, rmi4_data-&gt;input_dev-&gt;evbit); set_bit(EV_KEY, rmi4_data-&gt;input_dev-&gt;evbit); set_bit(EV_ABS, rmi4_data-&gt;input_dev-&gt;evbit); set_bit(BTN_TOUCH, rmi4_data-&gt;input_dev-&gt;keybit); set_bit(BTN_TOOL_FINGER, rmi4_data-&gt;input_dev-&gt;keybit); synaptics_rmi4_set_params(rmi4_data); ......&#125; 7.3、注册设备input_register_device()此处即与前面kernel log呼应：注册名为 synaptics_dsxv26 的输入设备123456789101112131415161718192021222324252627282930[-&gt;synaptics_dsx_core.c]static int synaptics_rmi4_set_input_dev(struct synaptics_rmi4_data *rmi4_data)&#123; int retval; const struct synaptics_dsx_board_data *bdata = rmi4_data-&gt;hw_if-&gt;board_data; rmi4_data-&gt;input_dev = input_allocate_device(); ...... retval = synaptics_rmi4_query_device(rmi4_data); .... //#define PLATFORM_DRIVER_NAME \"synaptics_dsxv26\"(synaptics_dsx_v2_6.h) rmi4_data-&gt;input_dev-&gt;name = PLATFORM_DRIVER_NAME; rmi4_data-&gt;input_dev-&gt;phys = INPUT_PHYS_NAME; rmi4_data-&gt;input_dev-&gt;id.product = SYNAPTICS_DSX_DRIVER_PRODUCT; rmi4_data-&gt;input_dev-&gt;id.version = SYNAPTICS_DSX_DRIVER_VERSION; rmi4_data-&gt;input_dev-&gt;dev.parent = rmi4_data-&gt;pdev-&gt;dev.parent; input_set_drvdata(rmi4_data-&gt;input_dev, rmi4_data); set_bit(EV_SYN, rmi4_data-&gt;input_dev-&gt;evbit); set_bit(EV_KEY, rmi4_data-&gt;input_dev-&gt;evbit); set_bit(EV_ABS, rmi4_data-&gt;input_dev-&gt;evbit); set_bit(BTN_TOUCH, rmi4_data-&gt;input_dev-&gt;keybit); set_bit(BTN_TOOL_FINGER, rmi4_data-&gt;input_dev-&gt;keybit); synaptics_rmi4_set_params(rmi4_data); ...... retval = input_register_device(rmi4_data-&gt;input_dev);&#125; 7.4、硬件相关操作当触摸屏按下，会产生中断，进而调用中断处理函数synaptics_rmi4_irq(): 123456789101112131415161718[-&gt;synaptics_dsx_core.c]static irqreturn_t synaptics_rmi4_irq(int irq, void *data)&#123; struct synaptics_rmi4_data *rmi4_data = data; const struct synaptics_dsx_board_data *bdata = rmi4_data-&gt;hw_if-&gt;board_data; if (IRQ_HANDLED == synaptics_filter_interrupt(data)) return IRQ_HANDLED; if (gpio_get_value(bdata-&gt;irq_gpio) != bdata-&gt;irq_on_state) goto exit; synaptics_rmi4_sensor_report(rmi4_data, true);exit: return IRQ_HANDLED;&#125; 进一步调用synaptics_rmi4_sensor_report(rmi4_data, true)处理数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[-&gt;synaptics_dsx_core.c]static void synaptics_rmi4_sensor_report(struct synaptics_rmi4_data *rmi4_data, bool report)&#123; int retval; unsigned char data[MAX_INTR_REGISTERS + 1]; unsigned char *intr = &amp;data[1]; bool was_in_bl_mode; struct synaptics_rmi4_f01_device_status status; struct synaptics_rmi4_fn *fhandler; struct synaptics_rmi4_exp_fhandler *exp_fhandler; struct synaptics_rmi4_device_info *rmi; rmi = &amp;(rmi4_data-&gt;rmi4_mod_info); .... retval = synaptics_rmi4_reg_read(rmi4_data, rmi4_data-&gt;f01_data_base_addr, data, rmi4_data-&gt;num_of_intr_regs + 1); ...... //读取寄存器数据 status.data[0] = data[0]; if (status.status_code == STATUS_CRC_IN_PROGRESS) &#123; retval = synaptics_rmi4_check_status(rmi4_data, &amp;was_in_bl_mode); .... retval = synaptics_rmi4_reg_read(rmi4_data, rmi4_data-&gt;f01_data_base_addr, status.data, sizeof(status.data)); ...... &#125; if (status.unconfigured &amp;&amp; !status.flash_prog) &#123; pr_notice(\"%s: spontaneous reset detected\\n\", __func__); &#125; //synaptics_rmi4_report_touch()上报数据 if (!list_empty(&amp;rmi-&gt;support_fn_list)) &#123; list_for_each_entry(fhandler, &amp;rmi-&gt;support_fn_list, link) &#123; if (fhandler-&gt;num_of_data_sources) &#123; if (fhandler-&gt;intr_mask &amp; intr[fhandler-&gt;intr_reg_num]) &#123; synaptics_rmi4_report_touch(rmi4_data, fhandler); &#125; &#125; &#125; &#125; mutex_lock(&amp;exp_data.mutex); if (!list_empty(&amp;exp_data.list)) &#123; list_for_each_entry(exp_fhandler, &amp;exp_data.list, link) &#123; if (!exp_fhandler-&gt;insert &amp;&amp; !exp_fhandler-&gt;remove &amp;&amp; (exp_fhandler-&gt;exp_fn-&gt;attn != NULL)) exp_fhandler-&gt;exp_fn-&gt;attn(rmi4_data, intr[0]); &#125; &#125; mutex_unlock(&amp;exp_data.mutex); return;&#125; 7.4.1、Input数据上报：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112[-&gt;synaptics_dsx_core.c]static void synaptics_rmi4_report_touch(struct synaptics_rmi4_data *rmi4_data, struct synaptics_rmi4_fn *fhandler)&#123; ...... switch (fhandler-&gt;fn_number) &#123; ...... case SYNAPTICS_RMI4_F12: touch_count_2d = synaptics_rmi4_f12_abs_report(rmi4_data, fhandler); if (touch_count_2d) rmi4_data-&gt;fingers_on_2d = true; else rmi4_data-&gt;fingers_on_2d = false; break; ...... default: break; &#125; return;&#125;static int synaptics_rmi4_f12_abs_report(struct synaptics_rmi4_data *rmi4_data, struct synaptics_rmi4_fn *fhandler)&#123; int retval; unsigned char touch_count = 0; /* number of touch points */ unsigned char index; unsigned char finger; unsigned char fingers_to_process; unsigned char finger_status; unsigned char size_of_2d_data; unsigned char gesture_type; unsigned short data_addr; int x; int y; int wx; int wy; int temp; struct synaptics_rmi4_f12_extra_data *extra_data; struct synaptics_rmi4_f12_finger_data *data; struct synaptics_rmi4_f12_finger_data *finger_data; static unsigned char finger_presence; static unsigned char stylus_presence; fingers_to_process = fhandler-&gt;num_of_data_points; data_addr = fhandler-&gt;full_addr.data_base; extra_data = (struct synaptics_rmi4_f12_extra_data *)fhandler-&gt;extra; size_of_2d_data = sizeof(struct synaptics_rmi4_f12_finger_data); ...... retval = synaptics_rmi4_reg_read(rmi4_data, data_addr + extra_data-&gt;data1_offset, (unsigned char *)fhandler-&gt;data, fingers_to_process * size_of_2d_data); if (retval &lt; 0) return 0; data = (struct synaptics_rmi4_f12_finger_data *)fhandler-&gt;data; mutex_lock(&amp;(rmi4_data-&gt;rmi4_report_mutex)); //根据触摸点数量循环上报input数据 for (finger = 0; finger &lt; fingers_to_process; finger++) &#123; finger_data = data + finger; finger_status = finger_data-&gt;object_type_and_status; x = (finger_data-&gt;x_msb &lt;&lt; 8) | (finger_data-&gt;x_lsb); y = (finger_data-&gt;y_msb &lt;&lt; 8) | (finger_data-&gt;y_lsb); if (rmi4_data-&gt;hw_if-&gt;board_data-&gt;swap_axes) &#123; temp = x; x = y; y = temp; temp = wx; wx = wy; wy = temp; &#125; if (rmi4_data-&gt;hw_if-&gt;board_data-&gt;x_flip) x = rmi4_data-&gt;sensor_max_x - x; if (rmi4_data-&gt;hw_if-&gt;board_data-&gt;y_flip) y = rmi4_data-&gt;sensor_max_y - y; switch (finger_status) &#123; case F12_FINGER_STATUS: case F12_GLOVED_FINGER_STATUS: input_report_key(rmi4_data-&gt;input_dev, BTN_TOUCH, 1); input_report_key(rmi4_data-&gt;input_dev, BTN_TOOL_FINGER, 1); input_report_abs(rmi4_data-&gt;input_dev, ABS_MT_POSITION_X, x); input_report_abs(rmi4_data-&gt;input_dev, ABS_MT_POSITION_Y, y); ...... &#125; ...... input_sync(rmi4_data-&gt;input_dev); mutex_unlock(&amp;(rmi4_data-&gt;rmi4_report_mutex)); return touch_count;&#125; 调用input_report_key()、input_report_abs()、input_sync() 上报、同步数据。 （八）、参考文档(特别感谢各位前辈的分析和图示)：Linux/Android——Input系统Android Input子系统浅谈Android(Linux) 输入子系统解析input子系统分析之三:驱动模块Linux驱动框架之——Input子系统input子系统事件处理层(evdev)的环形缓冲区linux input输入子系统分析《四》：input子系统整体流程全面分析Linux input子系统分析之二：深入剖析input_handler、input_core、input_device","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Android WindowManagerService 窗口管理服务 分析 [i.wonder~]","slug":"Android-7-1-2-Android-N-Android-WindowManagerService-窗口管理服务分析-i-wonder","date":"2018-02-28T16:00:00.000Z","updated":"2018-03-23T07:15:28.000Z","comments":true,"path":"2018/03/01/Android-7-1-2-Android-N-Android-WindowManagerService-窗口管理服务分析-i-wonder/","link":"","permalink":"http://zhoujinjian.cc/2018/03/01/Android-7-1-2-Android-N-Android-WindowManagerService-窗口管理服务分析-i-wonder/","excerpt":"窗口管理系统WMS是Android中的主要子系统之一，它涉及到App中组件的管理，系统和应用窗口的管理和绘制等工作。由于其涉及模块众多，且与用户体验密切相关，所以它也是Android当中最为复杂的子系统之一。一个App从启动到主窗口显示出来，需要App，ActivityManagerService（AMS），WindowManagerService（WMS），SurfaceFlinger（SF）等几个模块相互合作。App负责业务逻辑，绘制自己的视图；AMS管理组件、进程信息和Activity的堆栈及状态等等；WMS管理Activity对应的窗口及子窗口，还有系统窗口等；SF用于管理图形缓冲区，将App绘制的东西合成渲染在屏幕上。","text":"窗口管理系统WMS是Android中的主要子系统之一，它涉及到App中组件的管理，系统和应用窗口的管理和绘制等工作。由于其涉及模块众多，且与用户体验密切相关，所以它也是Android当中最为复杂的子系统之一。一个App从启动到主窗口显示出来，需要App，ActivityManagerService（AMS），WindowManagerService（WMS），SurfaceFlinger（SF）等几个模块相互合作。App负责业务逻辑，绘制自己的视图；AMS管理组件、进程信息和Activity的堆栈及状态等等；WMS管理Activity对应的窗口及子窗口，还有系统窗口等；SF用于管理图形缓冲区，将App绘制的东西合成渲染在屏幕上。 【博客原图链接】源码（部分）：/frameworks/base/services/core/java/com/android/server/am/ ActivityStack.java ActivityManagerService.java ActivityStackSupervisor.java ActivityStarter.java ActivityRecord.java /frameworks/base/core/java/android/view/ WindowManagerImpl.java ViewManager.java WindowManagerGlobal.java ViewRootImpl.java Choreographer.java IWindowSession.aidl DisplayEventReceiver.java SurfaceControl.java Surface.java SurfaceSession.java /frameworks/base/services/core/java/com/android/server/wm/ WindowManagerService.java AppWindowAnimator.java AppTransition.java AppWindowToken.java Session.java WindowState.java WindowAnimator.java WindowStateAnimator.java WindowSurfacePlacer.java WindowSurfaceController.java 【博客原图链接】我们先看一下窗口启动、退出过程动态图，之后再详细分析： （一）、Window 组织方式ActivityManagerService（AMS），WindowManagerService（WMS），SurfaceFlinger（SF）等几个模块相互合作。App负责业务逻辑，绘制自己的视图；AMS管理组件、进程信息和Activity的堆栈及状态等等；WMS管理Activity对应的窗口及子窗口，还有系统窗口等；SF用于管理图形缓冲区，将App绘制的东西合成渲染在屏幕上。窗口管理系统主要框架： 主要对象功能介绍： WindowManagerService负责完成窗口的管理工作 WindowState和应用端窗口一一对应，应用调用WMS添加窗口时，最终会在WindowManagerService.addWindow()创建一个WindowState与之一一对应 WindowToken是一个句柄，保存了所有具有同一个token的WindowState。应用请求WindowManagerService添加窗口的时候，提供了一个token，该token标识了被添加窗口的归属，WindowManagerService为该token生成一个WindowToken对象，所有token相同的WindowState被关联到同一个WindowToken，如输入法添加窗口时，会传递一个IBinder mCurToken，墙纸服务添加窗口时，会传递一个WallpaperConnection::final Binder mToken。 AppWindowToken继承于WindowToken，专门用于标识一个Activity。AppWindowToken里的token实际上就是指向了一个Activity。ActivityManagerService通知应用启动的时候，在服务端生成一个token用于标识该Activity，并且把该token传递到应用客户端，客户端的Activity在申请添加窗口时，以该token作为标识传递到WindowManagerService。同一个Activity中的主窗口、对话框窗口、菜单窗口都关联到同一个AppWindowToken。 Session表示一个客户端和服务端的交互会话。一般来说不同的应用通过不同的会话来和WindowManagerService交互，但是处于同一个进程的不同应用通过同一个Session来交互。 1.1、Android Token介绍Token是ActivityRecord的内部静态类，我们先来看下Token的继承关系，Token extends IApplicationToken.Stub，从IApplicationToken.Stub类进行继承，根据Binder的机制可以知道Token是一个匿名Binder实体类，这个匿名Binder实体会传递给其他进程，其他进程会拿到Token的代理端。 我们知道匿名Binder有两个比较重要的用途，一个是拿到Binder代理端后可跨Binder调用实体端的函数接口，另一个作用便是在多个进程中标识同一个对象。往往这两个作用是同时存在的，比如我们这里研究的Token就同时存在这两个作用，但最重要的便是后者，Token标识了一个ActivityRecord对象，即间接标识了一个Activity。 Token梳理：分析源码，我们发现，大多数 token 的对象，都表示一个 IBinder 对象。提到 IBinder，大家一点也不陌生，就是 Android 的 IPC 通信机制。在创建窗口过程中，涉及到的 IPC 通信，无非包含两方面，一个是 WmS 用来跟应用所在的进程进行通信的 ViewRootImpl.W 类的对象，另一个是指向一个 ActivityRecord 的对象，自然应该是WMS用来跟 AMS进行通信的了。我们梳理了一下，token 以下几处的定义，分别来讲讲这里的 token 代表什么。 分析一下 View 的 AttachInfo 的赋值。ViewRootImpl 在构建方法里，会初始化一个 AttachInfo 实例，把它的 Session，以及 W类对象赋值给 AttachInfo。分析可以看到，AttachInfo 中的 mWindowToken，与mWindow 都是指向 ViewRootImpl 中的 mWindow(W类实例)。当一个 View attach 到窗口后，ViewRootImpl会执行performTraversals，如果发现是首次调用会，会把自己的 mAttachInfo 传递给根 View（通过dispatchAttachedToWindow），告诉 View 树现在已经 attch to Window 了，马上可以显示了。根 View（一般是 ViewGroup）会把这个信息，遍历地传递给 View 树中的每一个子 View，这样每个 View 的 mAttachInfo 都被赋值为 ViewRootImp 的 mAttachInfo了。 1.1.1、Token对象的创建下面这个图是Token的传递，首先会传递到WMS中，接着会传递到应用进程ActivityThread中，下面来具体分析这个传递流程。总体流程图： 我们之前分析：【Android 7.1.2 (Android N) Activity启动流程分析】在启动Activity过程中会调用ActivityStarter.startActivityLocked() 123456789101112131415161718192021222324[-&gt;ActivityStarter.java] final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) &#123; ...... ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; ...... ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, mSupervisor, container, options, sourceRecord); ...... try &#123; err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); &#125; return err;&#125; 可以看到在startActivityLocked()中创建了一个ActivityRecord对象1234567891011121314[-&gt;ActivityRecord.java]final IApplicationToken.Stub appToken; // window manager tokenActivityRecord(ActivityManagerService _service, ProcessRecord _caller, int _launchedFromUid, String _launchedFromPackage, Intent _intent, String _resolvedType, ActivityInfo aInfo, Configuration _configuration, ActivityRecord _resultTo, String _resultWho, int _reqCode, boolean _componentSpecified, boolean _rootVoiceInteraction, ActivityStackSupervisor supervisor, ActivityContainer container, ActivityOptions options, ActivityRecord sourceRecord) &#123; service = _service; appToken = new Token(this, service); ...... &#125; 在ActivityRecord的构造函数中创建，标识着当前这个ActivityRecord，即间接代表着一个Activity。 1.1.2、AMS调用WMS的addAPPToken()接口在启动一个Activity时，会调用startActivityLocked()来在WMS中添加一个AppWindowToken对象startActivityLocked()创建ActivityRecord对象后会继续调用startActivityUnchecked()方法。 12345678[-&gt;ActivityStarter.java]private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) &#123; ...... mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions); ...... &#125; 12345678910111213141516171819[-&gt;ActivityStack.java]final void startActivityLocked(ActivityRecord r, boolean newTask, boolean keepCurTransition, ActivityOptions options) &#123; ...... addConfigOverride(r, task); ...... &#125; void addConfigOverride(ActivityRecord r, TaskRecord task) &#123; final Rect bounds = task.updateOverrideConfigurationFromLaunchBounds(); // 跳转到WMS mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind, bounds, task.mOverrideConfig, task.mResizeMode, r.isAlwaysFocusable(), task.isHomeTask(), r.appInfo.targetSdkVersion, r.mRotationAnimationHint); r.taskConfigOverride = task.mOverrideConfig; &#125; 我们继续看下WindowManager.addAppToken()方法 123456789101112131415161718192021222324252627282930313233343536373839404142[-&gt;WindowManagerService.java] @Override public void addAppToken(int addPos, IApplicationToken token, int taskId, int stackId, int requestedOrientation, boolean fullscreen, boolean showForAllUsers, int userId, int configChanges, boolean voiceInteraction, boolean launchTaskBehind, Rect taskBounds, Configuration config, int taskResizeMode, boolean alwaysFocusable, boolean homeTask, int targetSdkVersion, int rotationAnimationHint) &#123; ...... synchronized(mWindowMap) &#123; AppWindowToken atoken = findAppWindowToken(token.asBinder()); if (atoken != null) &#123; Slog.w(TAG_WM, \"Attempted to add existing app token: \" + token); return; &#125; //根据ActivityRecord中IApplicationToken.Stub的代理，创建AppWindowToken atoken = new AppWindowToken(this, token, voiceInteraction); atoken.inputDispatchingTimeoutNanos = inputDispatchingTimeoutNanos; atoken.appFullscreen = fullscreen; atoken.showForAllUsers = showForAllUsers; atoken.targetSdk = targetSdkVersion; atoken.requestedOrientation = requestedOrientation; atoken.layoutConfigChanges = (configChanges &amp; (ActivityInfo.CONFIG_SCREEN_SIZE | ActivityInfo.CONFIG_ORIENTATION)) != 0; atoken.mLaunchTaskBehind = launchTaskBehind; atoken.mAlwaysFocusable = alwaysFocusable; atoken.mRotationAnimationHint = rotationAnimationHint; Task task = mTaskIdToTask.get(taskId); if (task == null) &#123; task = createTaskLocked(taskId, stackId, userId, atoken, taskBounds, config); &#125; task.addAppToken(addPos, atoken, taskResizeMode, homeTask); //将atoken放入到mTokenMap中，等应用程序addWindow时，进行身份验证 //其中token.asBinder()是IApplicationToken.Stub的代理，atoken就是根据代理，得到对应AppWindowToken mTokenMap.put(token.asBinder(), atoken); // Application tokens start out hidden. atoken.hidden = true; atoken.hiddenRequested = true; &#125; &#125; 1.1.3、AMS跨Binder调用应用进程的scheduleLaunchActivity()将Token传递给上层应用进程当框架通过ApplicationThread的代理回调到ActivityThread的时候，将对应的步骤一种生成的token代理传入。ActivityStackSupervisor.realStartActivityLocked()1234567891011121314 [-&gt;ActivityStackSupervisor.java] final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ...... app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ...... return true;&#125; 这里通过调用IApplicationThread的方法实现的，这里调用的是scheduleLaunchActivity()方法，所以真正执行的是ActivityThread中的scheduleLaunchActivity()。 12345678910111213141516171819[-&gt; ActivityThread.java :ApplicationThread] @Override public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); //传递给了ActivityThread的token，这个token就是IApplicationToken.Stub的代理 r.token = token; ...... updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 1.1.4、Activity窗口添加过程详细过程请查看：【Android 7.1.2 (Android N) Activity-Window加载显示流程分析】1234567891011121314151617181920212223242526272829303132333435[-&gt;ActivityThread.java] final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ActivityClientRecord r = mActivities.get(token); ...... r = performResumeActivity(token, clearHide, reason); ...... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; //获得为当前Activity创建的窗口PhoneWindow对象 r.window = r.activity.getWindow(); //获取为窗口创建的视图DecorView对象 View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); //在attach函数中就为当前Activity创建了WindowManager对象 ViewManager wm = a.getWindowManager(); //得到该视图对象的布局参数 WindowManager.LayoutParams l = r.window.getAttributes(); //将视图对象保存到Activity的成员变量mDecor中 a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; ...... if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; //将创建的视图对象DecorView添加到Activity的窗口管理器中 wm.addView(decor, l); &#125; ...... if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; ...... &#125;&#125; 进而层层调用到：ViewRootImpl.setView() 12[-&gt;ViewRootImpl.java]WindowManager.LayoutParams l = r.window.getAttributes(); ViewRootImpl.setView()函数中添加Activity窗口时在参数mWindowAttributes中携带Token代理对象123456789101112131415[-&gt;ViewManager.java]public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel) &#123; ...... boolean addToken = false; //attrs这个是应用程序ActivityClientRecord中传递过来的参数，其中的attrs.token就是步骤三种的r.token WindowToken token = mTokenMap.get(attrs.token); ...... win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); mWindowMap.put(client.asBinder(), win); ...... &#125; 根据Binder机制可以知道从上层应用传递过来的Token代理对象会转换成SystemServer进程中的Token本地对象，后者与第2步中从Token对象是同一个对象，所以上面调用mTokenMap.get(attrs.token)时便能返回正确返回一个WindowToken（这个WindowToken其实是一个APPWindowToken），这样添加的窗口也就跟Activity关联上了。 1.2、WMS组织方式Activity管理服务ActivityManagerService中每一个ActivityRecord对象在Window管理服务WindowManagerService中都对应有一个AppWindowToken对象。 此外，在输入法管理服务InputMethodManagerService中，每一个输入法窗口都对应有一个Binder对象，这个Binder对象在Window管理服务WindowManagerService又对应有一个WindowToken对象。 与输入法窗口类似，在壁纸管理服务WallpaperManagerService中，每一个壁纸窗口都对应有一个Binder对象，这个Binder对象在Window管理服务WindowManagerService也对应有一个WindowToken对象。 在Window管理服务WindowManagerService中，无论是AppWindowToken对象，还是WindowToken对象，它们都是用来描述一组有着相同令牌的窗口的，每一个窗口都是通过一个WindowState对象来描述的。例如，一个Activity组件窗口可能有一个启动窗口（Starting Window），还有若干个子窗口，那么这些窗口就会组成一组，并且都是以Activity组件在Window管理服务WindowManagerService中所对应的AppWindowToken对象为令牌的。从抽象的角度来看，就是在Window管理服务WindowManagerService中，每一个令牌（AppWindowToken或者WindowToken）都是用来描述一组窗口（WindowState）的，并且每一个窗口的子窗口也是与它同属于一个组，即都有着相同的令牌。 其中，Activity Stack是在ActivityManagerService服务中创建的，Token List和Window Stack是在WindowManagerService中创建的，而Binder for IM和Binder for WP分别是在InputMethodManagerService服务和WallpaperManagerService服务中创建的，用来描述一个输入法窗口和一个壁纸窗口。 1.3、WMS窗口类型添加一个窗口是通过 WindowManagerGlobal.addView()来完成的，分析 addView 方法的参数，有三个参数是必不可少的，view，params，以及 display。而 display 一般直接取 WindowMnagerImpl 中的 mDisplay，表示要输出的显示设备。view 自然表示要显示的 View，而 params 是 WindowManager.LayoutParams，用来描述这个 view 的些窗口属性，其中一个重要的参数 type，用来描述窗口的类型。 12345678910111213[-&gt;WindowManagerGlobal] public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; if (display == null) &#123; throw new IllegalArgumentException(\"display must not be null\"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\"); &#125; ``` }1234567打开WindowManager类，看到静态内部类。``` java[-&gt;WindowManager]public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable &#123;......&#125; 可以看到在LayoutParams中，有2个比较重要的参数: flags,type。我们简要的分析一下flags,该参数表示Window的属性，它有很多选项，通过这些选项可以控制Window的显示特性，这里主要介绍几个比较常用的选项。 FLAG_NOT_FOCUSABLE表示Window不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层具有焦点的Window。 FLAG_NOT_TOUCH_MODAL系统会将当前Window区域以外的单击事件传递给底层的Window，当前Window区域以内的单击事件则自己处理，这个标记很重要，一般来说都需要开启此标记，否则其他Window将无法接收到单击事件。 FLAG_SHOW_WHEN_LOCKED开启此模式可以让Window显示在锁屏的界面上。 Type参数表示Window的类型，Window有三种类型，分别是应用Window、子Window、系统Window。应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的PopupWindow就是一个子Window。有些系统Window是需要声明权限才能创建的Window，比如Toast和系统状态栏这些都是系统Window。 1.3.1、应用窗口Activity 对应的窗口类型是应用窗口， 所有 Activity 默认的窗口类型是 TYPE_BASE_APPLICATION。WindowManager 的 LayoutParams 的默认类型是 TYPE_APPLICATION。 Dialog 并没有设置type，所以也是默认的窗口类型即 TYPE_APPLICATION。 1234567[-&gt;WindowManager.LayoutParams]public LayoutParams() &#123; super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); type = TYPE_APPLICATION; format = PixelFormat.OPAQUE;&#125; type层级 类型 FIRST_APPLICATION_WINDOW=1 开始应用程序窗口，第一个普通应用窗口 TYPE_BASE_APPLICATION=1 所有程序窗口的base窗口，其他应用程序窗口都显示在它上面 TYPE_APPLICATION=2 普通应用程序窗口，token必须设置为Activity的token来指定窗口属于谁 TYPE_APPLICATION_STARTING=3 应用程序启动时先显示此窗口，当真正的窗口配置完成后，关闭此窗口 LAST_APPLICATION_WINDOW=99 最后一个应用窗口 1.3.2、子窗口子窗口不能单独存在，它需要附属在特定的父Window之中，例如开篇第一张图，绿色框框即为popupWindow，它就是子窗口，类型一般为TYPE_APPLICATION_PANEL。之所以称为子窗口，即它的父窗口显示时，子窗口才显示。父窗口不显示，它也不显示。追随父窗口。 type层级 类型 FIRST_SUB_WINDOW=1000 第一个子窗口 TYPE_APPLICATION_PANEL=1000 应用窗口的子窗口,popupWindow的默认类型 TYPE_APPLICATION_MEDIA=1001 媒体窗口 TYPE_APPLICATION_SUB_PANEL=1002 TYPE_APPLICATION_PANE的子窗口 TYPE_APPLICATION_ATTACHED_DIALOG=1003 对话框，类似于面板窗口(OptionMenu,ContextMenu) TYPE_APPLICATION_MEDIA_OVERLAY=1004 媒体信息，显示在媒体层和程序窗口之间，需要实现半透明效果 LAST_SUB_WINDOW=1999 最后一个子窗口 1.3.3、系统窗口系统窗口跟应用窗口不同，不需要对应 Activity。跟子窗口不同，不需要有父窗口。一般来讲，系统窗口应该由系统来创建的，例如发生异常，ANR时的提示框，又如系统状态栏，屏保等。但是，Framework 还是定义了一些，可以被应用所创建的系统窗口，如 TYPE_ TOAST，TYPE INPUT METHOD，TYPE _WALLPAPTER 等等。 type层级 类型 FIRST_SYSTEM_WINDOW=2000 第一个系统窗口 TYPE_STATUS_BAR=2000 状态栏，只能有一个状态栏，位于屏幕顶端 TYPE_SEARCH_BAR =2001 搜索栏 TYPE_PHONE=2002 电话窗口，它用于电话交互 TYPE_SYSTEM_ALERT=2003 系统警告，出现在应用程序窗口之上 TYPE_KEYGUARD=2004 锁屏窗口 TYPE_TOAST=2005 信息窗口，用于显示Toast TYPE_SYSTEM_OVERLAY=2006 系统顶层窗口，显示在其他内容之上，此窗口不能获得输入焦点，否则影响锁屏 TYPE_PRIORITY_PHONE=2007 当锁屏时显示的来电显示窗口 TYPE_SYSTEM_DIALOG=2008 系统对话框 TYPE_KEYGUARD_DIALOG=2009 锁屏时显示的对话框 TYPE_SYSTEM_ERROR=2010 系统内部错误提示 TYPE_INPUT_METHOD=2011 输入法窗口，显示于普通应用/子窗口之上 TYPE_INPUT_METHOD_DIALOG=2012 输入法中备选框对应的窗口 TYPE_WALLPAPER=2013 墙纸窗口 TYPE_STATUS_BAR_PANEL=2014 滑动状态条后出现的窗口 TYPE_SECURE_SYSTEM_OVERLAY=2015 安全系统覆盖窗口 …… …… LAST_SYSTEM_WINDOW=2999 最后一个系统窗口 那么，这个type层级到底有什么作用呢？Window是分层的，每个Window都有对应的z-ordered，（z轴，从1层层叠加到2999，你可以将屏幕想成三维坐标模式）层级大的会覆盖在层级小的Window上面。 在三类Window中，应用Window的层级范围是1~99。子Window的层级范围是1000~1999，系统Window的层级范围是2000~2999，这些层级范围对应着WindowManager.LayoutParams的type参数。如果想要Window位于所有Window的最顶层，那么采用较大的层级即可。另外有些系统层级的使用是需要声明权限的。 （二）、Window Size（大小）和 Window Position（位置） 计算过程之前在【Android 7.1.2 (Android N) Android Graphics 系统分析 [i.wonder~]】分析过，当Vsync事件到来时，就会通过Choreographer的postCallback()，接着执行mTraversalRunnable对象的run()方法。mTraversalRunnable对象的类型为TraversalRunnable，该类实现了Runnable接口，在其run()函数中调用了doTraversal()函数来完成窗口布局。为了分析的连贯性，这里重新贴一下源码：1234567891011121314151617[-&gt;ViewRootImpl.java]final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable();void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); ...... performTraversals(); ...... &#125;&#125; performTraversals()函数相当复杂，其主要实现以下几个重要步骤： 1.执行窗口测量； 2.执行窗口注册； 3.执行窗口布局； 4.执行窗口绘图； 12345678910111213141516171819202122232425262728293031[-&gt;ViewRootImpl.java] private void performTraversals() &#123; ...... /****************执行窗口测量******************/ if (layoutRequested) &#123; windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight); &#125; ...... /****************向WMS服务添加窗口******************/ if (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != null || mForceNextWindowRelayout) &#123; ...... try &#123; ...... relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); ...... &#125; ...... &#125; /****************执行窗口布局******************/ if (didLayout) &#123; performLayout(lp, mWidth, mHeight); ...... &#125; /****************执行窗口绘制******************/ if (!cancelDraw &amp;&amp; !newSurface) &#123; ...... performDraw(); &#125; ......&#125; 2.1、 Android 屏幕区域介绍首先来看relayoutWindow()。relayoutWindow() 是Window Manager Service 重要工作之一，它的流程如下图所示： 每个View将期望窗口尺寸交给WMS（WindowManager Service).WMS 将所有的窗口大小以及当前的Overscan区域传给WPM （WindowManager Policy).WPM根据用户配置确定每个Window在最终Display输出上的位置以及需要分配的Surface大小。返回这些信息给每个View，他们将在给会的区域空间里绘图。Android里定义了很多区域,如下图所示 Overscan: Overscan 是电视特有的概念，上图中黄色部分就是Overscan区域，指的是电视机屏幕四周某些不可见的区域（因为电视特性，这部分区域的buffer内容显示时被丢弃），也意味着如果窗口的某些内容画在这个区域里，它在某些电视上就会看不到。为了避免这种情况发生，通常要求UI不要画在屏幕的边角上，而是预留一定的空间。因为Overscan的区域大小随着电视不 同而不同，它一般由终端用户通过UI指定，（比如说GoogleTV里就有确定Overscan大小的应用）。 OverscanScreen, Screen: OverscanScreen 是包含Overscan区域的屏幕大小,而Screen则为去除Overscan区域后的屏幕区域, OverscanScreen &gt; Screen. Restricted and Unrestricted: 某些区域是被系统保留的，比如说手机屏幕上方的状态栏(如图纸绿色区域）和下方的导航栏，根据是否包括这些预留的区域，Android把区域分为Unrestricted Area 和 Resctrited Aread, 前者包括这部分预留区域，后者则不包含, Unrestricted area &gt; Rectricted area。 mFrame, mDisplayFrame, mContainingFrame Frame指的是一片内存区域, 对应于屏幕上的一块矩形区域. mFrame的大小就是Surface的大小, 如上上图中的蓝色区域. mDisplayFrame 和 mContainingFrame 一般和mFrame 大小一致. mXXX 是Window(ViewRootImpl, Windowstate) 里面定义的成员变量. mContentFrame, mVisibleFrame 一个Surface的所有内容不一定在屏幕上都得到显示, 与Overscan重叠的部分会被截掉, 系统的其他窗口也会遮挡掉部分区域 (比如短信窗口，ContentFrame是800x600(没有Status Bar), 但当输入法窗口弹出是，变成了800x352), 剩下的区域称为Visible Frame, UI内容只有画在这个区域里才能确保可见. 所以也称为Content Frame. mXXX也是Window(ViewRootImpl, WindowState) 里面定义的成员变量. Insets insets的定义如上图所示, 用了表示某个Frame的边缘大小. 2.2、 Window 大小位置计算过程 在Android系统中，Activity窗口的大小是由WindowManagerService服务来计算的。WindowManagerService服务会根据屏幕及其装饰区的大小来决定Activity窗口的大小。一个Activity窗口只有知道自己的大小之后，才能对它里面的UI元素进行测量、布局以及绘制。 一般来说，Activity窗口的大小等于整个屏幕的大小，但是它并不占据着整块屏幕。为了理解这一点，我们首先分析一下Activity窗口的区域是如何划分的。 我们知道，Activity窗口的上方一般会有一个状态栏，用来显示3G信号、电量使用等图标，如图从Activity窗口剔除掉状态栏所占用的区域之后，所得到的区域就称为内容区域（Content Region）。顾名思义，内容区域就是用来显示Activity窗口的内容的。我们再抽象一下，假设Activity窗口的四周都有一块类似状态栏的区域，那么将这些区域剔除之后，得到中间的那一块区域就称为内容区域，而被剔除出来的区域所组成的区域就称为内容边衬区域（Content Insets）。Activity窗口的内容边衬区域可以用一个四元组（content-left, content-top, content-right, content-bottom）来描述，其中，content-left、content-right、content-top、content-bottom分别用来描述内容区域与窗口区域的左右上下边界距离。我们还知道，Activity窗口有时候需要显示输入法窗口，如图。这时候Activity窗口的内容区域的大小有可能没有发生变化，这取决于它的Soft Input Mode。我们假设Activity窗口的内容区域没有发生变化，但是它在底部的一些区域被输入法窗口遮挡了，即它在底部的一些内容是不可见的。从Activity窗口剔除掉状态栏和输入法窗口所占用的区域之后，所得到的区域就称为可见区域（Visible Region）。同样，我们再抽象一下，假设Activity窗口的四周都有一块类似状态栏和输入法窗口的区域，那么将这些区域剔除之后，得到中间的那一块区域就称为可见区域，而被剔除出来的区域所组成的区域就称为可见边衬区域（Visible Insets）。Activity窗口的可见边衬区域可以用一个四元组（visible-left, visible-top, visible-right, visible-bottom）来描述，其中，visible-left、visible-right、visible-top、visible-bottom分别用来描述可见区域与窗口区域的左右上下边界距离。 在大多数情况下，Activity窗口的内容区域和可见区域的大小是一致的，而状态栏和输入法窗口所占用的区域又称为屏幕装饰区。理解了这些概念之后，我们就可以推断，WindowManagerService服务实际上就是需要根据屏幕以及可能出现的状态栏和输入法窗口的大小来计算出Activity窗口的整体大小及其内容区域边衬和可见区域边衬的大小。有了这三个数据之后，Activity窗口就可以对它里面的UI元素进行测量、布局以及绘制等操作了。总体流程图：这个过程可以分为13个步骤，接下来我们就详细分析每一个步骤。 2.2.1、ViewRootImpl.performTraversals()123456789101112131415161718192021222324252627282930313233343536373839[-&gt;ViewRootImpl.java]private void performTraversals() &#123; // cache mView since it is used so much below... final View host = mView; ...... WindowManager.LayoutParams lp = mWindowAttributes; int desiredWindowWidth; int desiredWindowHeight; ...... Rect frame = mWinFrame; if (mFirst) &#123; mFullRedrawNeeded = true; mLayoutRequested = true; //第一次被请求执行测量、布局和绘制操作，desiredWindowWidth和desiredWindowHeight等于Display Size，否则mWinFrame保存的宽度和高度值。 if (shouldUseDisplaySize(lp)) &#123; Point size = new Point(); mDisplay.getRealSize(size); desiredWindowWidth = size.x; desiredWindowHeight = size.y; &#125; else &#123; Configuration config = mContext.getResources().getConfiguration(); desiredWindowWidth = dipToPx(config.screenWidthDp); desiredWindowHeight = dipToPx(config.screenHeightDp); &#125; ...... host.dispatchAttachedToWindow(mAttachInfo, 0); mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true); dispatchApplyInsets(host); &#125; else &#123; //不是第一次请求，当desiredWindowWidth != mWidth || desiredWindowHeight != mHeight，说明Activity窗口的大小发生了变化，这时候windowSizeMayChange = true，以便接下来对Activity窗口大小变化进行处理 desiredWindowWidth = frame.width(); desiredWindowHeight = frame.height(); if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123; mFullRedrawNeeded = true; mLayoutRequested = true; windowSizeMayChange = true; &#125; &#125; 这段代码用来获得Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight。 继续阅读代码： 12345678910111213141516171819202122232425262728293031323334353637[-&gt;ViewRootImpl.java::performTraversals()]boolean layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);if (layoutRequested) &#123; final Resources res = mView.getContext().getResources(); if (mFirst) &#123; ...... &#125; else &#123; //AttachInfo对象用来描述Activity窗口的属性,mContentInsets和mVisibleInsets分别用来描述Activity窗口的当前内容边衬大小和可见边衬大小。 //判断Activity窗口的OverscanInsets、ContentInsets、StableInsets、VisibleInsets大小是否发生了变化 if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) &#123; insetsChanged = true; &#125; ...... //WRAP_CONTENT表明Activity窗口的大小要等于内容区域的大小，同时等于Display size if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; windowSizeMayChange = true; if (shouldUseDisplaySize(lp)) &#123; Point size = new Point(); mDisplay.getRealSize(size); desiredWindowWidth = size.x; desiredWindowHeight = size.y; &#125; else &#123; Configuration config = res.getConfiguration(); desiredWindowWidth = dipToPx(config.screenWidthDp); desiredWindowHeight = dipToPx(config.screenHeightDp); &#125; &#125; &#125; // Ask host how big it wants to be //知道了顶层Activity窗口大小从而计算Activity内各个子View的大小 windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight);&#125; 这段代码用来在Activity窗口主动请求WindowManagerService服务计算大小之前，对它的顶层视图进行一次测量操作。 继续阅读代码： 12345678910111213141516171819202122232425262728[-&gt;ViewRootImpl.java::performTraversals()] if (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != null || mForceNextWindowRelayout) &#123; ...... try &#123; ...... //relayoutWindow来请求WMS计算Activity窗口的大小以及xxxInsets大小，并保存在PendingxxxInsets中 relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); ...... if (contentInsetsChanged) &#123; mAttachInfo.mContentInsets.set(mPendingContentInsets); &#125; ...... if (visibleInsetsChanged) &#123; mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets); &#125; ...... &#125; catch (RemoteException e) &#123; &#125; ...... //将计算得到的Activity窗口的左上角坐标保存在变量attachInfo所指向的一个AttachInfo对象的成员变量mWindowLeft和mWindowTop mAttachInfo.mWindowLeft = frame.left; mAttachInfo.mWindowTop = frame.top; //将计算得到的Activity窗口的宽度和高度保存在ViewRootImpl类的成员变量mWidth和mHeight中 if (mWidth != frame.width() || mHeight != frame.height()) &#123; mWidth = frame.width(); mHeight = frame.height(); &#125; 这段代码主要调用relayoutWindow()来请求WMS计算Activity窗口的大小以及边忖xxxInsets大小。计算完毕之后，分别保存在mPendingXXXInsets中。 继续阅读代码： 12345678910111213141516171819202122232425262728293031323334353637383940[-&gt;ViewRootImpl.java::performTraversals()] if (!mStopped || mReportNextDraw) &#123; boolean focusChangedDueToTouchMode = ensureTouchModeLocally( (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0); if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) &#123; int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ...... int width = host.getMeasuredWidth(); int height = host.getMeasuredHeight(); boolean measureAgain = false; if (lp.horizontalWeight &gt; 0.0f) &#123; width += (int) ((mWidth - width) * lp.horizontalWeight); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY); measureAgain = true; &#125; if (lp.verticalWeight &gt; 0.0f) &#123; height += (int) ((mHeight - height) * lp.verticalWeight); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY); measureAgain = true; &#125; if (measureAgain) &#123; performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; layoutRequested = true; &#125; &#125; &#125; else &#123; &#125; 这段代码用来检查是否需要重新测量Activity窗口的大小。 经过前面漫长的操作后，Activity窗口的大小测量工作终于尘埃落定，这时候就可以对Activity窗口的内容进行布局 performLayout(lp, mWidth, mHeight)和进行绘画了，performDraw()，由于主要关注Activity窗口大小计算过程，在此不做继续分析。 2.2.2、ViewRootImpl.relayoutWindow()通过调用这个Session对象的成员函数relayout()来请求WindowManagerService服务计算Activity窗口的大小。 123456789101112131415[-&gt;ViewRootImpl.java]private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending) throws RemoteException &#123; ..... int relayoutResult = mWindowSession.relayout( mWindow, mSeq, params, (int) (mView.getMeasuredWidth() * appScale + 0.5f), (int) (mView.getMeasuredHeight() * appScale + 0.5f), viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0, mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets, mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration, mSurface); ...... return relayoutResult;&#125; 参数说明：1、mWindow 用来标志要计算的是哪一个Activity窗口的大小p2、Activity窗口的顶层视图经过测量后得到的宽度和高度3、Activity窗口的可见状态，即viewVisibility4、Activity窗口是否有额外的内容区域边衬和可见区域边衬等待告诉给WindowManagerService服务，即参数insetsPending5、mWinFrame，这是一个输出参数，用来保存WindowManagerService服务计算后得到的Activity窗口的大小6、mPendingOverscanInsets用来保存Overscan边衬，mPendingContentInsets用来保存内容区域边衬，mPendingVisibleInsets用来保存可见区域边衬，mPendingStableInsets用来保存可能被系统UI元素部分或完全遮蔽的全屏窗口区域7、mPendingConfiguration，这是一个输出参数，用来保存WindowManagerService服务返回来的Activity窗口的配置信息8、mSurface，这是一个输出参数，用来保存WindowManagerService服务返回来的Activity窗口的绘图表面 2.2.3、Session.relayout()123456789101112[-&gt;Session.java]public int relayout(IWindow window, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewFlags, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame, Configuration outConfig, Surface outSurface) &#123; int res = mService.relayoutWindow(this, window, seq, attrs, requestedWidth, requestedHeight, viewFlags, flags, outFrame, outOverscanInsets, outContentInsets, outVisibleInsets, outStableInsets, outsets, outBackdropFrame, outConfig, outSurface); return res;&#125; 只是调用了WindowManagerService类的成员函数relayoutWindow来进一步计算参数window所描述的一个Activity窗品的大小 2.2.4、WindowManagerService.relayoutWindow()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[-&gt;WindowManagerService.java]public int relayoutWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame, Configuration outConfig, Surface outSurface) &#123; int result = 0; ...... synchronized(mWindowMap) &#123; WindowState win = windowForClientLocked(session, client, false); WindowStateAnimator winAnimator = win.mWinAnimator; if (viewVisibility != View.GONE) &#123; win.setRequestedSize(requestedWidth, requestedHeight); &#125; ..... if (attrs != null) &#123; mPolicy.adjustWindowParamsLw(attrs); ...... &#125; win.setWindowScale(win.mRequestedWidth, win.mRequestedHeight); ...... if (viewVisibility == View.VISIBLE &amp;&amp; (win.mAppToken == null || !win.mAppToken.clientHidden)) &#123; result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges, oldVisibility); try &#123; result = createSurfaceControl(outSurface, result, win, winAnimator); &#125; catch (Exception e) &#123; ...... &#125; ...... win.adjustStartingWindowFlags(); &#125; else &#123; ...... &#125; ...... mWindowPlacerLocked.performSurfacePlacement(); ...... outFrame.set(win.mCompatFrame); outOverscanInsets.set(win.mOverscanInsets); outContentInsets.set(win.mContentInsets); outVisibleInsets.set(win.mVisibleInsets); outStableInsets.set(win.mStableInsets); outOutsets.set(win.mOutsets); outBackdropFrame.set(win.getBackdropFrame(win.mFrame)); ...... return result;&#125; 只关注relayoutWindow中与窗口大小计算有关的逻辑，计算过程如下所示：1、参数requestedWidth和requestedHeight描述的是应用程序进程请求设置Activity窗口中的宽度和高度，它们会被记录在WindowState对象win的成员变量mRequestedWidth和mRequestedHeight中2、WindowState对象win的成员变量mAttrs，它指向的是一个WindowManager.LayoutParams对象，用来描述Activity窗口的布局参数3、调用WindowSurfacePlacer.performSurfacePlacement()来计算Activity窗口的大小。计算完成之后，参数client所描述的Activity窗口的大小、内容区域边衬大小和可见区域边边衬大小就会分别保存在WindowState对象win的成员变量mCompatFrame、mOverscanInsets、mContentInsets、mVisibleInsets、mStableInsets、mOutsets中4、 将WindowState对象win的成员变量mCompatFrame、mOverscanInsets、mContentInsets、mVisibleInsets、mStableInsets、mOutsets拷贝赋值对应变量中，以便可以返回给应用程序进程 经过上述4个操作后，Activity窗口的大小计算过程就完成了，接下来我们继续分析WindowSurfacePlacer.performSurfacePlacement()的实现，以便可以详细了解Activity窗口的大小计算过程 2.2.5、WindowSurfacePlacer.performSurfacePlacement()1234567891011121314[-&gt;WindowSurfacePlacer.java]final void performSurfacePlacement() &#123; if (mDeferDepth &gt; 0) &#123; return; &#125; int loopCount = 6; do &#123; mTraversalScheduled = false; performSurfacePlacementLoop(); mService.mH.removeMessages(DO_TRAVERSAL); loopCount--; &#125; while (mTraversalScheduled &amp;&amp; loopCount &gt; 0); mWallpaperActionPending = false;&#125; 2.2.6.WindowSurfacePlacer.performSurfacePlacementLoop()12345678910111213141516171819202122232425262728293031323334353637[-&gt;WindowSurfacePlacer.java]private void performSurfacePlacementLoop() &#123; mInLayout = true; boolean recoveringMemory = false; if (!mService.mForceRemoves.isEmpty()) &#123; recoveringMemory = true; while (!mService.mForceRemoves.isEmpty()) &#123; WindowState ws = mService.mForceRemoves.remove(0); mService.removeWindowInnerLocked(ws); &#125; ...... &#125; ...... try &#123; performSurfacePlacementInner(recoveringMemory); mInLayout = false; if (mService.needsLayout()) &#123; if (++mLayoutRepeatCount &lt; 6) &#123; requestTraversal(); &#125; else &#123; Slog.e(TAG, \"Performed 6 layouts in a row. Skipping\"); mLayoutRepeatCount = 0; &#125; &#125; else &#123; mLayoutRepeatCount = 0; &#125; if (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123; mService.mH.removeMessages(REPORT_WINDOWS_CHANGE); mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE); &#125; &#125; catch (RuntimeException e) &#123; mInLayout = false; &#125;&#125; 在调用成员函数performSurfacePlacementInner()刷新系统UI的前后1、检查系统中是否存在强制删除的窗口2、检查系统中是否有窗口需要移除 2.2.7、WindowSurfacePlacer.performSurfacePlacementInner()继续分析的performSurfacePlacementInner()实现，以便可以了解Activity窗口的大小计算过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[-&gt;WindowSurfacePlacer.java]private void performSurfacePlacementInner(boolean recoveringMemory) &#123; if (DEBUG_WINDOW_TRACE) Slog.v(TAG, \"performSurfacePlacementInner: entry. Called by \" + Debug.getCallers(3)); ...... final DisplayContent defaultDisplay = mService.getDefaultDisplayContentLocked(); final DisplayInfo defaultInfo = defaultDisplay.getDisplayInfo(); final int defaultDw = defaultInfo.logicalWidth; final int defaultDh = defaultInfo.logicalHeight; SurfaceControl.openTransaction(); try &#123; applySurfaceChangesTransaction(recoveringMemory, numDisplays, defaultDw, defaultDh); &#125; catch (RuntimeException e) &#123; Slog.wtf(TAG, \"Unhandled exception in Window Manager\", e); &#125; finally &#123; SurfaceControl.closeTransaction(); &#125; final WindowList defaultWindows = defaultDisplay.getWindowList(); ...... final int N = mService.mPendingRemove.size(); if (N &gt; 0) &#123; if (mService.mPendingRemoveTmp.length &lt; N) &#123; mService.mPendingRemoveTmp = new WindowState[N+10]; &#125; mService.mPendingRemove.toArray(mService.mPendingRemoveTmp); mService.mPendingRemove.clear(); DisplayContentList displayList = new DisplayContentList(); for (i = 0; i &lt; N; i++) &#123; WindowState w = mService.mPendingRemoveTmp[i]; mService.removeWindowInnerLocked(w); final DisplayContent displayContent = w.getDisplayContent(); if (displayContent != null &amp;&amp; !displayList.contains(displayContent)) &#123; displayList.add(displayContent); &#125; &#125; for (DisplayContent displayContent : displayList) &#123; mService.mLayersController.assignLayersLocked(displayContent.getWindowList()); displayContent.layoutNeeded = true; &#125; &#125; ...... mService.scheduleAnimationLocked(); ......&#125; 可以看到进一步调用applySurfaceChangesTransaction()方法进行进一步计算 2.2.8、WindowSurfacePlacer.applySurfaceChangesTransaction()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869[-&gt;WindowSurfacePlacer.java]private void applySurfaceChangesTransaction(boolean recoveringMemory, int numDisplays, int defaultDw, int defaultDh) &#123; ...... boolean focusDisplayed = false; for (int displayNdx = 0; displayNdx &lt; numDisplays; ++displayNdx) &#123; final DisplayContent displayContent = mService.mDisplayContents.valueAt(displayNdx); boolean updateAllDrawn = false; WindowList windows = displayContent.getWindowList(); DisplayInfo displayInfo = displayContent.getDisplayInfo(); final int displayId = displayContent.getDisplayId(); final int dw = displayInfo.logicalWidth; final int dh = displayInfo.logicalHeight; final int innerDw = displayInfo.appWidth; final int innerDh = displayInfo.appHeight; final boolean isDefaultDisplay = (displayId == Display.DEFAULT_DISPLAY); // Reset for each display. mDisplayHasContent = false; mPreferredRefreshRate = 0; mPreferredModeId = 0; int repeats = 0; do &#123; repeats++; if (repeats &gt; 6) &#123;//最多执行7次的while循环 displayContent.layoutNeeded = false; break; &#125; //通知SurfaceFlinger服务了，也就是让SurfaceFlinger服务更新它里面的各个Layer的属性值，以便可以对这些Layer执行可见性计算、合成等操作，最后渲染到硬件帧缓冲区中去 if ((displayContent.pendingLayoutChanges &amp; FINISH_LAYOUT_REDO_WALLPAPER) != 0 &amp;&amp; mWallpaperControllerLocked.adjustWallpaperWindows()) &#123; mService.mLayersController.assignLayersLocked(windows); displayContent.layoutNeeded = true; &#125; ...... if ((displayContent.pendingLayoutChanges &amp; FINISH_LAYOUT_REDO_LAYOUT) != 0) &#123; displayContent.layoutNeeded = true; &#125; // FIRST LOOP: Perform a layout, if needed. //计算各个窗品的大小 if (repeats &lt; LAYOUT_REPEAT_THRESHOLD) &#123; performLayoutLockedInner(displayContent, repeats == 1, false /* updateInputWindows */); &#125; else &#123; &#125; // FIRST AND ONE HALF LOOP: Make WindowManagerPolicy think // it is animating. displayContent.pendingLayoutChanges = 0; if (isDefaultDisplay) &#123; mService.mPolicy.beginPostLayoutPolicyLw(dw, dh); for (int i = windows.size() - 1; i &gt;= 0; i--) &#123; WindowState w = windows.get(i); if (w.mHasSurface) &#123; mService.mPolicy.applyPostLayoutPolicyLw(w, w.mAttrs, w.mAttachedWindow); &#125; &#125; displayContent.pendingLayoutChanges |= mService.mPolicy.finishPostLayoutPolicyLw(); &#125; &#125; while (displayContent.pendingLayoutChanges != 0); ......&#125; 2.2.9、WindowSurfacePlacer.applySurfaceChangesTransaction()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586[-&gt;WindowSurfacePlacer.java]final void performLayoutLockedInner(final DisplayContent displayContent, boolean initial, boolean updateInputWindows) &#123; displayContent.layoutNeeded = false; WindowList windows = displayContent.getWindowList(); boolean isDefaultDisplay = displayContent.isDefaultDisplay; DisplayInfo displayInfo = displayContent.getDisplayInfo(); final int dw = displayInfo.logicalWidth; final int dh = displayInfo.logicalHeight; ...... final int N = windows.size(); int i; /// mService.mPolicy.beginLayoutLw(isDefaultDisplay, dw, dh, mService.mRotation, mService.mCurConfiguration.uiMode); ...... displayContent.resize(mTmpContentRect); int seq = mService.mLayoutSeq+1; if (seq &lt; 0) seq = 0; mService.mLayoutSeq = seq; boolean behindDream = false; int topAttached = -1; for (i = N-1; i &gt;= 0; i--) &#123; final WindowState win = windows.get(i); ...... final boolean gone = (behindDream &amp;&amp; mService.mPolicy.canBeForceHidden(win, win.mAttrs)) || win.isGoneForLayoutLw(); ...... if (!gone || !win.mHaveFrame || win.mLayoutNeeded || ((win.isConfigChanged() || win.setReportResizeHints()) &amp;&amp; !win.isGoneForLayoutLw() &amp;&amp; ((win.mAttrs.privateFlags &amp; PRIVATE_FLAG_KEYGUARD) != 0 || (win.mHasSurface &amp;&amp; win.mAppToken != null &amp;&amp; win.mAppToken.layoutConfigChanges)))) &#123; if (!win.mLayoutAttached) &#123; ...... win.mLayoutNeeded = false; win.prelayout(); mService.mPolicy.layoutWindowLw(win, null); win.mLayoutSeq = seq; // Window frames may have changed. Update dim layer with the new bounds. final Task task = win.getTask(); if (task != null) &#123; displayContent.mDimLayerController.updateDimLayer(task); &#125; ...... &#125; else &#123; &#125; &#125; &#125; boolean attachedBehindDream = false; ...... for (i = topAttached; i &gt;= 0; i--) &#123; final WindowState win = windows.get(i); if (win.mLayoutAttached) &#123; ...... if ((win.mViewVisibility != View.GONE &amp;&amp; win.mRelayoutCalled) || !win.mHaveFrame || win.mLayoutNeeded) &#123; ...... win.mLayoutNeeded = false; win.prelayout(); mService.mPolicy.layoutWindowLw(win, win.mAttachedWindow); win.mLayoutSeq = seq; &#125; &#125; else if (win.mAttrs.type == TYPE_DREAM) &#123; attachedBehindDream = behindDream; &#125; &#125; // Window frames may have changed. Tell the input dispatcher about it. mService.mInputMonitor.setUpdateInputWindowsNeededLw(); if (updateInputWindows) &#123; mService.mInputMonitor.updateInputWindowsLw(false /*force*/); &#125; mService.mPolicy.finishLayoutLw(); mService.mH.sendEmptyMessage(UPDATE_DOCKED_STACK_DIVIDER);&#125; 1、mPolicy指向的是一个窗口管理策略类，即PhoneWindowManager对象，主要是用来制定窗口的大小计算策略2、准备阶段：调用PhoneWindowManager.beginLayoutLw()来设置屏幕的大小。包括NavigationBar、StatusBar大小计算3、计算阶段：调用PhoneWindowManager.layoutWindowLw()来计算各个窗口的大小、内容区域边衬大小以及可见区域边衬大小。4、结束阶段：调用PhoneWindowManager类的成员函数finishLayoutLw()来执行一些清理工作。 2.2.10、PhoneWindowManager.beginLayoutLw()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172[-&gt;PhoneWindowManager.java]public void beginLayoutLw(boolean isDefaultDisplay, int displayWidth, int displayHeight, int displayRotation, int uiMode) &#123; mDisplayRotation = displayRotation; final int overscanLeft, overscanTop, overscanRight, overscanBottom; if (isDefaultDisplay) &#123; switch (displayRotation) &#123; case Surface.ROTATION_90: overscanLeft = mOverscanTop; overscanTop = mOverscanRight; overscanRight = mOverscanBottom; overscanBottom = mOverscanLeft; break; ...... &#125; &#125; else &#123; overscanLeft = 0; overscanTop = 0; overscanRight = 0; overscanBottom = 0; &#125; mOverscanScreenLeft = mRestrictedOverscanScreenLeft = 0; mOverscanScreenTop = mRestrictedOverscanScreenTop = 0; mOverscanScreenWidth = mRestrictedOverscanScreenWidth = displayWidth; mOverscanScreenHeight = mRestrictedOverscanScreenHeight = displayHeight; mSystemLeft = 0; mSystemTop = 0; mSystemRight = displayWidth; mSystemBottom = displayHeight; mUnrestrictedScreenLeft = overscanLeft; mUnrestrictedScreenTop = overscanTop; mUnrestrictedScreenWidth = displayWidth - overscanLeft - overscanRight; mUnrestrictedScreenHeight = displayHeight - overscanTop - overscanBottom; mRestrictedScreenLeft = mUnrestrictedScreenLeft; mRestrictedScreenTop = mUnrestrictedScreenTop; mRestrictedScreenWidth = mSystemGestures.screenWidth = mUnrestrictedScreenWidth; mRestrictedScreenHeight = mSystemGestures.screenHeight = mUnrestrictedScreenHeight; mDockLeft = mContentLeft = mVoiceContentLeft = mStableLeft = mStableFullscreenLeft = mCurLeft = mUnrestrictedScreenLeft; mDockTop = mContentTop = mVoiceContentTop = mStableTop = mStableFullscreenTop = mCurTop = mUnrestrictedScreenTop; mDockRight = mContentRight = mVoiceContentRight = mStableRight = mStableFullscreenRight = mCurRight = displayWidth - overscanRight; mDockBottom = mContentBottom = mVoiceContentBottom = mStableBottom = mStableFullscreenBottom = mCurBottom = displayHeight - overscanBottom; mDockLayer = 0x10000000; mStatusBarLayer = -1; // start with the current dock rect, which will be (0,0,displayWidth,displayHeight) final Rect pf = mTmpParentFrame; final Rect df = mTmpDisplayFrame; final Rect of = mTmpOverscanFrame; final Rect vf = mTmpVisibleFrame; final Rect dcf = mTmpDecorFrame; pf.left = df.left = of.left = vf.left = mDockLeft; pf.top = df.top = of.top = vf.top = mDockTop; pf.right = df.right = of.right = vf.right = mDockRight; pf.bottom = df.bottom = of.bottom = vf.bottom = mDockBottom; dcf.setEmpty(); // Decor frame N/A for system bars. ....... if (isDefaultDisplay) &#123; navVisible |= !canHideNavigationBar(); boolean updateSysUiVisibility = layoutNavigationBar(displayWidth, displayHeight, displayRotation, uiMode, overscanLeft, overscanRight, overscanBottom, dcf, navVisible, navTranslucent,navAllowedHidden, statusBarExpandedNotKeyguard); updateSysUiVisibility |= layoutStatusBar(pf, df, of, vf, dcf, sysui, isKeyguardShowing); ...... if (updateSysUiVisibility) &#123; updateSystemUiVisibilityLw(); &#125; &#125;&#125; 1、初始化Overscan、UnrestrictedScreen、RestrictedScreen等屏幕区域变量2、计算NavigationBar和StatusBar大小 2.2.11、PhoneWindowManager.layoutWindowLw()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[-&gt;PhoneWindowManager.java]Overridepublic void layoutWindowLw(WindowState win, WindowState attached) &#123; ...... final int fl = PolicyControl.getWindowFlags(win, attrs); final int pfl = attrs.privateFlags; final int sim = attrs.softInputMode; final int sysUiFl = PolicyControl.getSystemUiVisibility(win, null); final Rect pf = mTmpParentFrame; final Rect df = mTmpDisplayFrame; final Rect of = mTmpOverscanFrame; final Rect cf = mTmpContentFrame; final Rect vf = mTmpVisibleFrame; final Rect dcf = mTmpDecorFrame; final Rect sf = mTmpStableFrame; Rect osf = null; dcf.setEmpty(); final boolean hasNavBar = (isDefaultDisplay &amp;&amp; mHasNavigationBar &amp;&amp; mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw()); final int adjust = sim &amp; SOFT_INPUT_MASK_ADJUST; if (isDefaultDisplay) &#123; sf.set(mStableLeft, mStableTop, mStableRight, mStableBottom); &#125; else &#123; sf.set(mOverscanLeft, mOverscanTop, mOverscanRight, mOverscanBottom); &#125; if (!isDefaultDisplay) &#123; if (attached != null) &#123; // If this window is attached to another, our display // frame is the same as the one we are attached to. setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf); &#125; else &#123; // Give the window full screen. pf.left = df.left = of.left = cf.left = mOverscanScreenLeft; pf.top = df.top = of.top = cf.top = mOverscanScreenTop; pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth; pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight; &#125; &#125; ...... win.computeFrameLw(pf, df, of, cf, vf, dcf, sf, osf); ......&#125; 然后调用WindowState.computeFrameLw来计算窗口win的具体大小了。计算的结果便得到了窗口win的大小，以及它的内容区域边衬大小和可见区域边衬大小。 2.2.12、WindowState.computeFrameLw()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115[-&gt;WindowState.java]public void computeFrameLw(Rect pf, Rect df, Rect of, Rect cf, Rect vf, Rect dcf, Rect sf, Rect osf) &#123; ...... final Task task = getTask(); final boolean fullscreenTask = !isInMultiWindowMode(); final boolean windowsAreFloating = task != null &amp;&amp; task.isFloating(); ...... final Rect layoutContainingFrame; final Rect layoutDisplayFrame; // The offset from the layout containing frame to the actual containing frame. final int layoutXDiff; final int layoutYDiff; if (fullscreenTask || layoutInParentFrame()) &#123; // We use the parent frame as the containing frame for fullscreen and child windows mContainingFrame.set(pf); mDisplayFrame.set(df); layoutDisplayFrame = df; layoutContainingFrame = pf; layoutXDiff = 0; layoutYDiff = 0; &#125; else &#123; task.getBounds(mContainingFrame); ...... mDisplayFrame.set(mContainingFrame); layoutXDiff = !mInsetFrame.isEmpty() ? mInsetFrame.left - mContainingFrame.left : 0; layoutYDiff = !mInsetFrame.isEmpty() ? mInsetFrame.top - mContainingFrame.top : 0; layoutContainingFrame = !mInsetFrame.isEmpty() ? mInsetFrame : mContainingFrame; mTmpRect.set(0, 0, mDisplayContent.getDisplayInfo().logicalWidth, mDisplayContent.getDisplayInfo().logicalHeight); subtractInsets(mDisplayFrame, layoutContainingFrame, df, mTmpRect); ...... layoutDisplayFrame = df; layoutDisplayFrame.intersect(layoutContainingFrame); &#125; final int pw = mContainingFrame.width(); final int ph = mContainingFrame.height(); ...... mOverscanFrame.set(of); mContentFrame.set(cf); mVisibleFrame.set(vf); mDecorFrame.set(dcf); mStableFrame.set(sf); final boolean hasOutsets = osf != null; final int fw = mFrame.width(); final int fh = mFrame.height(); ...... if (windowsAreFloating &amp;&amp; !mFrame.isEmpty()) &#123; final int height = Math.min(mFrame.height(), mContentFrame.height()); final int width = Math.min(mContentFrame.width(), mFrame.width()); final DisplayMetrics displayMetrics = getDisplayContent().getDisplayMetrics(); final int minVisibleHeight = Math.min(height, WindowManagerService.dipToPixel( MINIMUM_VISIBLE_HEIGHT_IN_DP, displayMetrics)); final int minVisibleWidth = Math.min(width, WindowManagerService.dipToPixel( MINIMUM_VISIBLE_WIDTH_IN_DP, displayMetrics)); final int top = Math.max(mContentFrame.top, Math.min(mFrame.top, mContentFrame.bottom - minVisibleHeight)); final int left = Math.max(mContentFrame.left + minVisibleWidth - width, Math.min(mFrame.left, mContentFrame.right - minVisibleWidth)); mFrame.set(left, top, left + width, top + height); mContentFrame.set(mFrame); mVisibleFrame.set(mContentFrame); mStableFrame.set(mContentFrame); &#125; else if (mAttrs.type == TYPE_DOCK_DIVIDER) &#123; mDisplayContent.getDockedDividerController().positionDockedStackedDivider(mFrame); mContentFrame.set(mFrame); &#125; else &#123; mContentFrame.set(......); mVisibleFrame.set(......); mStableFrame.set(......); &#125; if (fullscreenTask &amp;&amp; !windowsAreFloating) &#123; // Windows that are not fullscreen can be positioned outside of the display frame, mOverscanInsets.set(......); &#125; if (mAttrs.type == TYPE_DOCK_DIVIDER) &#123; mStableInsets.set(......); mContentInsets.setEmpty(); mVisibleInsets.setEmpty(); &#125; else &#123; getDisplayContent().getLogicalDisplayRect(mTmpRect); boolean overrideRightInset = !fullscreenTask &amp;&amp; mFrame.right &gt; mTmpRect.right; boolean overrideBottomInset = !fullscreenTask &amp;&amp; mFrame.bottom &gt; mTmpRect.bottom; mContentInsets.set(......); mVisibleInsets.set(......); mStableInsets.set(......); &#125; // Offset the actual frame by the amount layout frame is off. mFrame.offset(-layoutXDiff, -layoutYDiff); mCompatFrame.offset(-layoutXDiff, -layoutYDiff); mContentFrame.offset(-layoutXDiff, -layoutYDiff); mVisibleFrame.offset(-layoutXDiff, -layoutYDiff); mStableFrame.offset(-layoutXDiff, -layoutYDiff); mCompatFrame.set(mFrame); if (mEnforceSizeCompat) &#123; mOverscanInsets.scale(mInvGlobalScale); mContentInsets.scale(mInvGlobalScale); mVisibleInsets.scale(mInvGlobalScale); mStableInsets.scale(mInvGlobalScale); mOutsets.scale(mInvGlobalScale); mCompatFrame.scale(mInvGlobalScale); &#125; ......&#125; 整个窗口大小保存在WindowState类的成员变量mFrame中，而窗品的内容区域边衬大小和可见区域边衬大小分别保在WindowState类的成员变量mContentInsets和mVisibleInsets中 2.2.13、PhoneWindowManager.finishLayoutLw()12345[WindowState.java]@Overridepublic void finishLayoutLw() &#123; return;&#125; （三）、Window Z-Order 计算和调整过程口的UI最终是需要通过SurfaceFlinger服务来统一渲染的，而SurfaceFlinger服务在渲染窗口的UI之前，需要计算基于各个窗口的Z轴位置来计算它们的可见区域。因此，WindowManagerService服务计算好每一个窗口的Z轴位置之后，还需要将它们设置到SurfaceFlinger服务中去，以便SurfaceFlinger服务可以正确地渲染每一个窗口的UI。 3.1、需要重新计算窗口Z轴位置的情景在【Android 7.1.2 (Android N) Activity-Window加载显示流程分析】中已经详细介绍Window添加过程，这里直接从WMS.addWindow开始分析。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[-&gt;WindowManagerService.java]public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; ....... synchronized(mWindowMap) &#123; ...... boolean addToken = false; WindowToken token = mTokenMap.get(attrs.token); AppWindowToken atoken = null; boolean addToastWindowRequiresToken = false; ...... // WindowState win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); ...... origId = Binder.clearCallingIdentity(); if (addToken) &#123; mTokenMap.put(attrs.token, token); &#125; win.attach(); mWindowMap.put(client.asBinder(), win); ...... boolean imMayMove = true; if (type == TYPE_INPUT_METHOD) &#123; win.mGivenInsetsPending = true; mInputMethodWindow = win; addInputMethodWindowToListLocked(win); imMayMove = false; &#125; else if (type == TYPE_INPUT_METHOD_DIALOG) &#123; mInputMethodDialogs.add(win); addWindowToListInOrderLocked(win, true); moveInputMethodDialogsLocked(findDesiredInputMethodWindowIndexLocked(true)); imMayMove = false; &#125; else &#123; addWindowToListInOrderLocked(win, true); ...... &#125; ...... //重新计算系统中所有窗口的Z轴位置 mLayersController.assignLayersLocked(displayContent.getWindowList()); ...... &#125; ...... return res;&#125; WMS.relayoutWindow()也会调用WindowLayersController.assignLayersLocked()重新计算、调整系统中所有窗口的Z轴位置，由于原理类似这里不做解释。 3.2、计算系统中所有窗口的Z轴位置接下来我们就通过WindowState类的构造函数来分析一个窗口的BaseLayer值是如何确定12345678910111213141516[WindowState.java]WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token, WindowState attachedWindow, int appOp, int seq, WindowManager.LayoutParams a, int viewVisibility, final DisplayContent displayContent) &#123; ...... if ((mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW)) &#123; ...... //windowTypeToLayerLw的返回值并且不是一个窗口的最终的BaseLayer值，而是要将它的返回值乘以一个常量TYPE_LAYER_MULTIPLIER，再加上另外一个常量TYPE_LAYER_OFFSET之后，才得到最终的BaseLayer值 mBaseLayer = mPolicy.windowTypeToLayerLw( attachedWindow.mAttrs.type) * WindowManagerService.TYPE_LAYER_MULTIPLIER + WindowManagerService.TYPE_LAYER_OFFSET; mSubLayer = mPolicy.subWindowTypeToLayerLw(a.type); ......&#125; 一个窗口除了有一个BaseLayer值之外，还有一个SubLayer值，分别保存在一个对应的WindowState对象的成员变量mBaseLayer和mSubLayer。SubLayer值是用来描述一个窗口是否是另外一个窗口的子窗口的。在继续分析WindowLayersController.assignLayersLocked()之前，我们首先分析PhoneWindowManager.windowTypeToLayerLw()和subWindowTypeToLayerLw()的实现，以便可以了解一个窗口的BaseLayer值和SubLayer值是如何确定的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[-&gt;PhoneWindowManager.java]@Overridepublic int windowTypeToLayerLw(int type) &#123; if (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) &#123; return 2; &#125; switch (type) &#123; ...... case TYPE_SYSTEM_DIALOG: return 7; case TYPE_TOAST: // toasts and the plugged-in battery thing return 8; ...... case TYPE_SYSTEM_ALERT: // like the ANR / app crashed dialogs return 11; ...... case TYPE_STATUS_BAR_SUB_PANEL: return 15; case TYPE_STATUS_BAR: return 16; case TYPE_STATUS_BAR_PANEL: return 17; case TYPE_KEYGUARD_DIALOG: return 18; ...... case TYPE_NAVIGATION_BAR: // the navigation bar, if available, shows atop most things return 21; case TYPE_NAVIGATION_BAR_PANEL: // some panels (e.g. search) need to show on top of the navigation bar return 22; ...... &#125; return 2;&#125;/** &#123;@inheritDoc&#125; */@Overridepublic int subWindowTypeToLayerLw(int type) &#123; switch (type) &#123; case TYPE_APPLICATION_PANEL: case TYPE_APPLICATION_ATTACHED_DIALOG: return APPLICATION_PANEL_SUBLAYER; ...... case TYPE_APPLICATION_ABOVE_SUB_PANEL: return APPLICATION_ABOVE_SUB_PANEL_SUBLAYER; &#125; return 0;&#125; 主要根据不同的Window Type返回不一样的数值。 123[-&gt;WindowManagerService.java]static final int TYPE_LAYER_MULTIPLIER = 10000;static final int TYPE_LAYER_OFFSET = 1000; 我们可以用adb shell dumpsys window -a 命令查看一下Layer的数值，可以看到StatusBar的数值计算：mBaseLayer = 16 WindowManagerService.TYPE_LAYER_MULTIPLIER+ WindowManagerService.TYPE_LAYER_OFFSETStatusBar.mBaseLayer = 16 10000 + 1000 = 161000 。 12345678910Window #4 Window&#123;3c1f1fb u0 StatusBar&#125;: mBaseLayer=161000 mSubLayer=0 mAnimLayer=161000+0=161000 mLastLayer=161000Window #3 Window&#123;fe4aae2 u0 KeyguardScrim&#125;: mBaseLayer=141000 mSubLayer=0 mAnimLayer=141000+0=141000 mLastLayer=141000Window #2 Window&#123;173ee76 u0 DockedStackDivider&#125;: mBaseLayer=21000 mSubLayer=0 mAnimLayer=21010+0=21010 mLastLayer=0Window #1 Window&#123;3a83a4a u0 com.android.launcher&#125;: mBaseLayer=21000 mSubLayer=0 mAnimLayer=21005+0=21005 mLastLayer=21005Window #0 Window&#123;aefb7bc u0 com.android.systemui.ImageWallpaper&#125;: mBaseLayer=21000 mSubLayer=0 mAnimLayer=21000+0=21000 mLastLayer=21000 理解了窗口的BaseLayer值和SubLayer值的计算过程之外，接下来我们就可以分析WindowManagerService类的成员函数assignLayersLocked()的实现了 3.2.1、WindowLayersController.assignLayersLocked()123456789101112131415161718192021222324252627282930313233343536373839404142[-&gt;WindowLayersController.java]final void assignLayersLocked(WindowList windows) &#123; if (DEBUG_LAYERS) Slog.v(TAG_WM, \"Assigning layers based on windows=\" + windows, new RuntimeException(\"here\").fillInStackTrace()); clear(); int curBaseLayer = 0; int curLayer = 0; boolean anyLayerChanged = false; for (int i = 0, windowCount = windows.size(); i &lt; windowCount; i++) &#123; final WindowState w = windows.get(i); boolean layerChanged = false; int oldLayer = w.mLayer; if (w.mBaseLayer == curBaseLayer || w.mIsImWindow || (i &gt; 0 &amp;&amp; w.mIsWallpaper)) &#123; curLayer += WINDOW_LAYER_MULTIPLIER; &#125; else &#123; curBaseLayer = curLayer = w.mBaseLayer; &#125; assignAnimLayer(w, curLayer); // TODO: Preserved old behavior of code here but not sure comparing // oldLayer to mAnimLayer and mLayer makes sense...though the // worst case would be unintentionalp layer reassignment. if (w.mLayer != oldLayer || w.mWinAnimator.mAnimLayer != oldLayer) &#123; layerChanged = true; anyLayerChanged = true; &#125; if (w.mAppToken != null) &#123; mHighestApplicationLayer = Math.max(mHighestApplicationLayer, w.mWinAnimator.mAnimLayer); &#125; collectSpecialWindows(w); if (layerChanged) &#123; w.scheduleAnimationIfDimming(); &#125; &#125; adjustSpecialWindows(); ......&#125; 调用 assignAnimLayer() 进行Layer调整： 12345678910[-&gt;WindowLayersController.java] private void assignAnimLayer(WindowState w, int layer) &#123; w.mLayer = layer; w.mWinAnimator.mAnimLayer = w.mLayer + w.getAnimLayerAdjustment() + getSpecialWindowAnimLayerAdjustment(w); if (w.mAppToken != null &amp;&amp; w.mAppToken.mAppAnimator.thumbnailForceAboveLayer &gt; 0 &amp;&amp; w.mWinAnimator.mAnimLayer &gt; w.mAppToken.mAppAnimator.thumbnailForceAboveLayer) &#123; w.mAppToken.mAppAnimator.thumbnailForceAboveLayer = w.mWinAnimator.mAnimLayer; &#125; &#125; 3.3、设置窗口的Z轴位置到SurfaceFlinger服务中去WindowManagerService服务在刷新系统的UI的时候，就会将系统中已经计算好了的窗口Z轴位置设置到SurfaceFlinger服务中去，以便SurfaceFlinger服务可以对系统中的窗口进行可见性计算以及合成和渲染等操作首先看一下堆栈信息： 123456789101112131415161718192021WindowSurfaceController.showSurface()添加打印LogSlog.i(\"zhoujinjian\", \"zhoujinjian\",new RuntimeException(\"here\").fillInStackTrace());03-01 19:06:45.229: I/zhoujinjian(1424): zhoujinjian03-01 19:06:45.229: I/zhoujinjian(1424): java.lang.RuntimeException: here03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowSurfaceController.showSurface(WindowSurfaceController.java:414)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowSurfaceController.updateVisibility(WindowSurfaceController.java:402)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowSurfaceController.showRobustlyInTransaction(WindowSurfaceController.java:391)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowStateAnimator.showSurfaceRobustlyLocked(WindowStateAnimator.java:1814)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowStateAnimator.prepareSurfaceLocked(WindowStateAnimator.java:1609)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowAnimator.animateLocked(WindowAnimator.java:791)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowAnimator.-wrap0(WindowAnimator.java)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowAnimator$1.doFrame(WindowAnimator.java:166)03-01 19:06:45.229: I/zhoujinjian(1424): at android.view.Choreographer$CallbackRecord.run(Choreographer.java:879)03-01 19:06:45.229: I/zhoujinjian(1424): at android.view.Choreographer.doCallbacks(Choreographer.java:693)03-01 19:06:45.229: I/zhoujinjian(1424): at android.view.Choreographer.doFrame(Choreographer.java:625)03-01 19:06:45.229: I/zhoujinjian(1424): at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:867)03-01 19:06:45.229: I/zhoujinjian(1424): at android.os.Handler.handleCallback(Handler.java:751)03-01 19:06:45.229: I/zhoujinjian(1424): at android.os.Handler.dispatchMessage(Handler.java:95)03-01 19:06:45.229: I/zhoujinjian(1424): at android.os.Looper.loop(Looper.java:154)03-01 19:06:45.229: I/zhoujinjian(1424): at android.os.HandlerThread.run(HandlerThread.java:61)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.ServiceThread.run(ServiceThread.java:46) 为了了解WMS是如何将Z轴位置设置到SurfaceFlinger服务中去，首先看一下WMS构造方法中关键对象WindowAnimator的创建 3.3.1、Vsync刷新UI回调过程开机启动时会初始化WMS。1234567[-&gt;WindowManagerService.java]private WindowManagerService(Context context, InputManagerService inputManager, boolean haveInputMethods, boolean showBootMsgs, boolean onlyCore) &#123; ...... mAnimator = new WindowAnimator(this); ...... &#125; 调用WindowAnimator构造方法 12345678910111213141516[-&gt;WindowAnimator.java]WindowAnimator(final WindowManagerService service) &#123; mService = service; mContext = service.mContext; mPolicy = service.mPolicy; mWindowPlacerLocked = service.mWindowPlacerLocked; mAnimationFrameCallback = new Choreographer.FrameCallback() &#123; public void doFrame(long frameTimeNs) &#123; synchronized (mService.mWindowMap) &#123; mService.mAnimationScheduled = false; animateLocked(frameTimeNs); &#125; &#125; &#125;;&#125; 可以看到创建了Choreographer.FrameCallback()，前面在【Android-7-1-2-Android-N-Activity-Window加载显示流程】分析过，FrameDisplayEventReceiver（在Choreographer构造方法中初始化）对象用于请求并接收Vsync信号，当Vsync信号到来时，系统会自动调用其onVsync()函数，后面会回调到FrameDisplayEventReceiver.run()方法，再回调函数中执行doFrame()实现屏幕刷新，doFrame()会顺序执行CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL 和CALLBACK_COMMIT 对应CallbackQueue队列中注册的回调，从而会执行CallbackRecord.run()，在执行其回调函数时，就需要区别这两种对象类型，如果注册的是Runnable对象，则调用其run()函数，如果注册的是FrameCallback对象，则调用它的doFrame()函数。 123456789101112131415[-&gt;Choreographer.java]private static final class CallbackRecord &#123; public CallbackRecord next; public long dueTime; public Object action; // Runnable or FrameCallback public Object token; public void run(long frameTimeNanos) &#123; if (token == FRAME_CALLBACK_TOKEN) &#123; ((FrameCallback)action).doFrame(frameTimeNanos); &#125; else &#123; ((Runnable)action).run(); &#125; &#125;&#125; 在此种情况下会执行FrameCallback对象的doFrame()函数（原因稍后再分析动画时详细分析），由WindowAnimator构造函数中可知接着就会执行WindowAnimator.animateLocked() 3.3.2、准备刷新UI123456789101112131415161718192021222324252627282930313233[-&gt;WindowAnimator.java] private void animateLocked(long frameTimeNs) &#123; ...... if (SHOW_TRANSACTIONS) Slog.i( TAG, \"&gt;&gt;&gt; OPEN TRANSACTION animateLocked\"); SurfaceControl.openTransaction(); SurfaceControl.setAnimationTransaction(); try &#123; final int numDisplays = mDisplayContentsAnimators.size(); for (int i = 0; i &lt; numDisplays; i++) &#123; final int displayId = mDisplayContentsAnimators.keyAt(i); updateAppWindowsLocked(displayId); DisplayContentsAnimator displayAnimator = mDisplayContentsAnimators.valueAt(i); ...... updateWindowsLocked(displayId); updateWallpaperLocked(displayId); final WindowList windows = mService.getWindowListLocked(displayId); final int N = windows.size(); //通过一个for循环来遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新 for (int j = 0; j &lt; N; j++) &#123; windows.get(j).mWinAnimator.prepareSurfaceLocked(true); &#125; &#125; ...... catch (RuntimeException e) &#123; ...... &#125; finally &#123; SurfaceControl.closeTransaction(); if (SHOW_TRANSACTIONS) Slog.i( TAG, \"&lt;&lt;&lt; CLOSE TRANSACTION animateLocked\"); &#125;&#125; 首先获取windows列表，然后循环调用windows.get(j).mWinAnimator.prepareSurfaceLocked(true)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566[-&gt;WindowStateAnimator.java]void prepareSurfaceLocked(final boolean recoveringMemory) &#123; final WindowState w = mWin; ...... boolean displayed = false; //确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息 computeShownFrameLocked(); setSurfaceBoundariesLocked(recoveringMemory); if (mIsWallpaper &amp;&amp; !mWin.mWallpaperVisible) &#123; ...... &#125; else if (w.mAttachedHidden || !w.isOnScreen()) &#123; ...... &#125; else if (mLastLayer != mAnimLayer || mLastAlpha != mShownAlpha || mLastDsDx != mDsDx || mLastDtDx != mDtDx || mLastDsDy != mDsDy || mLastDtDy != mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || mLastHidden) &#123; displayed = true; mLastAlpha = mShownAlpha; mLastLayer = mAnimLayer; mLastDsDx = mDsDx; mLastDtDx = mDtDx; mLastDsDy = mDsDy; mLastDtDy = mDtDy; w.mLastHScale = w.mHScale; w.mLastVScale = w.mVScale; ...... boolean prepared = mSurfaceController.prepareToShowInTransaction(mShownAlpha, mAnimLayer, mDsDx * w.mHScale * mExtraHScale, mDtDx * w.mVScale * mExtraVScale, mDsDy * w.mHScale * mExtraHScale, mDtDy * w.mVScale * mExtraVScale, recoveringMemory); if (prepared &amp;&amp; mLastHidden &amp;&amp; mDrawState == HAS_DRAWN) &#123; if (showSurfaceRobustlyLocked()) &#123; markPreservedSurfaceForDestroy(); mAnimator.requestRemovalOfReplacedWindows(w); mLastHidden = false; if (mIsWallpaper) &#123; mWallpaperControllerLocked.dispatchWallpaperVisibility(w, true); &#125; ...... mAnimator.setPendingLayoutChanges(w.getDisplayId(), WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM); &#125; else &#123; w.mOrientationChanging = false; &#125; &#125; if (hasSurface()) &#123; w.mToken.hasVisible = true; &#125; &#125; else &#123; displayed = true; &#125; ......&#125; 调用prepareToShowInTransaction()将alph、alayer、setMatrix设置到mSurfaceControl中。1234567891011121314151617boolean prepareToShowInTransaction(float alpha, int layer, float dsdx, float dtdx, float dsdy, float dtdy, boolean recoveringMemory) &#123; if (mSurfaceControl != null) &#123; try &#123; mSurfaceAlpha = alpha; mSurfaceControl.setAlpha(alpha); mSurfaceLayer = layer; mSurfaceControl.setLayer(layer); mSurfaceControl.setMatrix( dsdx, dtdx, dsdy, dtdy); &#125; catch (RuntimeException e) &#123; ....... &#125; &#125; return true; &#125; setSurfaceBoundariesLocked()方法中会调用SurfaceControl.setPosition()等等方法将计算好的数值设置到mSurfaceControl中。说明：一个窗口的显示和隐藏，以及大小、X轴和Y轴位置、Z轴位置、Alpha通道和变换矩阵设置，是通过调用Java层的SurfaceControl类的成员函数show、hide、setSize、setPosition、setLayer、setAlpha和setMatrix来实现的，它们最终都是通过调用JNI方法实现的 1234567891011121314151617181920212223242526272829303132SurfaceControl.java......public void setAlpha(float alpha) &#123; checkNotReleased(); nativeSetAlpha(mNativeObject, alpha);&#125;public void setMatrix(float dsdx, float dtdx, float dsdy, float dtdy) &#123; checkNotReleased(); nativeSetMatrix(mNativeObject, dsdx, dtdx, dsdy, dtdy);&#125;public void setWindowCrop(Rect crop) &#123; checkNotReleased(); if (crop != null) &#123; nativeSetWindowCrop(mNativeObject, crop.left, crop.top, crop.right, crop.bottom); &#125; else &#123; nativeSetWindowCrop(mNativeObject, 0, 0, 0, 0); &#125;&#125;public void setFinalCrop(Rect crop) &#123; checkNotReleased(); if (crop != null) &#123; nativeSetFinalCrop(mNativeObject, crop.left, crop.top, crop.right, crop.bottom); &#125; else &#123; nativeSetFinalCrop(mNativeObject, 0, 0, 0, 0); &#125;&#125;.... 3.3.3、告知SurfaceFlinger显示UI如果WindowState对象w所描述的窗口满足条件：prepared &amp;&amp; mLastHidden &amp;&amp; mDrawState == HAS_DRAWN那么就说明现在是时候要将WindowState对象w所描述的窗口显示出来了，通过调用showSurfaceRobustlyLocked实现 123456789101112131415[-&gt;WindowStateAnimator.java]private boolean showSurfaceRobustlyLocked() &#123; final Task task = mWin.getTask(); if (task != null &amp;&amp; StackId.windowsAreScaleable(task.mStack.mStackId)) &#123; mSurfaceController.forceScaleableInTransaction(true); &#125; boolean shown = mSurfaceController.showRobustlyInTransaction(); ...... if (mWin.mTurnOnScreen) &#123; ...... mWin.mTurnOnScreen = false; mAnimator.mBulkUpdateParams |= SET_TURN_ON_SCREEN; &#125; return true;&#125; 直接调用WindowSurfaceController.showRobustlyInTransaction() –&gt; updateVisibility()–&gt;showSurface()-&gt;SurfaceControl.show() 123456789101112131415161718192021222324252627282930[-&gt;WindowSurfaceController.java] boolean showRobustlyInTransaction() &#123; ...... mHiddenForOtherReasons = false; return updateVisibility(); &#125; private boolean updateVisibility() &#123; if (mHiddenForCrop || mHiddenForOtherReasons) &#123; if (mSurfaceShown) &#123;hideSurface();&#125; return false; &#125; else &#123; if (!mSurfaceShown) &#123;return showSurface(); &#125; else &#123; return true; &#125; &#125; &#125; private boolean showSurface() &#123; try &#123; mSurfaceShown = true; mSurfaceControl.show(); Slog.i(\"zhoujinjian\", \"zhoujinjian\",new RuntimeException(\"here\").fillInStackTrace()); return true; &#125; catch (RuntimeException e) &#123; ...... &#125; //出现异常,回收系统内存资源 mAnimator.reclaimSomeSurfaceMemory(\"show\", true); return false; &#125; 12345[-&gt;SurfaceControl.java]public void show() &#123; checkNotReleased(); nativeSetFlags(mNativeObject, 0, SURFACE_HIDDEN);&#125; 通过JNI调用android_view_SurfaceControl.cpp的nativeSetFlags函数，可以看到flags == 0；12345678[-&gt;android_view_SurfaceControl.cpp]static void nativeSetFlags(JNIEnv* env, jclass clazz, jlong nativeObject, jint flags, jint mask) &#123; SurfaceControl* const ctrl = reinterpret_cast&lt;SurfaceControl *&gt;(nativeObject); status_t err = ctrl-&gt;setFlags(flags, mask); if (err &lt; 0 &amp;&amp; err != NO_INIT) &#123; doThrowIAE(env); &#125;&#125; 调用SurfaceControl.cpp的setFlags()函数123456[-&gt;SurfaceControl.cpp]status_t SurfaceControl::setFlags(uint32_t flags, uint32_t mask) &#123; status_t err = validate(); if (err &lt; 0) return err; return mClient-&gt;setFlags(mHandle, flags, mask);&#125; 进一步通过Binder IPC机制，SurfaceComposerClient.cpp-&gt;Composer::setFlags() 1234567891011121314151617[-&gt;SurfaceComposerClient.cpp]status_t Composer::setFlags(const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;IBinder&gt;&amp; id, uint32_t flags, uint32_t mask) &#123; Mutex::Autolock _l(mLock); layer_state_t* s = getLayerStateLocked(client, id); ...... if ((mask &amp; layer_state_t::eLayerOpaque) || (mask &amp; layer_state_t::eLayerHidden) || (mask &amp; layer_state_t::eLayerSecure)) &#123; s-&gt;what |= layer_state_t::eFlagsChanged; &#125; s-&gt;flags &amp;= ~mask; s-&gt;flags |= (flags &amp; mask); s-&gt;mask |= mask; return NO_ERROR;&#125; 具体数值就不详细计算了，前面分析【Android 7.1.2 (Android N) Android Graphics 系统分析 [i.wonder~]】可知，SurfaceFlinger接收Vsync信号与App有一个offset间隔时间，当SurfaceFlinger接收Vsync信号时，就可以根据flags是否显示 和 上面设置的一系列数值进行渲染合成，最终显示到屏幕上。 （四）、Activity启动窗口(Starting Window)添加过程4.1、Activity组件的启动窗口(Starting Window)的添加过程时序图： 4.1.1、 ActivityStack.startActivityLocked()123456789101112131415161718192021222324252627282930313233343536373839[-&gt;ActivityStack.java] final void startActivityLocked(ActivityRecord r, boolean newTask, boolean keepCurTransition, ActivityOptions options) &#123; ...... if (!isHomeStack() || numActivities() &gt; 0) &#123; ...... if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) &#123; mWindowManager.prepareAppTransition(TRANSIT_NONE, keepCurTransition); mNoAnimActivities.add(r); &#125; else &#123; mWindowManager.prepareAppTransition(newTask ? r.mLaunchTaskBehind ? TRANSIT_TASK_OPEN_BEHIND : TRANSIT_TASK_OPEN : TRANSIT_ACTIVITY_OPEN, keepCurTransition); mNoAnimActivities.remove(r); &#125; addConfigOverride(r, task); boolean doShow = true; ...... if (r.mLaunchTaskBehind) &#123; ....... &#125; else if (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123; ActivityRecord prev = r.task.topRunningActivityWithStartingWindowLocked(); if (prev != null) &#123; // We don't want to reuse the previous starting preview if: // (1) The current activity is in a different task. if (prev.task != r.task) &#123; prev = null; &#125; // (2) The current activity is already displayed. else if (prev.nowVisible) &#123; prev = null; &#125; &#125; r.showStartingWindow(prev, showStartingIcon); &#125; &#125; ...... &#125; 可以看到直接调用ActivityRecord.showStartingWindow()进一步添加启动窗口 4.1.2、 ActivityRecord.showStartingWindow()1234567891011[-&gt;ActivityRecord.java]void showStartingWindow(ActivityRecord prev, boolean createIfNeeded) &#123; final CompatibilityInfo compatInfo = service.compatibilityInfoForPackageLocked(info.applicationInfo); final boolean shown = service.mWindowManager.setAppStartingWindow( appToken, packageName, theme, compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags, prev != null ? prev.appToken : null, createIfNeeded); if (shown) &#123; mStartingWindowState = STARTING_WINDOW_SHOWN; &#125;&#125; 4.1.2、ActivityRecord.setAppStartingWindow()1234567891011121314151617181920[-&gt;ActivityRecord.java]public boolean setAppStartingWindow(IBinder token, String pkg, int theme, CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, int labelRes, int icon, int logo, int windowFlags, IBinder transferFrom, boolean createIfNeeded) &#123; ...... synchronized(mWindowMap) &#123; AppWindowToken wtoken = findAppWindowToken(token); ...... if (transferStartingWindow(transferFrom, wtoken)) &#123; return true; &#125; ...... wtoken.startingData = new StartingData(pkg, theme, compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags); Message m = mH.obtainMessage(H.ADD_STARTING, wtoken); mH.sendMessageAtFrontOfQueue(m); &#125; return true;&#125; 如果参数transferFrom所描述的Activity组件没有启动窗口或者启动窗口数据转移给参数token所描述的Activity组件，那么接下来就可能需要为参数token所描述的Activity组件创建一个新的启动窗口 4.1.3、 H.handleMessage()12345678910111213141516171819202122232425262728293031323334353637[-&gt;WindowManagerService.java::H]case ADD_STARTING: &#123; final AppWindowToken wtoken = (AppWindowToken)msg.obj; final StartingData sd = wtoken.startingData; ...... View view = null; try &#123; final Configuration overrideConfig = wtoken != null &amp;&amp; wtoken.mTask != null ? wtoken.mTask.mOverrideConfig : null; view = mPolicy.addStartingWindow(wtoken.token, sd.pkg, sd.theme, sd.compatInfo, sd.nonLocalizedLabel, sd.labelRes, sd.icon, sd.logo, sd.windowFlags, overrideConfig); &#125; catch (Exception e) &#123; &#125; if (view != null) &#123; boolean abort = false; synchronized(mWindowMap) &#123; if (wtoken.removed || wtoken.startingData == null) &#123; wtoken.startingWindow = null; wtoken.startingData = null; abort = true; &#125; &#125; else &#123; wtoken.startingView = view; &#125; &#125; if (abort) &#123; try &#123; mPolicy.removeStartingWindow(wtoken.token, view); &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125; break; PhoneWindowManager实现WindowManagerPolicy，所以会调用PhoneWindowManager中的方法继续分析PhoneWindowManager.addStartingWindow() 4.1.4、PhoneWindowManager.addStartingWindow()12345678910111213141516171819202122232425262728293031323334353637383940414243[-&gt;PhoneWindowManager.java]public View addStartingWindow(IBinder appToken, String packageName, int theme, CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, int labelRes, int icon, int logo, int windowFlags, Configuration overrideConfig) &#123; ...... WindowManager wm = null; View view = null; try &#123; Context context = mContext; ...... final PhoneWindow win = new PhoneWindow(context); win.setIsStartingWindow(true); ...... win.setType( WindowManager.LayoutParams.TYPE_APPLICATION_STARTING); ...... win.setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT); final WindowManager.LayoutParams params = win.getAttributes(); params.token = appToken; params.packageName = packageName; params.windowAnimations = win.getWindowStyle().getResourceId( com.android.internal.R.styleable.Window_windowAnimationStyle, 0); ...... params.setTitle(\"Starting \" + packageName); wm = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); view = win.getDecorView(); ...... wm.addView(view, params); return view.getParent() != null ? view : null; &#125; catch (WindowManager.BadTokenException e) &#123; ...... &#125; catch (RuntimeException e) &#123; ...... &#125; finally &#123; if (view != null &amp;&amp; view.getParent() == null) &#123; wm.removeViewImmediate(view); &#125; &#125; return null;&#125; 创建PhoneWindow对象，接下来继续设置所创建的窗口win的以下属性：1、窗口类型：设置为WindowManager.LayoutParams.TYPE_APPLICATION_STARTING，即设置为启动窗口类型； 2、窗口标题：由参数labelRes、nonLocalizedLabel，以及窗口的运行上下文context来确定； 3、窗口标志：分别将indowManager.LayoutParams.FLAG_NOT_TOUCHABLE、WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE和WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM位设置为1，即不可接受触摸事件和不可获得焦点，但是可以接受输入法窗口； 4、窗口大小：设置为WindowManager.LayoutParams.MATCH_PARENT，即与父窗口一样大，但是由于这是一个顶层窗口，因此实际上是指与屏幕一样大； 5、布局参数：包括窗口所对应的窗口令牌（token）和包名（packageName），以及窗口所使用的动画类型（windowAnimations）和标题（title）。 wm.addView(view, params)，一个新创建的Activity组件的启动窗口就增加到WindowManagerService服务中去了，这样，WindowManagerService服务就可以下次刷新系统UI时，将该启动窗口显示出来 （五）、WMS切换Activity窗口（App Transition）过程 WindowManagerService服务在执行Activity窗口的切换操作的时候，会给参与切换操作的Activity组件的设置一个动画，以便可以向用户展现一个Activity组件切换效果，从而提高用户体验。首先看一下App Transition动态图： 时序图： 我们直接分析App Transition过程的prepareAppTransition、executeAppTransition关于Activity启动过程请参考：【Android-7-1-2-Android-N-Activity启动流程分析】 5.1、prepareAppTransition()过程5.1.1、ActivityStack.startActivityLocked()12345678[-&gt;ActivityStack.java]......mWindowManager.prepareAppTransition(newTask ? r.mLaunchTaskBehind ? TRANSIT_TASK_OPEN_BEHIND : TRANSIT_TASK_OPEN : TRANSIT_ACTIVITY_OPEN, keepCurTransition);...... 5.1.2、WindowManagerService.prepareAppTransition()123456789101112[-&gt;WindowManagerService.java]@Overridepublic void prepareAppTransition(int transit, boolean alwaysKeepCurrent) &#123; ...... synchronized(mWindowMap) &#123; boolean prepared = mAppTransition.prepareAppTransitionLocked( transit, alwaysKeepCurrent); if (prepared &amp;&amp; okToDisplay()) &#123; mSkipAppTransitionAnimation = false; &#125; &#125;&#125; 发现是直接调用AppTransition.prepareAppTransitionLocked()实现的。 5.1.3、AppTransition.prepareAppTransitionLocked()进一步调用setAppTransition() 12345private void setAppTransition(int transit) &#123; mNextAppTransition = transit; setLastAppTransition(TRANSIT_UNSET, null, null);&#125; 发现只是将transit（即AppTransition动画类型）赋值给变量mNextAppTransition 5.2、AppTransition animation设置过程继续分析ActivityStackSupervisor.realStartActivityLocked() 123456789101112[-&gt;ActivityStackSupervisor.java]final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ...... if (andResume) &#123; r.startFreezingScreenLocked(app, 0); mWindowManager.setAppVisibility(r.appToken, true); // schedule launch ticks to collect information about slow apps. r.startLaunchTickingLocked(); &#125; 首先会通知WindowManagerService服务将参数r.appToken所描述的Activity组件的可见性设置为true 12345678910111213141516171819[-&gt;WindowManagerService.java]@Overridepublic void setAppVisibility(IBinder token, boolean visible) &#123; ...... AppWindowToken wtoken; synchronized(mWindowMap) &#123; wtoken = findAppWindowToken(token); ...... mOpeningApps.remove(wtoken); mClosingApps.remove(wtoken); ...... final long origId = Binder.clearCallingIdentity(); wtoken.inPendingTransaction = false; setTokenVisibilityLocked(wtoken, null, visible, AppTransition.TRANSIT_UNSET, true, wtoken.voiceInteraction); wtoken.updateReportedVisibilityLocked(); &#125; &#125; 调用WindowManagerService.setTokenVisibilityLocked()1234567891011121314151617[-&gt;WindowManagerService.java] boolean setTokenVisibilityLocked(AppWindowToken wtoken, WindowManager.LayoutParams lp, boolean visible, int transit, boolean performLayout, boolean isVoiceInteraction) &#123; ...... if (wtoken.hidden == visible || (wtoken.hidden &amp;&amp; wtoken.mIsExiting) || (visible &amp;&amp; wtoken.waitingForReplacement())) &#123; ...... if (transit != AppTransition.TRANSIT_UNSET) &#123; ...... if (applyAnimationLocked(wtoken, lp, transit, visible, isVoiceInteraction)) &#123; delayed = runningAppAnimation = true; &#125; ...... changed = true; &#125; &#125; &#125; 调用WindowManagerService.applyAnimationLocked()设置AppTransition动画 12345678910[-&gt;WindowManagerService.java] private boolean applyAnimationLocked(AppWindowToken atoken, WindowManager.LayoutParams lp, int transit, boolean enter, boolean isVoiceInteraction) &#123; ...... if (okToDisplay()) &#123; Animation a = mAppTransition.loadAnimation(lp, transit, enter, mCurConfiguration.uiMode, mCurConfiguration.orientation, frame, displayFrame, insets, surfaceInsets, isVoiceInteraction, freeform, atoken.mTask.mTaskId); &#125;&#125; 终于到了AppTransition真正设置过程了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[-&gt;AppTransition.java]Animation loadAnimation(WindowManager.LayoutParams lp, int transit, boolean enter, int uiMode, int orientation, Rect frame, Rect displayFrame, Rect insets, @Nullable Rect surfaceInsets, boolean isVoiceInteraction, boolean freeform, int taskId) &#123; Animation a; if()&#123;&#125; ...... &#125; else if()&#123; ...... &#125;else &#123; int animAttr = 0; switch (transit) &#123; case TRANSIT_ACTIVITY_OPEN: animAttr = enter ? WindowAnimation_activityOpenEnterAnimation : WindowAnimation_activityOpenExitAnimation; break; case TRANSIT_ACTIVITY_CLOSE: animAttr = enter ? WindowAnimation_activityCloseEnterAnimation : WindowAnimation_activityCloseExitAnimation; break; case TRANSIT_DOCK_TASK_FROM_RECENTS: case TRANSIT_TASK_OPEN: animAttr = enter ? WindowAnimation_taskOpenEnterAnimation : WindowAnimation_taskOpenExitAnimation; break; case TRANSIT_TASK_CLOSE: animAttr = enter ? WindowAnimation_taskCloseEnterAnimation : WindowAnimation_taskCloseExitAnimation; break; case TRANSIT_TASK_TO_FRONT: animAttr = enter ? WindowAnimation_taskToFrontEnterAnimation : WindowAnimation_taskToFrontExitAnimation; break; case TRANSIT_TASK_TO_BACK: animAttr = enter ? WindowAnimation_taskToBackEnterAnimation : WindowAnimation_taskToBackExitAnimation; break; ...... &#125; a = animAttr != 0 ? loadAnimationAttr(lp, animAttr) : null; &#125; return a;&#125; 最后通过loadAnimationAttr加载xml文件加载动画，动画xml文件的存放路径（/frameworks/base/core/res/res/anim/） 5.3、executeAppTransition过程 ActivityStackSupervisor.realStartActivityLocked() ActivityStack.minimalResumeActivityLocked()ActivityStack.completeResumeLocked()ActivityStackSupervisor.reportResumedActivityLocked() 继续分析ActivityStackSupervisor.reportResumedActivityLocked() 1234567891011[-&gt;ActivityStackSupervisor.java]boolean reportResumedActivityLocked(ActivityRecord r) &#123; final ActivityStack stack = r.task.stack; ...... if (allResumedActivitiesComplete()) &#123; ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); mWindowManager.executeAppTransition(); return true; &#125; return false;&#125; 首先是Activity组件的可见性设置，然后执行executeAppTransition() 5.3.1.WindowManagerService.executeAppTransition()123456789101112131415[-&gt;WindowManagerService.java] public void executeAppTransition() &#123; ...... synchronized(mWindowMap) &#123; if (mAppTransition.isTransitionSet()) &#123; mAppTransition.setReady(); ...... try &#123; mWindowPlacerLocked.performSurfacePlacement(); &#125; finally &#123; ...... &#125; &#125; &#125; &#125; 而WindowSurfacePlacer.performSurfacePlacement()请看前面第二节分析 （六）、Activity Window 动画显示过程6.1、动画的设置过程 在Android系统中，窗口动画的本质就是对原始窗口施加一个变换（Transformation）。在线性数学中，对物体的形状进行变换是通过乘以一个矩阵（Matrix）来实现，目的就是对物体进行偏移、旋转、缩放、切变、反射和投影等。因此，给窗口设置动画实际上就给窗口设置一个变换矩阵（Transformation Matrix）。 窗口被设置的动画虽然可以达到三个，但是这三个动画可以归结为两类，一类是普通动画，例如，窗口在打开过程中被设置的进入动画和在关闭过程中被设置的退出动画，另一类是切换动画。其中，Self Transformation和Attached Transformation都是属于普通动画，而App Transformation属于切换动画。前面已经分析过App Transformation的设置过程接下来分析普通动画的设置过程。 6.1、普通动画的设置过程普通动画的设置过程也是通过setTokenVisibilityLocked()设置的 6.1.1、WindowManagerService.setTokenVisibilityLocked()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[-&gt;WindowManagerService.java] boolean setTokenVisibilityLocked(AppWindowToken wtoken, WindowManager.LayoutParams lp, boolean visible, int transit, boolean performLayout, boolean isVoiceInteraction) &#123; ...... if (wtoken.hidden == visible || (wtoken.hidden &amp;&amp; wtoken.mIsExiting) || (visible &amp;&amp; wtoken.waitingForReplacement())) &#123; ...... if (transit != AppTransition.TRANSIT_UNSET) &#123; ...... if (applyAnimationLocked(wtoken, lp, transit, visible, isVoiceInteraction)) &#123; delayed = runningAppAnimation = true; &#125; ...... changed = true; &#125; final int windowsCount = wtoken.allAppWindows.size(); for (int i = 0; i &lt; windowsCount; i++) &#123; WindowState win = wtoken.allAppWindows.get(i); ...... if (visible) &#123; if (!win.isVisibleNow()) &#123; if (!runningAppAnimation) &#123; win.mWinAnimator.applyAnimationLocked( WindowManagerPolicy.TRANSIT_ENTER, true); ...... &#125; changed = true; win.setDisplayLayoutNeeded(); &#125; &#125; else if (win.isVisibleNow()) &#123; if (!runningAppAnimation) &#123; win.mWinAnimator.applyAnimationLocked( WindowManagerPolicy.TRANSIT_EXIT, false); ...... &#125; changed = true; win.setDisplayLayoutNeeded(); &#125; &#125; wtoken.hidden = wtoken.hiddenRequested = !visible; visibilityChanged = true; ...... if (changed) &#123; mInputMonitor.setUpdateInputWindowsNeededLw(); if (performLayout) &#123; updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES, false /*updateInputWindows*/); mWindowPlacerLocked.performSurfacePlacement(); &#125; mInputMonitor.updateInputWindowsLw(false /*force*/); &#125; &#125; &#125; 可以看到普通动画是通过win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER, true) 6.1.1.WindowStateAnimator.applyAnimationLocked()1234567891011121314151617181920212223242526272829303132333435363738[-&gt;WindowStateAnimator.java]boolean applyAnimationLocked(int transit, boolean isEntrance) &#123; ...... if (mService.okToDisplay()) &#123; int anim = mPolicy.selectAnimationLw(mWin, transit); int attr = -1; Animation a = null; if (anim != 0) &#123; a = anim != -1 ? AnimationUtils.loadAnimation(mContext, anim) : null; &#125; else &#123; switch (transit) &#123; case WindowManagerPolicy.TRANSIT_ENTER: attr = com.android.internal.R.styleable.WindowAnimation_windowEnterAnimation; break; case WindowManagerPolicy.TRANSIT_EXIT: attr = com.android.internal.R.styleable.WindowAnimation_windowExitAnimation; break; case WindowManagerPolicy.TRANSIT_SHOW: attr = com.android.internal.R.styleable.WindowAnimation_windowShowAnimation; break; case WindowManagerPolicy.TRANSIT_HIDE: attr = com.android.internal.R.styleable.WindowAnimation_windowHideAnimation; break; &#125; if (attr &gt;= 0) &#123; a = mService.mAppTransition.loadAnimationAttr(mWin.mAttrs, attr); &#125; &#125; if (a != null) &#123; setAnimation(a); mAnimationIsEntrance = isEntrance; &#125; &#125; else &#123; clearAnimation(); &#125; ...... return mAnimation != null;&#125; 可以看到也是根据动画类型从而通过AppTransition.loadAnimationAttr(mWin.mAttrs, attr)加载不同的anim xml文件。 6.2、窗口动画的显示框架通过堆栈信息可以看到，由Vsync信号驱动，然后调用Choreographer.doFrame完成动画的相关操作，关于Vsync这部分之前文章已经分析过，这里不再分析了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130[-&gt;WindowAnimator.java]/** Locked on mService.mWindowMap. */private void animateLocked(long frameTimeNs) &#123; ...... mCurrentTime = frameTimeNs / TimeUtils.NANOS_PER_MS; mBulkUpdateParams = SET_ORIENTATION_CHANGE_COMPLETE; boolean wasAnimating = mAnimating; setAnimating(false); mAppWindowAnimating = false; ...... if (SHOW_TRANSACTIONS) Slog.i( TAG, \"&gt;&gt;&gt; OPEN TRANSACTION animateLocked\"); SurfaceControl.openTransaction(); SurfaceControl.setAnimationTransaction(); try &#123; final int numDisplays = mDisplayContentsAnimators.size(); for (int i = 0; i &lt; numDisplays; i++) &#123; final int displayId = mDisplayContentsAnimators.keyAt(i); //1、Activity组件切换动画的推进过程 updateAppWindowsLocked(displayId); DisplayContentsAnimator displayAnimator = mDisplayContentsAnimators.valueAt(i); final ScreenRotationAnimation screenRotationAnimation = displayAnimator.mScreenRotationAnimation; if (screenRotationAnimation != null &amp;&amp; screenRotationAnimation.isAnimating()) &#123; if (screenRotationAnimation.stepAnimationLocked(mCurrentTime)) &#123; setAnimating(true); &#125; else &#123; mBulkUpdateParams |= SET_UPDATE_ROTATION; screenRotationAnimation.kill(); displayAnimator.mScreenRotationAnimation = null; //TODO (multidisplay): Accessibility supported only for the default display. if (mService.mAccessibilityController != null &amp;&amp; displayId == Display.DEFAULT_DISPLAY) &#123; // We just finished rotation animation which means we did not // anounce the rotation and waited for it to end, announce now. mService.mAccessibilityController.onRotationChangedLocked( mService.getDefaultDisplayContentLocked(), mService.mRotation); &#125; &#125; &#125; // Update animations of all applications, including those // associated with exiting/removed apps //2、窗口动画的推进过程 updateWindowsLocked(displayId); //壁纸动画的推进过程 updateWallpaperLocked(displayId); final WindowList windows = mService.getWindowListLocked(displayId); final int N = windows.size(); //3、通过一个for循环来遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新 //确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息 for (int j = 0; j &lt; N; j++) &#123; windows.get(j).mWinAnimator.prepareSurfaceLocked(true); &#125; &#125; for (int i = 0; i &lt; numDisplays; i++) &#123; final int displayId = mDisplayContentsAnimators.keyAt(i); testTokenMayBeDrawnLocked(displayId); final ScreenRotationAnimation screenRotationAnimation = mDisplayContentsAnimators.valueAt(i).mScreenRotationAnimation; if (screenRotationAnimation != null) &#123; screenRotationAnimation.updateSurfacesInTransaction(); &#125; orAnimating(mService.getDisplayContentLocked(displayId).animateDimLayers()); orAnimating(mService.getDisplayContentLocked(displayId).getDockedDividerController() .animate(mCurrentTime)); //TODO (multidisplay): Magnification is supported only for the default display. if (mService.mAccessibilityController != null &amp;&amp; displayId == Display.DEFAULT_DISPLAY) &#123; mService.mAccessibilityController.drawMagnifiedRegionBorderIfNeededLocked(); &#125; &#125; ...... //4、触发下一帧动画逻辑 if (mAnimating) &#123; mService.scheduleAnimationLocked(); &#125; if (mService.mWatermark != null) &#123; mService.mWatermark.drawIfNeeded(); &#125; &#125; catch (RuntimeException e) &#123; ...... &#125; finally &#123; SurfaceControl.closeTransaction(); if (SHOW_TRANSACTIONS) Slog.i( TAG, \"&lt;&lt;&lt; CLOSE TRANSACTION animateLocked\"); &#125; boolean hasPendingLayoutChanges = false; final int numDisplays = mService.mDisplayContents.size(); for (int displayNdx = 0; displayNdx &lt; numDisplays; ++displayNdx) &#123; final DisplayContent displayContent = mService.mDisplayContents.valueAt(displayNdx); final int pendingChanges = getPendingLayoutChanges(displayContent.getDisplayId()); if ((pendingChanges &amp; WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) &#123; mBulkUpdateParams |= SET_WALLPAPER_ACTION_PENDING; &#125; if (pendingChanges != 0) &#123; hasPendingLayoutChanges = true; &#125; &#125; boolean doRequest = false; if (mBulkUpdateParams != 0) &#123; doRequest = mWindowPlacerLocked.copyAnimToLayoutParamsLocked(); &#125; //5、刷新系统UI if (hasPendingLayoutChanges || doRequest) &#123; mWindowPlacerLocked.requestTraversal(); &#125; ...... if (mRemoveReplacedWindows) &#123; removeReplacedWindowsLocked(); &#125; mService.stopUsingSavedSurfaceLocked(); mService.destroyPreservedSurfaceLocked(); mService.mWindowPlacerLocked.destroyPendingSurfaces(); ......&#125; 1、Activity组件切换动画的推进、2、窗口动画的推进、壁纸动画推进3、循环遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息4、触发下一帧动画逻辑5、刷新系统UI其中第3点 prepareSurfaceLocked在3.3.小节已经分析过了、第5点最终会调用mWindowPlacerLocked.performSurfacePlacement来刷新UI，也已经分析过了。接下来分析Activity组件切换动画、窗口动画的推进过程。 6.3、Activity组件切换动画AppWindowAnimator:属于AppWindowToken，它的成员变量mAppAnimator代表了此应用程序所属的AppWindowAnimatorWindowStateAnimator:WMS记录了所有窗口的WindowState，其中WindowState.mWinAnimator是一个WindowStateAnimator对象，它和上面AppWindowAnimator一样可以由开发人员定制 WindowAnimator.updateAppWindowsLocked()123456789101112131415161718192021222324[-&gt;WindowAnimator.java]private void updateAppWindowsLocked(int displayId) &#123; ArrayList&lt;TaskStack&gt; stacks = mService.getDisplayContentLocked(displayId).getStacks(); for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final TaskStack stack = stacks.get(stackNdx); final ArrayList&lt;Task&gt; tasks = stack.getTasks(); for (int taskNdx = tasks.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123; final AppTokenList tokens = tasks.get(taskNdx).mAppTokens; for (int tokenNdx = tokens.size() - 1; tokenNdx &gt;= 0; --tokenNdx) &#123; final AppWindowAnimator appAnimator = tokens.get(tokenNdx).mAppAnimator; appAnimator.wasAnimating = appAnimator.animating; if (appAnimator.stepAnimationLocked(mCurrentTime, displayId)) &#123; appAnimator.animating = true; setAnimating(true); mAppWindowAnimating = true; &#125; else if (appAnimator.wasAnimating) &#123; // stopped animating, do one more pass through the layout setAppLayoutChanges(appAnimator, WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER, \"appToken \" + appAnimator.mAppToken + \" done\", displayId); ...... &#125; &#125; &#125; 调用stepAnimationLocked()12345678910111213141516171819202122232425[-&gt;AppWindowAnimator.java] // This must be called while inside a transaction. boolean stepAnimationLocked(long currentTime, final int displayId) &#123; if (mService.okToDisplay()) &#123; ...... if ((mAppToken.allDrawn || animating || mAppToken.startingDisplayed) &amp;&amp; animation != null) &#123; ...... if (stepAnimation(currentTime)) &#123; // animation isn't over, step any thumbnail and that's // it for now. if (thumbnail != null) &#123; stepThumbnailAnimation(currentTime); &#125; return true; &#125; &#125; &#125; else if (animation != null) &#123; animating = true; animation = null; &#125; ...... &#125;&#125; 调用stepAnimation()123456789101112131415161718192021222324252627[-&gt;AppWindowAnimator.java]private boolean stepAnimation(long currentTime) &#123; if (animation == null) &#123; return false; &#125; //1. transformation.clear(); final long animationFrameTime = getAnimationFrameTime(animation, currentTime); //2. boolean hasMoreFrames = animation.getTransformation(animationFrameTime, transformation); if (!hasMoreFrames) &#123; if (deferThumbnailDestruction &amp;&amp; !deferFinalFrameCleanup) &#123; deferFinalFrameCleanup = true; hasMoreFrames = true; &#125; else &#123; deferFinalFrameCleanup = false; if (mProlongAnimation == PROLONG_ANIMATION_AT_END) &#123; hasMoreFrames = true; &#125; else &#123; setNullAnimation(); clearThumbnail(); &#125; &#125; &#125; hasTransformation = hasMoreFrames; return hasMoreFrames;&#125; 1.将成员变量transformation所描述的变换矩阵的数据清空2.调用Animation.getTransformation()来计算Activity组件切换动画下一步所对应的变换矩阵，并且将这个变换矩阵的数据保存在成员变量transformation 6.4、窗口动画的推进过程继续分析WindowAnimator.animateLocked()的updateWindowsLocked() 6.4.1、WindowAnimator.updateWindowsLocked()1234567891011121314151617181920212223[-&gt;WindowAnimator.java]private void updateWindowsLocked(final int displayId) &#123; ++mAnimTransactionSequence; final WindowList windows = mService.getWindowListLocked(displayId); ...... for (int i = windows.size() - 1; i &gt;= 0; i--) &#123; WindowState win = windows.get(i); WindowStateAnimator winAnimator = win.mWinAnimator; final int flags = win.mAttrs.flags; boolean canBeForceHidden = mPolicy.canBeForceHidden(win, win.mAttrs); boolean shouldBeForceHidden = shouldForceHide(win); if (winAnimator.hasSurface()) &#123; final boolean wasAnimating = winAnimator.mWasAnimating; final boolean nowAnimating = winAnimator.stepAnimationLocked(mCurrentTime); winAnimator.mWasAnimating = nowAnimating; orAnimating(nowAnimating); &#125; &#125; ...... &#125; ......&#125; WindowStateAnimator.stepAnimationLocked()如果窗口的动画尚未结束显示，那么stepAnimationLocked()会返回一个true值给调用者，否则的话，就会返回一个false值给调用者12345678910111213141516171819202122232425262728293031323334353637383940[-&gt;WindowStateAnimator.java] boolean stepAnimationLocked(long currentTime) &#123; // Save the animation state as it was before this step so WindowManagerService can tell if // we just started or just stopped animating by comparing mWasAnimating with isAnimationSet(). mWasAnimating = mAnimating; final DisplayContent displayContent = mWin.getDisplayContent(); if (displayContent != null &amp;&amp; mService.okToDisplay()) &#123; // We will run animations as long as the display isn't frozen. if (mWin.isDrawnLw() &amp;&amp; mAnimation != null) &#123; mHasTransformation = true; mHasLocalTransformation = true; if (!mLocalAnimating) &#123; final DisplayInfo displayInfo = displayContent.getDisplayInfo(); if (mAnimateMove) &#123; mAnimateMove = false; mAnimation.initialize(mWin.mFrame.width(), mWin.mFrame.height(), mAnimDx, mAnimDy); &#125; else &#123; mAnimation.initialize(mWin.mFrame.width(), mWin.mFrame.height(), displayInfo.appWidth, displayInfo.appHeight); &#125; mAnimDx = displayInfo.appWidth; mAnimDy = displayInfo.appHeight; mAnimation.setStartTime(mAnimationStartTime != -1 ? mAnimationStartTime : currentTime); mLocalAnimating = true; mAnimating = true; &#125; if ((mAnimation != null) &amp;&amp; mLocalAnimating) &#123; mLastAnimationTime = currentTime; if (stepAnimation(currentTime)) &#123; return true; &#125; &#125; ...... &#125; ...... return false; &#125; 12345678910111213[-&gt;WindowStateAnimator.java]private boolean stepAnimation(long currentTime) &#123; ...... currentTime = getAnimationFrameTime(mAnimation, currentTime); //1. mTransformation.clear(); //2. final boolean more = mAnimation.getTransformation(currentTime, mTransformation); if (mAnimationStartDelayed &amp;&amp; mAnimationIsEntrance) &#123; mTransformation.setAlpha(0f); &#125; return more;&#125; 1、将成员变量mTransformation所描述的变换矩阵的数据清空。2、调用mAnimation.getTransformation()来计算窗口动画下一步所对应的变换矩阵，并且将这个变换矩阵的数据保存在成员变量mTransformation。 然后就是动画过后，窗口大小计算、渲染合成等等显示步骤了，由于之前已经分析过了，不再分析了：3、循环遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息 12345[-&gt;WindowAnimator.java::animateLocked()]//确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息for (int j = 0; j &lt; N; j++) &#123; windows.get(j).mWinAnimator.prepareSurfaceLocked(true);&#125; 4、触发下一帧动画逻辑 1234[-&gt;WindowAnimator.java::animateLocked()]if (mAnimating) &#123; mService.scheduleAnimationLocked();&#125; 5、刷新系统UI 1234[-&gt;WindowAnimator.java::animateLocked()]if (hasPendingLayoutChanges || doRequest) &#123; mWindowPlacerLocked.requestTraversal();&#125; 最终经过SurfaceFlinger合成显示到屏幕上。总体流程图(…)： （七）、参考文档(特别感谢各位前辈的分析和图示)：浅析 Android 的窗口WMS:窗口大小的计算Android 窗口的计算过程Android Window 机制探索Android 窗口管理 - 且听风吟Android 关于Window OverscanWindowManagerService动画分析深入理解Activity——Token之旅 - CSDN博客Android 4.4(KitKat)窗口管理子系统 - 体系框架Android窗口系统第四篇—Activity动画的设置过程 Android 7.1 GUI系统-窗口管理WMS-Surface管理（四）Android 的窗口管理系统 (View, Canvas, WindowManager)WMS—启动窗口(StartingWindow) - Gityuan博客 | 袁辉辉博客View绘制流程及源码解析(一)——performTraversals()源码分析Android窗口系统第三篇—WindowManagerService中窗口的组织方式google 进入分屏后在横屏模式按 home 键界面错乱 (二) - Android - 掘金Android应用Activity、Dialog、PopWindow、Toast窗口添加机制及源码分析Android窗口管理服务WindowManagerService的简要介绍和学习计划 - CSDN博客Android窗口管理分析（2）：WindowManagerService窗口管理之Window添加流程Android窗口管理服务WindowManagerService显示窗口动画的原理分析 - CSDN博客Android6.0 WMS（五） WMS计算Activity窗口大小的过程分析（二）WMS的relayoutWindow","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Android Graphics 系统 分析 [i.wonder~]","slug":"Android-7-1-2-Android-N-Android-Graphics-系统分析","date":"2018-01-31T16:00:00.000Z","updated":"2018-03-23T07:20:44.000Z","comments":true,"path":"2018/02/01/Android-7-1-2-Android-N-Android-Graphics-系统分析/","link":"","permalink":"http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-系统分析/","excerpt":"Android系统图形框架由下往上主要的包括HAL(HWComposer和Gralloc两个moudle)，SurfaceFlinger（BufferQueue的消费者），WindowManagerService（窗口管理者），View（BufferQueue的生产者）四大模块。● HAL: 包括HWComposer和Gralloc两个moudle，Android N上由SurfaceFlinger打开，因此在同一进程。 gralloc 用于BufferQueue的内存分配，同时也有fb的显示接口，HWComposer作为合成SurfaceFlinger里面的Layer，并显示（通过gralloc的post函数）● SurfaceFlinger可以叫做LayerFlinger，作为Layer的管理者，同是也是BufferQueue的消费者，当每个Layer的生产者draw完完整的一帧时，会通知SurfaceFlinger，通知的方式采用BufferQueue。● WindowManagerService: 作为Window的管理者，掌管着计算窗口大小，窗口切换等任务，同时也会将相应的参数设置给SurfaceFlinger，比如Window的在z-order，和窗口的大小。● View: 作为BufferQueue的生产者，每当执行lockCanvas-&gt;draw-&gt;unlockCanvas，之后会存入一帧数据进入BufferQueue中。嘿嘿(^▽^),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。","text":"Android系统图形框架由下往上主要的包括HAL(HWComposer和Gralloc两个moudle)，SurfaceFlinger（BufferQueue的消费者），WindowManagerService（窗口管理者），View（BufferQueue的生产者）四大模块。● HAL: 包括HWComposer和Gralloc两个moudle，Android N上由SurfaceFlinger打开，因此在同一进程。 gralloc 用于BufferQueue的内存分配，同时也有fb的显示接口，HWComposer作为合成SurfaceFlinger里面的Layer，并显示（通过gralloc的post函数）● SurfaceFlinger可以叫做LayerFlinger，作为Layer的管理者，同是也是BufferQueue的消费者，当每个Layer的生产者draw完完整的一帧时，会通知SurfaceFlinger，通知的方式采用BufferQueue。● WindowManagerService: 作为Window的管理者，掌管着计算窗口大小，窗口切换等任务，同时也会将相应的参数设置给SurfaceFlinger，比如Window的在z-order，和窗口的大小。● View: 作为BufferQueue的生产者，每当执行lockCanvas-&gt;draw-&gt;unlockCanvas，之后会存入一帧数据进入BufferQueue中。嘿嘿(^▽^),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。 【博客原图链接】源码（部分）：/frameworks/native/services/surfaceflinger/ tests/Transaction_test.cpp tests/vsync/vsync.cpp /frameworks/native/include/gui/ BitTube.h BufferSlot.h BufferQueueCore.h BufferQueueProducer.h /frameworks/base/core/java/android/app/ Activity.java ActivityThread.java Instrumentation.java /frameworks/base/core/jni/ android_view_DisplayEventReceiver.cpp android_view_SurfaceControl.cpp android_view_Surface.cpp android_view_SurfaceSession.cpp /frameworks/native/include/gui/ SurfaceComposerClient.h IDisplayEventConnection.h SurfaceComposerClient.h /frameworks/native/services/surfaceflinger/ SurfaceFlinger.cpp Client.cpp main_surfaceflinger.cpp DisplayDevice.cpp DispSync.cpp EventControlThread.cpp EventThread.cpp Layer.cpp MonitoredProducer.cpp /frameworks/base/core/java/android/view/ WindowManagerImpl.java ViewManager.java WindowManagerGlobal.java ViewRootImpl.java Choreographer.java IWindowSession.aidl DisplayEventReceiver.java SurfaceControl.java Surface.java SurfaceSession.java /frameworks/native/include/ui/ GraphicBuffer.h GraphicBufferAllocator.h /frameworks/base/services/core/java/com/android/server/wm/ WindowManagerService.java Session.java WindowState.java WindowStateAnimator.java WindowSurfaceController.java 【博客原图链接】（一）、Android Graphics 系统框架（试用限制？？？万恶的亿图(EDraw)强加水印~火~） App基于Android系统的GUI框架开发完整的Apk应用。 Android Graphics Stack Client(SurfaceFlinger Client)Android在客户端的绘图堆栈通常包括：OpenGL ES：使用GPU进行3D和2D的绘图的APIEGL：衔接GLES和系统的Native Window系统的适配层Vulkan：Vulkan为Khronos Group推出的下一代跨平台图形开发接口，用于替代历史悠久的OpenGL。Android从7.0(Nougat)开始加入了对其的支持。Vulkan与OpenGL相比，接口更底层，从而使开发者能更直接地控制GPU。由于更好的并行支持，及更小的开销，性能上也有一定的提升。Android Graphics Stack Server（SurfaceFlinger Server）SurfaceFlinger是Android用于管理Display和负责Window Composite（窗口混合），把应用的显示窗口输出到Display的系统服务。 Android Drivers（HAL）Android的驱动层，通过Android本身的HAL（硬件抽象层）机制，运行于User Space，跟渲染相关的包括： Hwcomposer：如果硬件支持，SurfaceFlinger可以请求hwcomposer去做窗口混合而不需要自己来做，这样的效率也会更高，减少对GPU资源的占用Gralloc：用来管理Graphics Buffer的分配和管理系统的framebufferOpenGL ES/EGL Linux Kernel and Drivers除了标准的Linux内核和驱动（例如fb是framebuffer驱动），硬件厂商自己的驱动外，Android自己的一些Patches： Ashmem：异步共享内存，用于在进程间共享一块内存区域，并允许系统在资源紧张时回收不加锁的内存块ION：内存管理器 ION是google在Android4.0 为了解决内存碎片管理而引入的通用内存管理器,在面向程序员编程方面，它和ashmem很相似。但ION比ashmem更强大Binder：高效的进程间通信机制Vsync：Android 4.1引入了Vsync(Vertical Syncronization)用于渲染同步，使得App UI和SurfaceFlinger可以按硬件产生的VSync节奏来进行工作HardwareDisplay（显示器）、CPU、GPU、VPU（Video Process Unit）、和内存等等 （二）、Android Graphics 测试程序（C++）为了便于观察对原生测试程序显示图像大小做了如下修改： frameworks/native/services/surfaceflinger/tests/Transaction_test.cpp Disable_HWUI_GPU_HWC.patch 原生SurfaceFlinger测试程序编译：1、编译Android 7.1.2源码-userdebug版本，烧录重启2、编译/frameworks/native/services/surfaceflinger/tests/会生成SurfaceFlinger_test3、连接手机执行命令 adb root、adb remount、adb push SurfaceFlinger_test /system/bin/4、adb shell setenforce 0(暂时关闭SELinux权限)5、adb shell、cd system/bin/、chmod 0777 SurfaceFlinger_test6、运行测试程序：./SurfaceFlinger_test 可以看到在Android 显示屏接替绘制了多个图像，并且会变换形状、位置、颜色、透明度等。我们先看一下主要步骤：1、 创建SurfaceComposerClient 12sp&lt;SurfaceComposerClient&gt; mComposerClient;mComposerClient = new SurfaceComposerClient; 2、 客户端SurfaceComposerClient请求SurfaceFlinger创建Surface注：App端对应SurfaceControl&lt;—&gt;SurfaceFlinger对应Layer 12345678sp&lt;SurfaceControl&gt; mBGSurfaceControl;sp&lt;SurfaceControl&gt; mFGSurfaceControl; // Background surfacemBGSurfaceControl = mComposerClient-&gt;createSurface( String8(\"BG Test Surface\"), displayWidth, displayHeight, PIXEL_FORMAT_RGBA_8888, 0); fillSurfaceRGBA8(mBGSurfaceControl, 63, 63, 195); 1234// Foreground surfacemFGSurfaceControl = mComposerClient-&gt;createSurface( String8(\"FG Test Surface\"), 64, 64, PIXEL_FORMAT_RGBA_8888, 0);fillSurfaceRGBA8(mFGSurfaceControl, 195, 63, 63); 3、处理事务，将SurfaceControl（App）的变化更新到Layer（SurfaceFlinger）图层123456789101112SurfaceComposerClient::openGlobalTransaction(); mComposerClient-&gt;setDisplayLayerStack(display, 0); ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX-2)); ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show()); ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setLayer(INT_MAX-1)); ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(64, 64)); ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;show()); SurfaceComposerClient::closeGlobalTransaction(true); 4、接受Vsync同步信号，渲染合成，推送到显示屏显示 接下来开始Android Graphics系统神秘探索之谜。 （三）、Android Graphics 禁用hwc和GPU3.1、Disable_HWUI_GPU_HWC注：基于Android 7.1.2 Qualcomm MSM89XX源码，由于代码段较长，已放到GitHubDisable_HWUI_GPU_HWC.patch 编译userdebug版本，烧录开机:运行测试程序：./SurfaceFlinger_test 结果跟上述一致，这里不再贴图了。 3.2、Vsync测试程序Vsync(Vertical Syncronization)用于渲染同步，使得App UI和SurfaceFlinger可以按硬件产生的VSync节奏来进行工作。 查看frameworks/native/services/surfaceflinger/tests/下还有vsync测试程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;android/looper.h&gt;#include &lt;gui/DisplayEventReceiver.h&gt;#include &lt;utils/Looper.h&gt;using namespace android;int receiver(int fd, int events, void* data)&#123; DisplayEventReceiver* q = (DisplayEventReceiver*)data; ssize_t n; DisplayEventReceiver::Event buffer[1]; static nsecs_t oldTimeStamp = 0; while ((n = q-&gt;getEvents(buffer, 1)) &gt; 0) &#123; for (int i=0 ; i&lt;n ; i++) &#123; if (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123; printf(\"event vsync: count=%d\\t\", buffer[i].vsync.count); &#125; if (oldTimeStamp) &#123; float t = float(buffer[i].header.timestamp - oldTimeStamp) / s2ns(1); printf(\"%f ms (%f Hz)\\n\", t*1000, 1.0/t); &#125; oldTimeStamp = buffer[i].header.timestamp; &#125; &#125; if (n&lt;0) &#123;printf(\"error reading events (%s)\\n\", strerror(-n));&#125; return 1;&#125;int main(int argc, char** argv)&#123; DisplayEventReceiver myDisplayEvent; sp&lt;Looper&gt; loop = new Looper(false); loop-&gt;addFd(myDisplayEvent.getFd(), 0, ALOOPER_EVENT_INPUT, receiver, &amp;myDisplayEvent); myDisplayEvent.setVsyncRate(1); do &#123; //printf(\"about to poll...\\n\"); int32_t ret = loop-&gt;pollOnce(-1); switch (ret) &#123; case ALOOPER_POLL_WAKE: //(\"ALOOPER_POLL_WAKE\\n\"); break; case ALOOPER_POLL_CALLBACK: //(\"ALOOPER_POLL_CALLBACK\\n\"); break; case ALOOPER_POLL_TIMEOUT: printf(\"ALOOPER_POLL_TIMEOUT\\n\"); break; case ALOOPER_POLL_ERROR: printf(\"ALOOPER_POLL_TIMEOUT\\n\"); break; default: printf(\"ugh? poll returned %d\\n\", ret); break; &#125; &#125; while (1); return 0;&#125; 编译运行看看：可以看到vsync信号每隔16 ms一次，关于vsync知识稍后再分析。 123456event vsync: count=2631 16.168612 ms (61.848231 Hz)event vsync: count=2632 16.168613 ms (61.848224 Hz)event vsync: count=2633 16.168312 ms (61.849378 Hz)event vsync: count=2634 16.168682 ms (61.847961 Hz)event vsync: count=2635 16.168596 ms (61.848288 Hz)event vsync: count=2636 16.168867 ms (61.847255 Hz) （四）、Android SurfaceFlinger 内部机制4.1、APP与SurfaceFlinger的数据结构 4.1.1、BufferQueue介绍BufferQueue 类是 Android 中所有图形处理操作的核心。它的是将生成图形数据缓冲区的一方（生产者Producer）连接到接受数据以进行显示或进一步处理的一方（消费者Consumer）。几乎所有在系统中移动图形数据缓冲区的内容都依赖于 BufferQueue。从上图APP与SurfaceFlinger交互中可以看出，BufferQueue内部维持着64个BufferSlot，每一个BufferSlot内部有一个GraphicBuffer指向分配的Graphic Buffer。先来看一下图中几个状态代表的含义： 1234567891011frameworks/native/include/gui/BufferSlot.h// A buffer can be in one of five states, represented as below://// | mShared | mDequeueCount | mQueueCount | mAcquireCount |// --------|---------|---------------|-------------|---------------|// FREE | false | 0 | 0 | 0 |// DEQUEUED| false | 1 | 0 | 0 |// QUEUED | false | 0 | 1 | 0 |// ACQUIRED| false | 0 | 0 | 1 |// SHARED | true | any | any | any | FREE :FREE表示缓冲区可由生产者（Producer）DEQUEUED出列。 该BufferSlot由BufferQueue“拥有”。 它转换到DEQUEUED当调用dequeueBuffer时。 DEQUEUED：DEQUEUED表示缓冲区已经被生产者（Producer）出列，但是尚未queued 或canceled。生产者（Producer）可以修改缓冲区的内容一旦相关的释放围栏被发信号通知。BufferSlot由Producer“拥有”。 它可以转换到QUEUED（通过queueBuffer或者attachBuffer）或者返回FREE（通过cancelBuffer或者detachBuffer）。 QUEUED：QUEUED表示缓冲区已经被生产者（Producer）填充排队等待消费者（Consumer）使用。 缓冲区内容可能被继续 修改在有限的时间内，所以内容不能被访问，直到关联的栅栏fence发信号。 该BufferSlot由BufferQueue“拥有”。 它 可以转换为ACQUIRED（通过acquireBuffer）或FREE（如果是另一个缓冲区以异步模式排队）。 ACQUIRED：ACQUIRED表示缓冲区已被消费者（Consumer）获取。 如与QUEUED，内容不能被消费者访问，直到获得栅栏fence信号。 BufferSlot由Consumer“拥有”。 它当releaseBuffer（或detachBuffer）被调用时转换为FREE。 一个分离的缓冲区也可以通过attachBuffer进入ACQUIRED状态。 SHARED： SHARED表示此缓冲区正在共享缓冲区中使用模式。 它可以同时在其他State的任何组合，除了FREE （因为这不包括在任何其他State）。 它可以也可以出列，排队或多次获得。 简单描述一下状态转换过程： 1、首先生产者dequeue过来一块Buffer，此时该buffer的状态为DEQUEUED，所有者为PRODUCER，生产者可以填充数据了。在没有dequeue操作时，buffer的状态为free,所有者为BUFFERQUEUE。 2、生产者填充完数据后,进行queue操作，此时buffer的状态由DEQUEUED-&gt;QUEUED的转变，buffer所有者也变成了BufferQueue了。 3、上面已经通知消费者去拿buffer了，这个时候消费者就进行acquire操作将buffer拿过来，此时buffer的状态由QUEUED-&gt;ACQUIRED转变，buffer的拥有者由BufferQueue变成Consumer。 4、当消费者已经消费了这块buffer(已经合成，已经编码等)，就进行release操作释放buffer,将buffer归还给BufferQueue,buffer状态由ACQUIRED变成FREE.buffer拥有者由Consumer变成BufferQueue. 4.1.2、生产者Producer生产者Producer实现IGraphicBufferProducer的接口，在实际运作过程中，应用（Client端）存在代理端BpGraphicBufferProducer，SurfaceFlinger（Server端）存在Native端BnGraphicBufferProducer。生产者代理端Bp通过Binder通信，不断的dequeueBuffer和queueBuffer操作，Native端同样响应这些操作请求，这样buffer就转了起来了。 这里介绍几个非常重要的函数：1、requestBufferrequestBuffer为给定的索引请求一个新的Buffer。 服务器（即IGraphicBufferProducer实现）分配新创建的Buffer到给定的BufferSlot槽索引，并且客户端可以镜像slot-&gt;Buffer映射，这样就没有必要传输一个GraphicBuffer用于每个出队操作。 12345678// requestBuffer requests a new buffer for the given index. The server (i.e.// the IGraphicBufferProducer implementation) assigns the newly created// buffer to the given slot index, and the client is expected to mirror the// slot-&gt;buffer mapping so that it&apos;s not necessary to transfer a// GraphicBuffer for every dequeue operation.//// The slot must be in the range of [0, NUM_BUFFER_SLOTS).virtual status_t requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf) = 0; 2、dequeueBufferdequeueBuffer请求一个新的Buffer Slot供客户端使用。 插槽的所有权被转移到客户端，这意味着服务器不会使用与该插槽关联的缓冲区的内容。123456// dequeueBuffer requests a new buffer slot for the client to use. Ownership// of the slot is transfered to the client, meaning that the server will not// use the contents of the buffer associated with that slot.//virtual status_t dequeueBuffer(int* slot, sp&lt;Fence&gt;* fence, uint32_t w, uint32_t h, PixelFormat format, uint32_t usage) = 0; 3、detachBufferdetachBuffer尝试删除给定buffer 的所有权插槽从buffer queue。 如果这个请求成功，该slot将会被free，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到插槽。 缓冲区必须已经被取出，并且调用者必须已经拥有sp （即必须调用requestBuffer）12345678910// detachBuffer attempts to remove all ownership of the buffer in the given// slot from the buffer queue. If this call succeeds, the slot will be// freed, and there will be no way to obtain the buffer from this interface.// The freed slot will remain unallocated until either it is selected to// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached// to the slot. The buffer must have already been dequeued, and the caller// must already possesses the sp&lt;GraphicBuffer&gt; (i.e., must have called// requestBuffer).//virtual status_t detachBuffer(int slot) = 0; 4、attachBufferattachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区已经出队一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致很多的缓冲区同时出队。1234567// attachBuffer attempts to transfer ownership of a buffer to the buffer// queue. If this call succeeds, it will be as if this buffer was dequeued// from the returned slot number. As such, this call will fail if attaching// this buffer would cause too many buffers to be simultaneously dequeued.//virtual status_t attachBuffer(int* outSlot, const sp&lt;GraphicBuffer&gt;&amp; buffer) = 0; 4.1.3、消费者Consumer这里介绍几个非常重要的函数：1、acquireBufferacquireBuffer尝试获取下一个未决缓冲区的所有权BufferQueue。 如果没有缓冲区等待，则返回NO_BUFFER_AVAILABLE。 如果缓冲区被成功获取，有关缓冲区的信息将在BufferItem中返回。 1234567// acquireBuffer attempts to acquire ownership of the next pending buffer in// the BufferQueue. If no buffer is pending then it returns// NO_BUFFER_AVAILABLE. If a buffer is successfully acquired, the// information about the buffer is returned in BufferItem.//virtual status_t acquireBuffer(BufferItem* buffer, nsecs_t presentWhen, uint64_t maxFrameNumber = 0) = 0; 2、releaseBufferreleaseBuffer从消费者释放一个BufferSlot回到BufferQueue。 这可以在缓冲区的内容仍然存在时完成被访问。 栅栏将在缓冲区不再正在使用时发出信号。 frameNumber用于标识返回的确切缓冲区。12345678// releaseBuffer releases a buffer slot from the consumer back to the// BufferQueue. This may be done while the buffer&apos;s contents are still// being accessed. The fence will signal when the buffer is no longer// in use. frameNumber is used to indentify the exact buffer returned.//virtual status_t releaseBuffer(int buf, uint64_t frameNumber, EGLDisplay display, EGLSyncKHR fence, const sp&lt;Fence&gt;&amp; releaseFence) = 0; 3、detachBufferdetachBuffer尝试删除给定缓冲区的所有权插槽从缓冲区队列。 如果这个请求成功，该插槽将会是释放，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到slot。 缓冲区必须已被acquired。12345678// detachBuffer attempts to remove all ownership of the buffer in the given// slot from the buffer queue. If this call succeeds, the slot will be// freed, and there will be no way to obtain the buffer from this interface.// The freed slot will remain unallocated until either it is selected to// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached// to the slot. The buffer must have already been acquired.//virtual status_t detachBuffer(int slot) = 0; 4、attachBufferattachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区被获取了一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致太多的缓冲区被同时acquired。1234567// attachBuffer attempts to transfer ownership of a buffer to the buffer// queue. If this call succeeds, it will be as if this buffer was acquired// from the returned slot number. As such, this call will fail if attaching// this buffer would cause too many buffers to be simultaneously acquired.//virtual status_t attachBuffer(int *outSlot, const sp&lt;GraphicBuffer&gt;&amp; buffer) = 0; 4.2、App（Java层）请求创建Surface过程4.2.1、Activity启动流程Activity创建过程这里不再叙述。请参考【Android 7.1.2 (Android N) Activity启动流程分析】 &amp;&amp; 【Android 7.1.2 (Android N) Activity-Window加载显示流程分析】 ● ActivityManagerService接收启动Activity的请求 Activity.startActivity()Activity.startActivityForResult()Instrumentation.execStartActivity()ActivityManagerProxy.startActivity()ActivityManagerNative.onTransact()ActivityManagerService.startActivity()ActivityStarter.startActivityMayWait()ActivityStarter.startActivityLocked()ActivityStarter.startActivityUnchecked()ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()ActivityStack.resumeTopActivityUncheckedLocked()ActivityStack.resumeTopActivityInnerLocked()ActivityStackSupervisor.startSpecificActivityLocked() ●● 创建Activity所属的应用进程ActivityManagerService.startProcessLocked() ●●● Zygote通过socket通信fork一个新的进程，并根据”android.app.ActivityThread”字符串●●● 反射出该对象并执行ActivityThread的main方法ActivityThread.main()ActivityThread.attach()ActivityManagerProxy.attachApplication()ActivityManagerNative.onTransact()ActivityManagerService.attachApplication()ActivityManagerService.attachApplicationLocked()ActivityStackSupervisor.attachApplicationLocked()ActivityStackSupervisor.realStartActivityLocked() ●●●● 执行启动AcitivityIApplicationThread.scheduleLaunchActivity()ActivityThread.ApplicationThread.scheduleLaunchActivity()ActivityThread.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleLauncherActivity()ActivityThread.performLauncherActivity()ActivityThread.handleResumeActivity() 4.2.2、Window加载显示流程画图，需要重新分析一下下，嘿嘿(^▽^)~ 4.2.2.1、ActivityThread.handleLaunchActivity()接着从ActivityThread的handleLaunchActivity方法： 123456789101112131415 [-&gt;ActivityThread.java] private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason)&#123; ...... //创建Activity Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; ...... //启动Activity handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); ...... &#125;&#125; 4.2.2.2、ActivityThread.handleResumeActivity()回到我们刚刚的handleLaunchActivity()方法，在调用完performLaunchActivity()方法之后，其有掉用了handleResumeActivity()法。performLaunchActivity()方法完成了两件事：1) Activity窗口对象的创建，通过attach函数来完成；2) Activity视图对象的创建，通过setContentView函数来完成；这些准备工作完成后，就可以显示该Activity了，应用程序进程通过调用handleResumeActivity函数来启动Activity的显示过程。 [-&gt;ActivityThread.java]123456789101112131415161718192021222324252627282930 final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ActivityClientRecord r = mActivities.get(token); ...... r = performResumeActivity(token, clearHide, reason); ...... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; //获得为当前Activity创建的窗口PhoneWindow对象 r.window = r.activity.getWindow(); //获取为窗口创建的视图DecorView对象 View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); //在attach函数中就为当前Activity创建了WindowManager对象 ViewManager wm = a.getWindowManager(); //得到该视图对象的布局参数 WindowManager.LayoutParams l = r.window.getAttributes(); //将视图对象保存到Activity的成员变量mDecor中 a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; ...... if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; //将创建的视图对象DecorView添加到Activity的窗口管理器中 wm.addView(decor, l); &#125; ...... &#125; &#125;&#125; 在前面的performLaunchActivity函数中完成Activity的创建后，会将当前当前创建的Activity在应用程序进程端的描述符ActivityClientRecord以键值对的形式保存到ActivityThread的成员变量mActivities中：mActivities.put(r.token, r)，r.token就是Activity的身份证，即是IApplicationToken.Proxy代理对象，也用于与AMS通信。上面的函数首先通过performResumeActivity从mActivities变量中取出Activity的应用程序端描述符ActivityClientRecord，然后取出前面为Activity创建的视图对象DecorView和窗口管理器WindowManager，最后将视图对象添加到窗口管理器中。ViewManager.addView()真正实现的的地方在WindowManagerImpl.java中。 12345public interface ViewManager&#123;public void addView(View view, ViewGroup.LayoutParams params);......&#125; [-&gt;WindowManagerImpl.java] 12345Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; ...... mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125; [-&gt;WindowManagerGlobal.java] 123456789101112131415161718 public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ...... ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; ...... root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; try &#123; root.setView(view, wparams, panelParentView); &#125; ......&#125; 4.2.2.3、ViewRootImpl()构造过程：[ViewRootImpl.java # ViewRootImpl()] 1234567891011121314151617181920 final W mWindow; final Surface mSurface = new Surface(); final ViewRootHandler mHandler = new ViewRootHandler(); ...... public ViewRootImpl(Context context, Display display) &#123; mContext = context; mWindowSession = WindowManagerGlobal.getWindowSession();//IWindowSession的代理对象，该对象用于和WMS通信。 mDisplay = display; ...... mWindow = new W(this);//创建了一个W本地Binder对象，用于WMS通知应用程序进程 ...... mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this); ...... mViewConfiguration = ViewConfiguration.get(context); mDensity = context.getResources().getDisplayMetrics().densityDpi; mNoncompatDensity = context.getResources().getDisplayMetrics().noncompatDensityDpi; mFallbackEventHandler = new PhoneFallbackEventHandler(context); mChoreographer = Choreographer.getInstance();//Choreographer对象 ......&#125; 在ViewRootImpl的构造函数中初始化了一些成员变量，ViewRootImpl创建了以下几个主要对象： (1) 通过WindowManagerGlobal.getWindowSession()得到IWindowSession的代理对象，该对象用于和WMS通信。 (2) 创建了一个W本地Binder对象，用于WMS通知应用程序进程。 (3) 采用单例模式创建了一个Choreographer对象，用于统一调度窗口绘图。 (4) 创建ViewRootHandler对象，用于处理当前视图消息。 (5) 构造一个AttachInfo对象； ●●●(6) 创建Surface对象，用于绘制当前视图，当然该Surface对象的真正创建是由WMS来完成的，只不过是WMS传递给应用程序进程的。 4.2.2.4、IWindowSession代理获取过程[-&gt;WindowManagerGlobal.java] 12345678910111213141516171819202122 private static IWindowSession sWindowSession; public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; ...... //得到IWindowSession代理对象 sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123; @Override public void onAnimatorScaleChanged(float scale) &#123; ValueAnimator.setDurationScale(scale); &#125; &#125;, imm.getClient(), imm.getInputContext()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowSession; &#125;&#125; 以上函数通过WMS的openSession函数创建应用程序与WMS之间的连接通道，即获取IWindowSession代理对象，并将该代理对象保存到ViewRootImpl的静态成员变量sWindowSession中,因此在应用程序进程中有且只有一个IWindowSession代理对象。[-&gt;WindowManagerService.java] 12345678Overridepublic IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client, IInputContext inputContext) &#123; if (client == null) throw new IllegalArgumentException(\"null client\"); if (inputContext == null) throw new IllegalArgumentException(\"null inputContext\"); Session session = new Session(this, callback, client, inputContext); return session;&#125; 在WMS服务端构造了一个Session实例对象。ViewRootImpl 是一很重要的类，类似 ActivityThread 负责跟AmS通信一样，ViewRootImpl 的一个重要职责就是跟 WmS 通信，它通静态变量 sWindowSession（IWindowSession实例）与 WmS 进行通信。每个应用进程，仅有一个 sWindowSession 对象，它对应了 WmS 中的 Session 子类，WmS 为每一个应用进程分配一个 Session 对象。WindowState 类有一个 IWindow mClient 参数，是在构造方法中赋值的，是由 Session 调用 addWindow 传递过来了，对应了 ViewRootImpl 中的 W 类的实例。 4.2.2.5、视图View添加过程ViewRootImpl.setView()窗口管理器WindowManagerImpl为当前添加的窗口创建好各种对象后，调用ViewRootImpl的setView函数向WMS服务添加一个窗口对象。[-&gt;ViewRootImpl.java] 123456789101112131415161718192021222324252627282930public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; ////将DecorView保存到ViewRootImpl的成员变量mView中 mView = view; ...... //1）在添加窗口前进行UI布局 requestLayout(); ...... try &#123; ...... //2)将窗口添加到WMS服务中，mWindow为W本地Binder对象，通过Binder传输到WMS服务端后，变为IWindow代理对象 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; ...... //3)建立窗口消息通道 if (mInputChannel != null) &#123; if (mInputQueueCallback != null) &#123; mInputQueue = new InputQueue(); mInputQueueCallback.onInputQueueCreated(mInputQueue); &#125; mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); &#125; ...... &#125; &#125;&#125; 通过前面的分析可以知道，用户自定义的UI作为一个子View被添加到DecorView中，然后将顶级视图DecorView添加到应用程序进程的窗口管理器中，窗口管理器首先为当前添加的View创建一个ViewRootImpl对象、一个布局参数对象ViewGroup.LayoutParams，然后将这三个对象分别保存到当前应用程序进程的窗口管理器WindowManagerImpl中，最后通过ViewRootImpl对象将当前视图对象注册到WMS服务中。 ViewRootImpl的setView函数向WMS服务添加一个窗口对象过程：(1) requestLayout()在应用程序进程中进行窗口UI布局；(2) WindowSession.addToDisplay()向WMS服务注册一个窗口对象；(3) 注册应用程序进程端的消息接收通道； 4.2.2.6、requestLayout()在应用程序进程中进行窗口UI布局；2.10、窗口UI布局过程requestLayout函数调用里面使用了Hanlder的一个小手段，那就是利用postSyncBarrier添加了一个Barrier（挡板），这个挡板的作用是阻塞普通的同步消息的执行，在挡板被撤销之前，只会执行异步消息，而requestLayout先添加了一个挡板Barrier，之后自己插入了一个异步任务mTraversalRunnable，其主要作用就是保证mTraversalRunnable在所有同步Message之前被执行，保证View绘制的最高优先级。具体实现如下： 12345678910111213Overridepublic void requestLayout() &#123; scheduleTraversals();&#125;void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); ...... &#125;&#125; 这里暂时不讨论Choreographer和Vsync知识，稍后再详细分析。现在先说出结论：Choreographer构造函数中，构造了一个FrameDisplayEventReceiver对象，用于请求并接收Vsync信号。此时FrameDisplayEventReceiver会Call requestNextVsync()来告诉系统我要在下一个VSYNC需要被trigger。Vsync信号每隔16ms一次，此时Vsync信号还未来到，继续分析mWindowSession.addToDisplay()。 4.2.2.7、mWindowSession.addToDisplay()向WMS服务注册一个窗口对象；[Session.java]1234567Overridepublic int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outStableInsets, outOutsets, outInputChannel);&#125; [WindowManagerService.java] 123456789101112131415161718192021public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; ...... synchronized(mWindowMap) &#123; ...... WindowState win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); return WindowManagerGlobal.ADD_APP_EXITING; &#125; ...... if (addToken) &#123; mTokenMap.put(attrs.token, token); &#125; win.attach(); mWindowMap.put(client.asBinder(), win); ...... return res;&#125; 构造一个WindowState对象，并将添加的窗口信息记录到mTokenMap和mWindowMap哈希表中。在WMS服务端创建了所需对象后，接着调用了WindowState的attach()来进一步完成窗口添加。[WindowState.java]12345void attach() &#123; if (WindowManagerService.localLOGV) Slog.v(TAG, \"Attaching \" + this + \" token=\" + mToken + \", list=\" + mToken.windows); mSession.windowAddedLocked();&#125; [Session.java] 12345678910111213 void windowAddedLocked() &#123; if (mSurfaceSession == null) &#123; if (WindowManagerService.localLOGV) Slog.v( TAG_WM, \"First window added to \" + this + \", creating SurfaceSession\"); mSurfaceSession = new SurfaceSession(); if (SHOW_TRANSACTIONS) Slog.i(TAG_WM, \" NEW SURFACE SESSION \" + mSurfaceSession); mService.mSessions.add(this); if (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123; mService.dispatchNewAnimatorScaleLocked(this); &#125; &#125; mNumWindow++;&#125; 4.2.2.8、SurfaceSession建立过程SurfaceSession对象承担了应用程序与SurfaceFlinger之间的通信过程，每一个需要与SurfaceFlinger进程交互的应用程序端都需要创建一个SurfaceSession对象。 客户端请求[SurfaceSession.java] 123public SurfaceSession() &#123; mNativeClient = nativeCreate();&#125; Java层的SurfaceSession对象构造过程会通过JNI在native层创建一个SurfaceComposerClient对象。[android_view_SurfaceSession.cpp]12345static jlong nativeCreate(JNIEnv* env, jclass clazz) &#123;SurfaceComposerClient* client = new SurfaceComposerClient();client-&gt;incStrong((void*)nativeCreate);return reinterpret_cast&lt;jlong&gt;(client);&#125; Java层的SurfaceSession对象与C++层的SurfaceComposerClient对象之间是一对一关系。是否似曾相识，就是前面最开始SurfaceFlinger_Test程序第一步：new SurfaceComposerClient的过程。[SurfaceComposerClient.cpp] 12345678910111213SurfaceComposerClient::SurfaceComposerClient(): mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;void SurfaceComposerClient::onFirstRef() &#123;//得到SurfaceFlinger的代理对象BpSurfaceComposer sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService());if (sm != 0) &#123; sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection(); if (conn != 0) &#123; mClient = conn; mStatus = NO_ERROR; &#125;&#125;&#125; SurfaceComposerClient继承于RefBase类，当第一次被强引用时，onFirstRef函数被回调，在该函数中SurfaceComposerClient会请求SurfaceFlinger为当前应用程序创建一个Client对象，专门接收该应用程序的请求，在SurfaceFlinger端创建好Client本地Binder对象后，将该Binder代理对象返回给应用程序端，并保存在SurfaceComposerClient的成员变量mClient中。 服务端处理在SurfaceFlinger服务端为应用程序创建交互的Client对象[SurfaceFlinger.cpp] 12345678910sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()&#123;sp&lt;ISurfaceComposerClient&gt; bclient;sp&lt;Client&gt; client(new Client(this));status_t err = client-&gt;initCheck();if (err == NO_ERROR) &#123; bclient = client;&#125;return bclient;&#125; 4.2.3、App（C++层）请求创建SurfaceFlinger客户端(client)的过程 继续详细分析AppApp（C++层）请求创建SurfaceFlinger客户端(client)的过程 SurfaceComposerClient第一次强引用时，会执行onFirstRef()[SurfaceComposerClient.cpp] 12345678910111213SurfaceComposerClient::SurfaceComposerClient(): mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;void SurfaceComposerClient::onFirstRef() &#123;//得到SurfaceFlinger的代理对象BpSurfaceComposer sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService());if (sm != 0) &#123; sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection(); if (conn != 0) &#123; mClient = conn; mStatus = NO_ERROR; &#125;&#125;&#125; 第一步：获取”SurfaceFlinger”服务ComposerService::getComposerService()12345678910/*static*/ sp&lt;ISurfaceComposer&gt; ComposerService::getComposerService() &#123; ComposerService&amp; instance = ComposerService::getInstance(); Mutex::Autolock _l(instance.mLock); if (instance.mComposerService == NULL) &#123; ComposerService::getInstance().connectLocked(); assert(instance.mComposerService != NULL); ALOGD(\"ComposerService reconnected\"); &#125; return instance.mComposerService;&#125; ComposerService::getInstance()会调用connectLocked()获取”SurfaceFlinger”服务。12345678910111213ComposerService::ComposerService(): Singleton&lt;ComposerService&gt;() &#123; Mutex::Autolock _l(mLock); connectLocked();&#125;void ComposerService::connectLocked() &#123; const String16 name(&quot;SurfaceFlinger&quot;); while (getService(name, &amp;mComposerService) != NO_ERROR) &#123; usleep(250000); &#125; ......&#125; 所以前面instance.mComposerService其实返回的是”SurfaceFlinger”服务。第二步：createConnection()接下来就会调用”SurfaceFlinger”服务的createConnection() 12345678910sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()&#123; sp&lt;ISurfaceComposerClient&gt; bclient; sp&lt;Client&gt; client(new Client(this)); status_t err = client-&gt;initCheck(); if (err == NO_ERROR) &#123; bclient = client; &#125; return bclient;&#125; 4.2.4、APP申请创建Surface过程前面讲ViewRootImpl.setView时，requestLayout()需要Vsync trigger，加入现在Vsync信号来到，于是会继续执行。App申请创建Surface的过程就在其中。 当Vsync事件到来时，就会通过Choreographer的postCallback()，接着执行mTraversalRunnable对象的run()方法。mTraversalRunnable对象的类型为TraversalRunnable，该类实现了Runnable接口，在其run()函数中调用了doTraversal()函数来完成窗口布局。[-&gt;ViewRootImpl.java] 12345678910111213141516final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable();void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); ...... performTraversals(); ...... &#125;&#125; performTraversals函数相当复杂，其主要实现以下几个重要步骤： 1.执行窗口测量； 2.执行窗口注册； 3.执行窗口布局； 4.执行窗口绘图； [-&gt;ViewRootImpl.java] 12345678910111213141516171819202122232425262728293031 private void performTraversals() &#123; ...... /****************执行窗口测量******************/ if (layoutRequested) &#123; windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight); &#125; ...... /****************向WMS服务添加窗口******************/ if (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != null || mForceNextWindowRelayout) &#123; ...... try &#123; ...... relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); ...... &#125; ...... &#125; /****************执行窗口布局******************/ if (didLayout) &#123; performLayout(lp, mWidth, mHeight); ...... &#125; /****************执行窗口绘制******************/ if (!cancelDraw &amp;&amp; !newSurface) &#123; ...... performDraw(); &#125; ......&#125; 1、执行窗口测量performMeasure()[-&gt;ViewRootImpl.java] 123456 private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; ......&#125; 4.2.4.1、APP申请创建Surface过程(Java层)2、执行窗口注册relayoutWindow；[-&gt;ViewRootImpl.java] 12345678910111213141516 private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending) throws RemoteException &#123; ...... int relayoutResult = mWindowSession.relayout( mWindow, mSeq, params, (int) (mView.getMeasuredWidth() * appScale + 0.5f), (int) (mView.getMeasuredHeight() * appScale + 0.5f), viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0, mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets, mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration, mSurface); ...... return relayoutResult;&#125; 这里通过前面获取的IWindowSession代理对象请求WMS服务执行窗口布局，mSurface是ViewRootImpl的成员变量[-&gt;ViewRootImpl.java] 1final Surface mSurface = new Surface(); [-&gt;Surface.java] 123456/** * Create an empty surface, which will later be filled in by readFromParcel(). * @hide */public Surface() &#123;&#125; 该Surface构造函数仅仅创建了一个空Surface对象，并没有对该Surface进程native层的初始化，到此我们知道应用程序进程为每个窗口对象都创建了一个Surface对象。并且将该Surface通过跨进程方式传输给WMS服务进程，我们知道，在Android系统中，如果一个对象需要在不同进程间传输，必须实现Parcelable接口，Surface类正好实现了Parcelable接口。ViewRootImpl通过IWindowSession接口请求WMS的完整过程如下：[-&gt;IWindowSession.java$ Proxy] 123456789101112131415161718192021/** This file is auto-generated. DO NOT MODIFY* * Original file: frameworks/base/core/java/android/view/IWindowSession.aidl*/@Override public int relayout(android.view.IWindow window, int seq, android.view.WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, android.graphics.Rect outFrame, android.graphics.Rect outOverscanInsets, android.graphics.Rect outContentInsets, android.graphics.Rect outVisibleInsets, android.graphics.Rect outStableInsets, android.graphics.Rect outOutsets, android.graphics.Rect outBackdropFrame, android.content.res.Configuration outConfig, android.view.Surface outSurface) throws android.os.RemoteException &#123;android.os.Parcel _data = android.os.Parcel.obtain();android.os.Parcel _reply = android.os.Parcel.obtain();int _result;try &#123; ...... mRemote.transact(Stub.TRANSACTION_relayout, _data, _reply, 0); ...... if ((0 != _reply.readInt())) &#123; outSurface.readFromParcel(_reply); &#125;&#125; finally &#123; ......&#125;return _result;&#125; 从该函数的实现可以看出，应用程序进程中创建的Surface对象并没有传递到WMS服务进程，只是读取WMS服务进程返回来的Surface。那么WMS服务进程是如何响应应用程序进程布局请求的呢？ [-&gt;IWindowSession.java$ Stub]1234567891011121314151617181920@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException&#123;switch (code)&#123;case TRANSACTION_relayout: &#123; ...... android.view.Surface _arg15; _arg15 = new android.view.Surface(); int _result = this.relayout(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13, _arg14, _arg15); reply.writeNoException(); reply.writeInt(_result); ...... if ((_arg15!=null)) &#123; reply.writeInt(1); _arg15.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; return true; &#125;&#125; 该函数可以看出，WMS服务在响应应用程序进程请求添加窗口时，首先在当前进程空间创建一个Surface对象 12android.view.Surface _arg15;_arg15 = new android.view.Surface(); 然后调用Session的relayout()函数进一步完成窗口添加过程，最后将WMS服务中创建的Surface返回给应用程序进程。 到目前为止，在应用程序进程和WMS服务进程分别创建了一个Surface对象，但是他们调用的都是Surface的无参构造函数，在该构造函数中并未真正初始化native层的Surface，那native层的Surface是在那里创建的呢？[-&gt;Session.java] 1234567891011 public int relayout(IWindow window, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewFlags, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame, Configuration outConfig, Surface outSurface) &#123; int res = mService.relayoutWindow(this, window, seq, attrs, requestedWidth, requestedHeight, viewFlags, flags, outFrame, outOverscanInsets, outContentInsets, outVisibleInsets, outStableInsets, outsets, outBackdropFrame, outConfig, outSurface); return res;&#125; [-&gt;WindowManagerService.java] 1234567891011121314151617181920212223242526 public int relayoutWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame, Configuration outConfig, Surface outSurface) &#123; int result = 0; ...... if (viewVisibility == View.VISIBLE &amp;&amp; (win.mAppToken == null || !win.mAppToken.clientHidden)) &#123; result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges, oldVisibility); try &#123; result = createSurfaceControl(outSurface, result, win, winAnimator); &#125; catch (Exception e) &#123; ...... return 0; &#125; ...... &#125; else &#123; ...... &#125; ...... return result;&#125; [-&gt;WindowManagerService.java]12345678910111213 private int createSurfaceControl(Surface outSurface, int result, WindowState win, WindowStateAnimator winAnimator) &#123; if (!win.mHasSurface) &#123; result |= RELAYOUT_RES_SURFACE_CHANGED; &#125; WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked(); if (surfaceController != null) &#123; surfaceController.getSurface(outSurface); &#125; else &#123; outSurface.release(); &#125; return result;&#125; [-&gt;WindowSurfaceController.java] 123 void getSurface(Surface outSurface) &#123; outSurface.copyFrom(mSurfaceControl);&#125; [-&gt;WindowStateAnimator.java] 123456789101112 WindowSurfaceController createSurfaceLocked() &#123; ...... try &#123; ...... mSurfaceController = new WindowSurfaceController(mSession.mSurfaceSession, attrs.getTitle().toString(), width, height, format, flags, this); w.setHasSurface(true); &#125; ...... return mSurfaceController;&#125; [-&gt;WindowSurfaceController.java] 123456789101112131415public WindowSurfaceController(SurfaceSession s, String name, int w, int h, int format, int flags, WindowStateAnimator animator) &#123; mAnimator = animator; mSurfaceW = w; mSurfaceH = h; ...... if (animator.mWin.isChildWindow() &amp;&amp; animator.mWin.mSubLayer &lt; 0 &amp;&amp; animator.mWin.mAppToken != null) &#123; ...... &#125; else &#123; mSurfaceControl = new SurfaceControl( s, name, w, h, format, flags); &#125;&#125; 4.2.4.1、APP申请创建Surface过程(C++层)SurfaceControl创建过程[-&gt;SurfaceControl.java] 1234567 public SurfaceControl(SurfaceSession session, String name, int w, int h, int format, int flags) throws OutOfResourcesException &#123; ...... mNativeObject = nativeCreate(session, name, w, h, format, flags); ......&#125; [-&gt;android_view_SurfaceControl.cpp] 12345678910111213static jlong nativeCreate(JNIEnv* env, jclass clazz, jobject sessionObj, jstring nameStr, jint w, jint h, jint format, jint flags) &#123;ScopedUtfChars name(env, nameStr);sp&lt;SurfaceComposerClient&gt; client(android_view_SurfaceSession_getClient(env, sessionObj));sp&lt;SurfaceControl&gt; surface = client-&gt;createSurface( String8(name.c_str()), w, h, format, flags);if (surface == NULL) &#123; jniThrowException(env, OutOfResourcesException, NULL); return 0;&#125;surface-&gt;incStrong((void *)nativeCreate);return reinterpret_cast&lt;jlong&gt;(surface.get());&#125; 该函数首先得到前面创建好的SurfaceComposerClient对象，通过该对象向SurfaceFlinger端的Client对象发送创建Surface的请求，最后得到一个SurfaceControl对象。 [-&gt;SurfaceComposerClient.cpp] 1234567891011121314151617181920sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags) &#123;sp&lt;SurfaceControl&gt; sur;if (mStatus == NO_ERROR) &#123; sp&lt;IBinder&gt; handle; sp&lt;IGraphicBufferProducer&gt; gbp; status_t err = mClient-&gt;createSurface(name, w, h, format, flags, &amp;handle, &amp;gbp); ALOGE_IF(err, \"SurfaceComposerClient::createSurface error %s\", strerror(-err)); if (err == NO_ERROR) &#123; sur = new SurfaceControl(this, handle, gbp); &#125;&#125;return sur;&#125; SurfaceComposerClient将Surface创建请求转交给保存在其成员变量中的Bp SurfaceComposerClient对象来完成，在SurfaceFlinger端的Client本地对象会返回一个ISurface代理对象给应用程序，通过该代理对象为应用程序当前创建的Surface创建一个SurfaceControl对象。[ISurfaceComposerClient.cpp] 1234567891011 virtual status_t createSurface(const String8&amp; name, uint32_t width, uint32_t height, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) &#123; Parcel data, reply; ...... remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply); *handle = reply.readStrongBinder(); *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder()); return reply.readInt32();&#125; [Client.cpp]MessageCreateSurface消息是专门为应用程序请求创建Surface而定义的一种消息类型： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 status_t Client::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123; /* * createSurface must be called from the GL thread so that it can * have access to the GL context. */ class MessageCreateLayer : public MessageBase &#123; SurfaceFlinger* flinger; Client* client; sp&lt;IBinder&gt;* handle; sp&lt;IGraphicBufferProducer&gt;* gbp; status_t result; const String8&amp; name; uint32_t w, h; PixelFormat format; uint32_t flags; public: MessageCreateLayer(SurfaceFlinger* flinger, const String8&amp; name, Client* client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) : flinger(flinger), client(client), handle(handle), gbp(gbp), result(NO_ERROR), name(name), w(w), h(h), format(format), flags(flags) &#123; &#125; status_t getResult() const &#123; return result; &#125; virtual bool handler() &#123; result = flinger-&gt;createLayer(name, client, w, h, format, flags, handle, gbp); return true; &#125; &#125;; sp&lt;MessageBase&gt; msg = new MessageCreateLayer(mFlinger.get(), name, this, w, h, format, flags, handle, gbp); mFlinger-&gt;postMessageSync(msg); return static_cast&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult(); &#125;Client将应用程序创建Surface的请求转换为异步消息投递到SurfaceFlinger的消息队列中，将创建Surface的任务转交给SurfaceFlinger。[-&gt;SurfaceFlinger.cpp] status_t SurfaceFlinger::createLayer( const String8&amp; name, const sp&lt;Client&gt;&amp; client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123; //ALOGD(\"createLayer for (%d x %d), name=%s\", w, h, name.string()); ...... status_t result = NO_ERROR; sp&lt;Layer&gt; layer; ////根据flags创建不同类型的layer switch (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123; case ISurfaceComposerClient::eFXSurfaceNormal: result = createNormalLayer(client, name, w, h, flags, format, handle, gbp, &amp;layer); break; case ISurfaceComposerClient::eFXSurfaceDim: result = createDimLayer(client, name, w, h, flags, handle, gbp, &amp;layer); break; default: result = BAD_VALUE; break; &#125; if (result != NO_ERROR) &#123; return result; &#125; //将创建好的Layer对象保存在Client中 result = addClientLayer(client, *handle, *gbp, layer); if (result != NO_ERROR) &#123; return result; &#125; setTransactionFlags(eTransactionNeeded); return result; &#125; SurfaceFlinger根据标志位创建对应类型的Surface，当前系统定义了3种类型的Layer: [-&gt;ISurfaceComposerClient.h] 123eFXSurfaceNormal = 0x00000000,eFXSurfaceDim = 0x00020000,eFXSurfaceMask = 0x000F0000 [-&gt;SurfaceFlinger.cpp] 123456789101112131415161718192021222324status_t SurfaceFlinger::createNormalLayer(const sp&lt;Client&gt;&amp; client, const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat&amp; format, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)&#123;// initialize the surfacesswitch (format) &#123;case PIXEL_FORMAT_TRANSPARENT:case PIXEL_FORMAT_TRANSLUCENT: format = PIXEL_FORMAT_RGBA_8888; break;case PIXEL_FORMAT_OPAQUE: format = PIXEL_FORMAT_RGBX_8888; break;&#125;//在SurfaceFlinger端为应用程序的Surface创建对应的Layer对象 *outLayer = new Layer(this, client, name, w, h, flags);status_t err = (*outLayer)-&gt;setBuffers(w, h, format, flags);if (err == NO_ERROR) &#123; *handle = (*outLayer)-&gt;getHandle(); *gbp = (*outLayer)-&gt;getProducer();&#125;ALOGE_IF(err, \"createNormalLayer() failed (%s)\", strerror(-err));return err;&#125; 在SurfaceFlinger服务端为应用程序创建的Surface创建对应的Layer对象。应用程序请求创建Surface过程如下：第一次强引用Layer对象时，onFirstRef()函数被回调[Layer.cpp] 123456789101112131415161718192021void Layer::onFirstRef() &#123;// Creates a custom BufferQueue for SurfaceFlingerConsumer to usesp&lt;IGraphicBufferProducer&gt; producer;sp&lt;IGraphicBufferConsumer&gt; consumer;//创建BufferQueue对象BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);mProducer = new MonitoredProducer(producer, mFlinger);mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName, this);mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(0));mSurfaceFlingerConsumer-&gt;setContentsChangedListener(this);mSurfaceFlingerConsumer-&gt;setName(mName);#ifdef TARGET_DISABLE_TRIPLE_BUFFERING#warning \"disabling triple buffering\"#elsemProducer-&gt;setMaxDequeuedBufferCount(2);#endifconst sp&lt;const DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());updateTransformHint(hw);&#125; 根据buffer可用监听器的注册过程，我们知道，当生产者也就是应用程序填充好图形buffer数据后，通过回调方式通知消费者的 4.2.4.2、BufferQueue构造过程[-&gt;BufferQueue.cpp] 1234567891011void BufferQueue::createBufferQueue(sp&lt;IGraphicBufferProducer&gt;* outProducer, sp&lt;IGraphicBufferConsumer&gt;* outConsumer, const sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) &#123;......sp&lt;BufferQueueCore&gt; core(new BufferQueueCore(allocator));sp&lt;IGraphicBufferProducer&gt; producer(new BufferQueueProducer(core));sp&lt;IGraphicBufferConsumer&gt; consumer(new BufferQueueConsumer(core));*outProducer = producer;*outConsumer = consumer;&#125; [-&gt;BufferQueueCore.cpp]所以核心都是这个BufferQueueCore，他是管理图形缓冲区的中枢。 123456789101112131415161718192021BufferQueueCore::BufferQueueCore(const sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) :mAllocator(allocator),......&#123;if (allocator == NULL) &#123; sp&lt;ISurfaceComposer&gt; composer(ComposerService::getComposerService()); mAllocator = composer-&gt;createGraphicBufferAlloc(); if (mAllocator == NULL) &#123; BQ_LOGE(\"createGraphicBufferAlloc failed\"); &#125;&#125;int numStartingBuffers = getMaxBufferCountLocked();for (int s = 0; s &lt; numStartingBuffers; s++) &#123; mFreeSlots.insert(s);&#125;for (int s = numStartingBuffers; s &lt; BufferQueueDefs::NUM_BUFFER_SLOTS; s++) &#123; mUnusedSlots.push_front(s);&#125;&#125; BufferQueueCore类中定义了一个64项的数据mSlots，是一个容量大小为64的数组，因此BufferQueueCore可以管理最多64块的GraphicBuffer。 [-&gt;ISurfaceComposer.cpp] 1234567 virtual sp&lt;IGraphicBufferAlloc&gt; createGraphicBufferAlloc()&#123; Parcel data, reply; data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor()); remote()-&gt;transact(BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, data, &amp;reply); return interface_cast&lt;IGraphicBufferAlloc&gt;(reply.readStrongBinder());&#125; [-&gt;SurfaceFlinger.cpp] 12345sp&lt;IGraphicBufferAlloc&gt; SurfaceFlinger::createGraphicBufferAlloc()&#123;sp&lt;GraphicBufferAlloc&gt; gba(new GraphicBufferAlloc());return gba;&#125; GraphicBufferAlloc构造过程 [-&gt;GraphicBufferAlloc.cpp] 123456789sp&lt;GraphicBuffer&gt; GraphicBufferAlloc::createGraphicBuffer(uint32_t width, uint32_t height, PixelFormat format, uint32_t usage, std::string requestorName, status_t* error) &#123;sp&lt;GraphicBuffer&gt; graphicBuffer(new GraphicBuffer( width, height, format, usage, std::move(requestorName)));status_t err = graphicBuffer-&gt;initCheck();......return graphicBuffer;&#125; 图形缓冲区创建过程[-&gt;GraphicBuffer.cpp] 1234567891011121314GraphicBuffer::GraphicBuffer(uint32_t inWidth, uint32_t inHeight, PixelFormat inFormat, uint32_t inUsage, std::string requestorName): BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()), mInitCheck(NO_ERROR), mId(getUniqueId()), mGenerationNumber(0) &#123;width =height =stride =format =usage = 0;handle = NULL;mInitCheck = initSize(inWidth, inHeight, inFormat, inUsage, std::move(requestorName)); &#125; 根据图形buffer的宽高、格式等信息为图形缓冲区分配存储空间。 使用GraphicBufferAllocator对象来为图形缓冲区分配内存空间，GraphicBufferAllocator是对Gralloc模块中的gpu设备的封装类。关于GraphicBufferAllocator内存分配过程请以后作分析，图形缓冲区分配完成后，还会映射到SurfaceFlinger服务进程的虚拟地址空间。 Android图形缓冲区分配过程源码分析 [-&gt;Layer.cpp] 123456789101112131415Layer::Layer(SurfaceFlinger* flinger, const sp&lt;Client&gt;&amp; client, const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags): contentDirty(false), sequence(uint32_t(android_atomic_inc(&amp;sSequence))), mFlinger(flinger), mTextureName(-1U), mPremultipliedAlpha(true), mName(\"unnamed\"), mFormat(PIXEL_FORMAT_NONE), ......&#123;mCurrentCrop.makeInvalid();mFlinger-&gt;getRenderEngine().genTextures(1, &amp;mTextureName);mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);......&#125; 到此才算真正创建了一个可用于绘图的Surface (Layer)，从上面的分析我们可以看出，在WMS服务进程端，其实创建了两个Java层的Surface对象，第一个Surface使用了无参构造函数，仅仅构造一个Surface对象而已，而第二个Surface却使用了有参构造函数，参数指定了图象宽高等信息，这个Java层Surface对象还会在native层请求SurfaceFlinger创建一个真正能用于绘制图象的native层Surface。最后通过浅拷贝的方式将第二个Surface复制到第一个Surface中，最后通过writeToParcel方式写回到应用程序进程。 到目前为止，应用程序和WMS一共创建了3个Java层Surface（SurfaceControl）对象，如上图所示，而真正能用于绘图的Surface只有3号，那么3号Surface与2号Surface之间是什么关系呢？outSurface.copyFrom(surface) [Surface.java] 12345678910111213 public void copyFrom(SurfaceControl other) &#123; ...... long surfaceControlPtr = other.mNativeObject; ...... long newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr); synchronized (mLock) &#123; if (mNativeObject != 0) &#123; nativeRelease(mNativeObject); &#125; setNativeObjectLocked(newNativeObject); &#125;&#125; [android_view_Surface.cpp] 123456789101112131415static jlong nativeCreateFromSurfaceControl(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj) &#123;/* * This is used by the WindowManagerService just after constructing * a Surface and is necessary for returning the Surface reference to * the caller. At this point, we should only have a SurfaceControl. */sp&lt;SurfaceControl&gt; ctrl(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj));sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());if (surface != NULL) &#123; surface-&gt;incStrong(&amp;sRefBaseOwner);&#125;return reinterpret_cast&lt;jlong&gt;(surface.get());&#125; 2号Surface引用到了3号Surface的SurfaceControl对象后，通过writeToParcel()函数写会到应用程序进程。[Surface.java] 12345678910111213141516 @Overridepublic void writeToParcel(Parcel dest, int flags) &#123; if (dest == null) &#123; throw new IllegalArgumentException(\"dest must not be null\"); &#125; synchronized (mLock) &#123; // NOTE: This must be kept synchronized with the native parceling code // in frameworks/native/libs/Surface.cpp dest.writeString(mName); dest.writeInt(mIsSingleBuffered ? 1 : 0); nativeWriteToParcel(mNativeObject, dest); &#125; if ((flags &amp; Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) &#123; release(); &#125;&#125; [android_view_Surface.cpp] 12345678910111213141516static void nativeWriteToParcel(JNIEnv* env, jclass clazz, jlong nativeObject, jobject parcelObj) &#123;Parcel* parcel = parcelForJavaObject(env, parcelObj);if (parcel == NULL) &#123; doThrowNPE(env); return;&#125;sp&lt;Surface&gt; self(reinterpret_cast&lt;Surface *&gt;(nativeObject));android::view::Surface surfaceShim;if (self != nullptr) &#123; surfaceShim.graphicBufferProducer = self-&gt;getIGraphicBufferProducer();&#125;// Calling code in Surface.java has already written the name of the Surface// to the ParcelsurfaceShim.writeToParcel(parcel, /*nameAlreadyWritten*/true);&#125; 应用程序进程中的1号Surface按相反顺序读取WMS服务端返回过来的Binder对象等数据，并构造一个native层的Surface对象。 1234567891011121314151617 public void readFromParcel(Parcel source) &#123; if (source == null) &#123; throw new IllegalArgumentException(\"source must not be null\"); &#125; synchronized (mLock) &#123; // nativeReadFromParcel() will either return mNativeObject, or // create a new native Surface and return it after reducing // the reference count on mNativeObject. Either way, it is // not necessary to call nativeRelease() here. // NOTE: This must be kept synchronized with the native parceling code // in frameworks/native/libs/Surface.cpp mName = source.readString(); mIsSingleBuffered = source.readInt() != 0; setNativeObjectLocked(nativeReadFromParcel(mNativeObject, source)); &#125;&#125; 应用程序进程中的1号Surface按相反顺序读取WMS服务端返回过来的Binder对象等数据，并构造一个native层的Surface对象。 123456789101112131415static jlong nativeCreateFromSurfaceControl(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj) &#123;/* * This is used by the WindowManagerService just after constructing * a Surface and is necessary for returning the Surface reference to * the caller. At this point, we should only have a SurfaceControl. */sp&lt;SurfaceControl&gt; ctrl(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj));sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());if (surface != NULL) &#123; surface-&gt;incStrong(&amp;sRefBaseOwner);&#125;return reinterpret_cast&lt;jlong&gt;(surface.get());&#125; 每个Activity可以有一个或多个Surface，默认情况下一个Activity只有一个Surface，当Activity中使用SurfaceView时，就存在多个Surface。Activity默认surface是在relayoutWindow过程中由WMS服务创建的，然后回传给应用程序进程，我们知道一个Surface其实就是应用程序端的本地窗口，关于Surface的初始化过程这里就不在介绍。 4.2.4.2、生产者Producer构造过程12sp&lt;IGraphicBufferProducer&gt; producer(new BufferQueueProducer(core));sp&lt;IGraphicBufferConsumer&gt; consumer(new BufferQueueConsumer(core)); 实例化BufferQueueProducer，这里初始化了mCore(core) 和 mSlots(core-&gt;mSlots)1234567891011BufferQueueProducer::BufferQueueProducer(const sp&lt;BufferQueueCore&gt;&amp; core) : mCore(core), mSlots(core-&gt;mSlots), mConsumerName(), mStickyTransform(0), mLastQueueBufferFence(Fence::NO_FENCE), mCallbackMutex(), mNextCallbackTicket(0), mCurrentCallbackTicket(0), mCallbackCondition(), mDequeueTimeout(-1) &#123;&#125; 4.2.4.3、消费者Consumer构造过程12sp&lt;IGraphicBufferProducer&gt; producer(new BufferQueueProducer(core));sp&lt;IGraphicBufferConsumer&gt; consumer(new BufferQueueConsumer(core)); 实例化BufferQueueConsumer，这里初始化了mCore(core) 和 mSlots(core-&gt;mSlots)1234BufferQueueConsumer::BufferQueueConsumer(const sp&lt;BufferQueueCore&gt;&amp; core) : mCore(core), mSlots(core-&gt;mSlots), mConsumerName() &#123;&#125; 4.2.4.4、SurfaceFlinger设置监听12345mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName, this);mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(0));mSurfaceFlingerConsumer-&gt;setContentsChangedListener(this);mSurfaceFlingerConsumer-&gt;setName(mName); 4.2.4.5、应用程序本地窗口Surface创建过程从前面分析可知，SurfaceFlinger在处理应用程序请求创建Surface中，在SurfaceFlinger服务端仅仅创建了Layer对象，那么应用程序本地窗口Surface在什么时候、什么地方创建呢？ 为应用程序创建好了Layer对象并返回ISurface的代理对象给应用程序，应用程序通过该代理对象创建了一个SurfaceControl对象，Java层Surface需要通过android_view_Surface.cpp中的JNI函数来操作native层的Surface，在操作native层Surface前，首先需要获取到native的Surface，应用程序本地窗口Surface就是在这个时候创建的。[-&gt;SurfaceControl.cpp] 12345678910sp&lt;Surface&gt; SurfaceControl::getSurface() const&#123;Mutex::Autolock _l(mLock);if (mSurfaceData == 0) &#123; // This surface is always consumed by SurfaceFlinger, so the // producerControlledByApp value doesn't matter; using false. mSurfaceData = new Surface(mGraphicBufferProducer, false);&#125;return mSurfaceData;&#125; [Surface.cpp] 1234567891011121314151617181920212223242526272829303132333435Surface::Surface( const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer, bool controlledByApp): mGraphicBufferProducer(bufferProducer), mCrop(Rect::EMPTY_RECT), mGenerationNumber(0), mSharedBufferMode(false), mAutoRefresh(false), mSharedBufferSlot(BufferItem::INVALID_BUFFER_SLOT), mSharedBufferHasBeenQueued(false), mNextFrameNumber(1) &#123;// Initialize the ANativeWindow function pointers.ANativeWindow::setSwapInterval = hook_setSwapInterval;ANativeWindow::dequeueBuffer = hook_dequeueBuffer;ANativeWindow::cancelBuffer = hook_cancelBuffer;ANativeWindow::queueBuffer = hook_queueBuffer;ANativeWindow::query = hook_query;ANativeWindow::perform = hook_perform;ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;ANativeWindow::cancelBuffer_DEPRECATED = hook_cancelBuffer_DEPRECATED;ANativeWindow::lockBuffer_DEPRECATED = hook_lockBuffer_DEPRECATED;ANativeWindow::queueBuffer_DEPRECATED = hook_queueBuffer_DEPRECATED;const_cast&lt;int&amp;&gt;(ANativeWindow::minSwapInterval) = 0;const_cast&lt;int&amp;&gt;(ANativeWindow::maxSwapInterval) = 1;mReqWidth = 0;mReqHeight = 0;mReqFormat = 0;mReqUsage = 0;......mSwapIntervalZero = false;&#125; 在创建完应用程序本地窗口Surface后，想要在该Surface上绘图，首先需要为该Surface分配图形buffer。我们前面介绍了Android应用程序图形缓冲区的分配都是由SurfaceFlinger服务进程来完成，在请求创建Surface时，在服务端创建了一个BufferQueue本地Binder对象，该对象负责管理应用程序一个本地窗口Surface的图形缓冲区。 4.2.4.5、执行窗口布局performLayout() [-&gt;ViewRootImpl.java] 1234567891011121314151617181920 private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; mLayoutRequested = false; mScrollMayChange = true; mInLayout = true; final View host = mView; try &#123; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mInLayout = false; int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) &#123; ...... measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); mInLayout = true; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); ...... &#125; mInLayout = false;&#125; 4.2.4.7、执行窗口绘制performDraw()12345678[-&gt;ViewRootImpl.java]private void performDraw() &#123; ...... try &#123; draw(fullRedrawNeeded); &#125; ...... &#125; &#125; Android是怎样将View画出来的？由于之前我们已经关闭了HWC、GPU、HWUI，这里只关注软件绘制。 [-&gt;ViewRootImpl.java] 123456789101112131415 private void draw(boolean fullRedrawNeeded) &#123; Surface surface = mSurface; ...... if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123; if (mAttachInfo.mHardwareRenderer != null &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123; ...... &#125; else &#123; ...... if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123; return; &#125; &#125; &#125; .....&#125; 关于渲染这个流程很复杂，我们后续章节再分析。 4.3、APP申请(lock)Buffer的过程 1234567891011121314151617181920212223242526272829303132 private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. final Canvas canvas; try &#123; ...... canvas = mSurface.lockCanvas(dirty); ...... &#125; ...... try &#123; canvas.translate(-xoff, -yoff); if (mTranslator != null) &#123; mTranslator.translateCanvas(canvas); &#125; canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0); attachInfo.mSetIgnoreDirtyState = false; mView.draw(canvas); drawAccessibilityFocusedDrawableIfNeeded(canvas); &#125;...... &#125; finally &#123; try &#123; surface.unlockCanvasAndPost(canvas); &#125; catch (IllegalArgumentException e) &#123; ...... return false; &#125; &#125; return true;&#125; 先看看Surface的lockCanvas方法：[-&gt;Surface.java] 1234567891011//mCanvas 变量直接赋值private final Canvas mCanvas = new CompatibleCanvas();public Canvas lockCanvas(Rect inOutDirty) throws Surface.OutOfResourcesException, IllegalArgumentException &#123;synchronized (mLock) &#123; checkNotReleasedLocked(); ...... mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty); return mCanvas;&#125;&#125; [-&gt;android_view_Surface.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static jlong nativeLockCanvas(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj, jobject dirtyRectObj) &#123; //获取java层的Surface保存的long型句柄sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject));if (!isSurfaceValid(surface)) &#123; doThrowIAE(env); return 0;&#125;Rect dirtyRect(Rect::EMPTY_RECT);Rect* dirtyRectPtr = NULL;//获取java层dirty Rect的位置大小信息if (dirtyRectObj) &#123; dirtyRect.left = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left); dirtyRect.top = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top); dirtyRect.right = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right); dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom); dirtyRectPtr = &amp;dirtyRect;&#125;ANativeWindow_Buffer outBuffer; //调用Surface的lock方法,将申请的图形缓冲区赋给outBufferstatus_t err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);......SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height, convertPixelFormat(outBuffer.format), outBuffer.format == PIXEL_FORMAT_RGBX_8888 ? kOpaque_SkAlphaType : kPremul_SkAlphaType);SkBitmap bitmap;//创建一个SkBitmap //图形缓冲区每一行像素大小ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);bitmap.setInfo(info, bpr);if (outBuffer.width &gt; 0 &amp;&amp; outBuffer.height &gt; 0) &#123; bitmap.setPixels(outBuffer.bits);&#125; else &#123; // be safe with an empty bitmap. bitmap.setPixels(NULL);&#125;Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);nativeCanvas-&gt;setBitmap(bitmap);if (dirtyRectPtr) &#123; nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top, dirtyRect.right, dirtyRect.bottom);&#125;if (dirtyRectObj) &#123; env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left, dirtyRect.left); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top, dirtyRect.top); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right, dirtyRect.right); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);&#125;......sp&lt;Surface&gt; lockedSurface(surface);lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);return (jlong) lockedSurface.get();&#125; 这段代码逻辑主要如下： 1）获取java层dirty 的Rect大小和位置信息； 2）调用Surface的lock方法,将申请的图形缓冲区赋给outBuffer； 3）创建一个Skbitmap，填充它用来保存申请的图形缓冲区，并赋值给Java层的Canvas对象； 4）将剪裁位置大小信息赋给java层Canvas对象。 4.3.1、Surface管理图形缓冲区-APP申请(lock)Buffer的过程我们上边分析到了申请图形缓冲区，用到了Surface的lock函数，我们继续查看。[-&gt;Surface.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384status_t Surface::lock( ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds) &#123;......ANativeWindowBuffer* out;int fenceFd = -1;//调用dequeueBuffer函数，申请图形缓冲区status_t err = dequeueBuffer(&amp;out, &amp;fenceFd);ALOGE_IF(err, \"dequeueBuffer failed (%s)\", strerror(-err));if (err == NO_ERROR) &#123; //获取图形缓冲区区域大小,赋给后备缓冲区变量backBuffer sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out)); const Rect bounds(backBuffer-&gt;width, backBuffer-&gt;height); Region newDirtyRegion; if (inOutDirtyBounds) &#123; //如果上层指定乐刷新脏矩形区域，则用这个区域和缓冲区区域求交集， //然后将交集的结果设给需要去刷新的新区域 newDirtyRegion.set(static_cast&lt;Rect const&amp;&gt;(*inOutDirtyBounds)); newDirtyRegion.andSelf(bounds); &#125; else &#123; /如果上层没有指定脏矩形区域，所以刷新整个图形缓冲区 newDirtyRegion.set(bounds); &#125; // figure out if we can copy the frontbuffer back //上一次绘制的信息保存在mPostedBuffer中，而这个mPostedBuffer则要在unLockAndPost函数中设置 int backBufferSlot(getSlotFromBufferLocked(backBuffer.get())); const sp&lt;GraphicBuffer&gt;&amp; frontBuffer(mPostedBuffer); const bool canCopyBack = (frontBuffer != 0 &amp;&amp; backBuffer-&gt;width == frontBuffer-&gt;width &amp;&amp; backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp; backBuffer-&gt;format == frontBuffer-&gt;format); if (canCopyBack) &#123; Mutex::Autolock lock(mMutex); Region oldDirtyRegion; if(mSlots[backBufferSlot].dirtyRegion.isEmpty()) &#123; oldDirtyRegion.set(bounds); &#125; else &#123; for(int i = 0 ; i &lt; NUM_BUFFER_SLOTS; i++ ) &#123; if(i != backBufferSlot &amp;&amp; !mSlots[i].dirtyRegion.isEmpty()) oldDirtyRegion.orSelf(mSlots[i].dirtyRegion); &#125; &#125; const Region copyback(oldDirtyRegion.subtract(newDirtyRegion)); if (!copyback.isEmpty()) //这里把mPostedBuffer中的旧数据拷贝到BackBuffer中。 //后续的绘画只要更新脏区域就可以了，这会节约不少资源 copyBlt(backBuffer, frontBuffer, copyback); &#125; else &#123; // if we can't copy-back anything, modify the user's dirty // region to make sure they redraw the whole buffer //如果两次图形缓冲区大小不一致，我们就要修改用户指定的dirty区域大小为整个缓冲区大小， //然后去更新整个缓冲区 newDirtyRegion.set(bounds); Mutex::Autolock lock(mMutex); for (size_t i=0 ; i&lt;NUM_BUFFER_SLOTS ; i++) &#123; mSlots[i].dirtyRegion.clear(); &#125; &#125; &#123; // scope for the lock Mutex::Autolock lock(mMutex); //将新的dirty赋给这个bufferslot mSlots[backBufferSlot].dirtyRegion = newDirtyRegion; &#125; if (inOutDirtyBounds) &#123; *inOutDirtyBounds = newDirtyRegion.getBounds(); &#125; void* vaddr; //lock和unlock分别用来锁定和解锁一个指定的图形缓冲区，在访问一块图形缓冲区的时候， //例如，向一块图形缓冲写入内容的时候，需要将该图形缓冲区锁定，用来避免访问冲突, //锁定之后，就可以获得由参数参数l、t、w和h所圈定的一块缓冲区的起始地址，保存在输出参数vaddr中 status_t res = backBuffer-&gt;lockAsync( GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN, newDirtyRegion.bounds(), &amp;vaddr, fenceFd); ......&#125;return err;&#125; Surface的lock函数用来申请图形缓冲区和一些操作，方法不长，大概工作有： 1）调用connect函数完成一些初始化； 2）调用dequeueBuffer函数，申请图形缓冲区； 3）计算需要绘制的新的dirty区域，旧的区域原样copy数据。 [-&gt;BufferQueueProducer.cpp] 123456789101112131415161718192021222324252627int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) &#123;uint32_t reqWidth;uint32_t reqHeight;PixelFormat reqFormat;uint32_t reqUsage;&#123; ......//申请图形缓冲区status_t result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, reqWidth, reqHeight, reqFormat, reqUsage);......//根据index获取缓冲区sp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer);......if ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == 0) &#123; //由于申请的内存是在surfaceflinger进程中， //BufferQueue中的图形缓冲区也是通过匿名共享内存和binder传递描述符映射过去的， //Surface通过调用requestBuffer将图形缓冲区映射到Surface所在进程 result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf); ......&#125;......//获取这个这个buffer对象的指针内容*buffer = gbuf.get();......return OK;&#125; [-&gt;BufferQueueProducer.cpp] 12345678910status_t BufferQueueProducer::requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf) &#123;ATRACE_CALL();Mutex::Autolock lock(mCore-&gt;mMutex);......mSlots[slot].mRequestBufferCalled = true;*buf = mSlots[slot].mGraphicBuffer;return NO_ERROR;&#125; 这个比较简单，还是很好理解的额，就是根据指定index取出mSlots中的slot中的buffer。 4.4、APP提交(unlockAndPost)Buffer的过程Surface绘制完毕后，unlockCanvasAndPost操作。[-&gt;android_view_Surface.cpp] 1234567891011121314151617static void nativeUnlockCanvasAndPost(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj) &#123;sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject));if (!isSurfaceValid(surface)) &#123; return;&#125;// detach the canvas from the surfaceCanvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);nativeCanvas-&gt;setBitmap(SkBitmap());// unlock surfacestatus_t err = surface-&gt;unlockAndPost();if (err &lt; 0) &#123; doThrowIAE(env);&#125;&#125; [-&gt;Surface.cpp] 123456789101112131415status_t Surface::unlockAndPost()&#123;......int fd = -1;//解锁图形缓冲区，和前面的lockAsync成对出现status_t err = mLockedBuffer-&gt;unlockAsync(&amp;fd);//queueBuffer去归还图形缓冲区err = queueBuffer(mLockedBuffer.get(), fd);mPostedBuffer = mLockedBuffer;mLockedBuffer = 0;return err;&#125; 这里也比较简单，核心也是分两步： 1）解锁图形缓冲区，和前面的lockAsync成对出现； 2）queueBuffer去归还图形缓冲区； 所以我们还是重点分析第二步，查看queueBuffer的实现： [-&gt;Surface.cpp] 1234567int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) &#123;......status_t err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);mLastQueueDuration = systemTime() - now;......return err;&#125; 调用BufferQueueProducer的queueBuffer归还缓冲区，将绘制后的图形缓冲区queue回去。[-&gt;BufferQueueProducer.cpp] 1234567891011121314151617181920status_t BufferQueueProducer::queueBuffer(int slot, const QueueBufferInput &amp;input, QueueBufferOutput *output) &#123;......&#123; // scope for the lock Mutex::Autolock lock(mCallbackMutex); while (callbackTicket != mCurrentCallbackTicket) &#123; mCallbackCondition.wait(mCallbackMutex); &#125; if (frameAvailableListener != NULL) &#123; frameAvailableListener-&gt;onFrameAvailable(item); &#125; else if (frameReplacedListener != NULL) &#123; frameReplacedListener-&gt;onFrameReplaced(item); &#125; ......&#125;......return NO_ERROR;&#125; 总结： 1）从传入的QueueBufferInput ，解析填充一些变量； 2）改变入队Slot的状态为QUEUED，每次推进来，mFrameCounter都加1。这里的slot，上一篇讲分配缓冲区返回最老的FREE状态buffer，就是用这个mFrameCounter最小值判断，就是上一篇LRU算法的判断； 3）创建一个BufferItem来描述GraphicBuffer，用mSlots[slot]中的slot填充BufferItem； 4）将BufferItem塞进mCore的mQueue队列，依照指定规则； 5）然后通知SurfaceFlinger去消费。Folw： （五）、通知SF消费合成当绘制完毕的GraphicBuffer入队之后，会通知SurfaceFlinger去消费，就是BufferQueueProducer的queueBuffer函数的最后几行，listener-&gt;onFrameAvailable()。listener最终通过回调，会回到Layer当中，所以最终调用Layer的onFrameAvailable接口，我们看看它的实现：[Layer.cpp] 123456789101112void Layer::onFrameAvailable(const BufferItem&amp; item) &#123;// Add this buffer from our internal queue tracker&#123; // Autolock scope ...... mQueueItems.push_back(item); android_atomic_inc(&amp;mQueuedFrames); // Wake up any pending callbacks mLastFrameNumberReceived = item.mFrameNumber; mQueueItemCondition.broadcast();&#125;mFlinger-&gt;signalLayerUpdate();&#125; 这里又调用SurfaceFlinger的signalLayerUpdate函数，继续查看：[SurfaceFlinger.cpp] 123void SurfaceFlinger::signalLayerUpdate() &#123;mEventQueue.invalidate();&#125; 这里又调用MessageQueue的invalidate函数：[MessageQueue.cpp] 123void MessageQueue::invalidate() &#123;mEvents-&gt;requestNextVsync();&#125; 贴一下SurfaceFlinger的初始化请求vsync信号流程图： 最终结果会走到SurfaceFlinger的vsync信号接收逻辑，即SurfaceFlinger的onMessageReceived函数：[SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930void SurfaceFlinger::onMessageReceived(int32_t what) &#123;ATRACE_CALL();switch (what) &#123; case MessageQueue::INVALIDATE: &#123; bool frameMissed = !mHadClientComposition &amp;&amp; mPreviousPresentFence != Fence::NO_FENCE &amp;&amp; mPreviousPresentFence-&gt;getSignalTime() == INT64_MAX; ATRACE_INT(\"FrameMissed\", static_cast&lt;int&gt;(frameMissed)); if (mPropagateBackpressure &amp;&amp; frameMissed) &#123; signalLayerUpdate(); break; &#125; bool refreshNeeded = handleMessageTransaction(); refreshNeeded |= handleMessageInvalidate(); refreshNeeded |= mRepaintEverything; if (refreshNeeded) &#123; // Signal a refresh if a transaction modified the window state, // a new buffer was latched, or if HWC has requested a full // repaint signalRefresh(); &#125; break; &#125; case MessageQueue::REFRESH: &#123; handleMessageRefresh(); break; &#125;&#125;&#125; SurfaceFlinger收到了VSync信号后，调用了handleMessageRefresh函数[SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627void SurfaceFlinger::handleMessageRefresh() &#123;ATRACE_CALL();nsecs_t refreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC);preComposition();rebuildLayerStacks();setUpHWComposer();doDebugFlashRegions();doComposition();postComposition(refreshStartTime);mPreviousPresentFence = mHwc-&gt;getRetireFence(HWC_DISPLAY_PRIMARY);mHadClientComposition = false;for (size_t displayId = 0; displayId &lt; mDisplays.size(); ++displayId) &#123; const sp&lt;DisplayDevice&gt;&amp; displayDevice = mDisplays[displayId]; mHadClientComposition = mHadClientComposition || mHwc-&gt;hasClientComposition(displayDevice-&gt;getHwcDisplayId());&#125;// Release any buffers which were replaced this framefor (auto&amp; layer : mLayersWithQueuedFrames) &#123; layer-&gt;releasePendingBuffer();&#125;mLayersWithQueuedFrames.clear();&#125; 我们主要看下下面几个函数。[SurfaceFlinger.cpp] 123456preComposition();rebuildLayerStacks();setUpHWComposer();doDebugFlashRegions();doComposition();postComposition(refreshStartTime); 一、preComposition()函数我们先来看第一个函数preComposition()[SurfaceFlinger.cpp] 1234567891011121314void SurfaceFlinger::preComposition()&#123;bool needExtraInvalidate = false;const LayerVector&amp; layers(mDrawingState.layersSortedByZ);const size_t count = layers.size();for (size_t i=0 ; i&lt;count ; i++) &#123; if (layers[i]-&gt;onPreComposition()) &#123; needExtraInvalidate = true; &#125;&#125;if (needExtraInvalidate) &#123; signalLayerUpdate();&#125;&#125; 上面函数先是调用了mDrawingState的layersSortedByZ来得到上次绘图的Layer层列表。并不是所有的Layer都会参与屏幕图像的绘制，因此SurfaceFlinger用state对象来记录参与绘制的Layer对象。记得我们之前分析过createLayer函数来创建Layer，创建之后会调用addClientLayer函数。[SurfaceFlinger.cpp] 1234567891011121314151617181920status_t SurfaceFlinger::addClientLayer(const sp&lt;Client&gt;&amp; client, const sp&lt;IBinder&gt;&amp; handle, const sp&lt;IGraphicBufferProducer&gt;&amp; gbc, const sp&lt;Layer&gt;&amp; lbc) &#123;// add this layer to the current state list&#123; Mutex::Autolock _l(mStateLock); if (mCurrentState.layersSortedByZ.size() &gt;= MAX_LAYERS) &#123; return NO_MEMORY; &#125; mCurrentState.layersSortedByZ.add(lbc); mGraphicBufferProducerList.add(IInterface::asBinder(gbc));&#125;// attach this layer to the clientclient-&gt;attachLayer(handle, lbc);return NO_ERROR;&#125; 我们来看下addClientLayer函数，这里会把Layer对象放在mCurrentState的layersSortedByZ对象中。而mDrawingState和mCurrentState什么关系呢？在后面我们会介绍，mDrawingState代表上一次绘图时的状态，处理完之后会把mCurrentState赋给mDrawingState。回到preComposition函数，遍历所有的Layer对象，调用其onPreComposition函数来检测Layer层中的图像是否有变化。 1.1、每个Layer的onFrameAvailable函数onPreComposition函数来根据mQueuedFrames来判断图像是否发生了变化，或者是mSidebandStreamChanged、mAutoRefresh。[Layer.cpp] 1234bool Layer::onPreComposition() &#123;mRefreshPending = false;return mQueuedFrames &gt; 0 || mSidebandStreamChanged || mAutoRefresh;&#125; 当Layer所对应的Surface更新图像后，它所对应的Layer对象的onFrameAvailable函数会被调用来通知这种变化。在SurfaceFlinger的preComposition函数中当有Layer的图像改变了，最后也会调用SurfaceFlinger的signalLayerUpdate函数。SurfaceFlinger::signalLayerUpdate是调用了MessageQueue的invalidate函数最后处理还是调用了SurfaceFlinger的onMessageReceived函数。看看SurfaceFlinger的onMessageReceived函数对NVALIDATE的处理handleMessageInvalidate函数中调用了handlePageFlip函数，这个函数将会处理Layer中的缓冲区，把更新过的图像缓冲区切换到前台，等待VSync信号更新到FrameBuffer。 1.2、绘制流程用户进程更新Surface图像，将导致SurfaceFlinger中的Layer发送invalidate消息，处理该消息会调用handleTransaction函数和handlePageFilp函数来更新Layer对象。一旦VSync信号到来，再调用rebuildlayerStacks setUpHWComposer doComposition postComposition函数将所有Layer的图像混合后更新到显示设备上去。 二、handleTransaction handPageFlip更新Layer对象在上一节中的绘图的流程中，我们看到了handleTransaction和handPageFlip这两个函数通常是在用户进程更新Surface图像时会调用，来更新Layer对象。这节就主要讲解这两个函数。 2.1、handleTransaction函数handleTransaction函数的参数是transactionFlags，不过函数中没有使用这个参数，而是通过getTransactionFlags(eTransactionMask)来重新对transactionFlags赋值，然后使用它作为参数来调用函数handleTransactionLocked。[SurfaceFlinger.cpp] 123456789101112131415void SurfaceFlinger::handleTransaction(uint32_t transactionFlags)&#123;ATRACE_CALL();Mutex::Autolock _l(mStateLock);const nsecs_t now = systemTime();mDebugInTransaction = now;transactionFlags = getTransactionFlags(eTransactionMask);handleTransactionLocked(transactionFlags);mLastTransactionTime = systemTime() - now;mDebugInTransaction = 0;invalidateHwcGeometry();&#125; getTransactionFlags函数的参数是eTransactionMask只是屏蔽其他位。handleTransactionLocked函数会调用每个Layer类的doTransaction函数，在分析handleTransactionLocked函数之前，我们先看看Layer类 的doTransaction函数。 2.2、Layer的doTransaction函数下面是Layer的doTransaction函数代码[Layer.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475uint32_t Layer::doTransaction(uint32_t flags) &#123;ATRACE_CALL();pushPendingState();//上次绘制的State对象 Layer::State c = getCurrentState();//当前使用的State对象 const Layer::State&amp; s(getDrawingState());const bool sizeChanged = (c.requested.w != s.requested.w) || (c.requested.h != s.requested.h);if (sizeChanged) &#123; // the size changed, we need to ask our client to request a new buffer //如果Layer的尺寸发生变化，就要改变Surface的缓冲区的尺寸 // record the new size, form this point on, when the client request // a buffer, it'll get the new size. mSurfaceFlingerConsumer-&gt;setDefaultBufferSize( c.requested.w, c.requested.h);&#125;const bool resizePending = (c.requested.w != c.active.w) || (c.requested.h != c.active.h);if (!isFixedSize()) &#123; if (resizePending &amp;&amp; mSidebandStream == NULL) &#123; //如果Layer不是固定尺寸的类型，比较它的实际大小和要求的改变大小 flags |= eDontUpdateGeometryState; &#125;&#125;//如果没有eDontUpdateGeometryState标志，更新active的值为request if (flags &amp; eDontUpdateGeometryState) &#123;&#125; else &#123; Layer::State&amp; editCurrentState(getCurrentState()); if (mFreezePositionUpdates) &#123; float tx = c.active.transform.tx(); float ty = c.active.transform.ty(); c.active = c.requested; c.active.transform.set(tx, ty); editCurrentState.active = c.active; &#125; else &#123; editCurrentState.active = editCurrentState.requested; c.active = c.requested; &#125;&#125;// 如果当前state的active和以前的State的active不等，设置更新标志 if (s.active != c.active) &#123; // invalidate and recompute the visible regions if needed flags |= Layer::eVisibleRegion;&#125;//如果当前state的sequence和以前state的sequence不等，设置更新标志if (c.sequence != s.sequence) &#123; // invalidate and recompute the visible regions if needed flags |= eVisibleRegion; this-&gt;contentDirty = true; // we may use linear filtering, if the matrix scales us const uint8_t type = c.active.transform.getType(); mNeedsFiltering = (!c.active.transform.preserveRects() || (type &gt;= Transform::SCALE));&#125;// If the layer is hidden, signal and clear out all local sync points so// that transactions for layers depending on this layer's frames becoming// visible are not blockedif (c.flags &amp; layer_state_t::eLayerHidden) &#123; Mutex::Autolock lock(mLocalSyncPointMutex); for (auto&amp; point : mLocalSyncPoints) &#123; point-&gt;setFrameAvailable(); &#125; mLocalSyncPoints.clear();&#125;// Commit the transactioncommitTransaction(c);return flags;&#125; Layer类中的两个类型为Layer::State的成员变量mDrawingState、mCurrentState，这里为什么要两个对象呢？Layer对象在绘制图形时，使用的是mDrawingState变量，用户调用接口设置Layer对象属性是，设置的值保存在mCurrentState对象中，这样就不会因为用户的操作而干扰Layer对象的绘制了。Layer的doTransaction函数据你是比较这两个变量，如果有不同的地方，说明在上次绘制以后，用户改变的Layer的设置，要把这种变化通过flags返回。State的结构中有两个Geometry字段，active和requested。他们表示layer的尺寸，其中requested保存是用户设置的尺寸，而active保存的值通过计算后的实际尺寸。State中的z字段的值就是Layer在显示轴的位置，值越小位置越靠下。layerStack字段是用户指定的一个值，用户可以给DisplayDevice也指定一个layerStack值，只有Layer对象和DisplayDevice对象的layerStack相等，这个Layer才能在这个显示设备上输出，这样的好处是可以让显示设备只显示某个Surface的内容。例如，可以让HDMI显示设备只显示手机上播放视频的Surface窗口，但不显示Activity窗口。sequence字段是个序列值，每当用户调用了Layer的接口，例如setAlpha、setSize或者setLayer等改变Layer对象属性的哈数，这个值都会加1。因此在doTransaction函数中能通过比较sequence值来判断Layer的属性值有没有变化。doTransaction函数最后会调用commitTransaction函数，就是把mCurrentState赋值给mDrawingState[Layer.cpp] 123void Layer::commitTransaction(const State&amp; stateToCommit) &#123;mDrawingState = stateToCommit;&#125; 2.3、handleTransactionLocked函数下面我们来分析handleTransactionLocked函数，这个函数比较长，我们分段分析 2.3.1 处理Layer的事务[SurfaceFlinger.cpp] 123456789101112131415161718192021void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)&#123;const LayerVector&amp; currentLayers(mCurrentState.layersSortedByZ);const size_t count = currentLayers.size();// Notify all layers of available framesfor (size_t i = 0; i &lt; count; ++i) &#123; currentLayers[i]-&gt;notifyAvailableFrames();&#125;if (transactionFlags &amp; eTraversalNeeded) &#123; for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); uint32_t trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded); if (!trFlags) continue; const uint32_t flags = layer-&gt;doTransaction(0); if (flags &amp; Layer::eVisibleRegion) mVisibleRegionsDirty = true; &#125;&#125; 在SurfaceFlinger中也有两个类型为State的变量mCurrentState和mDrawingState，但是和Layer中的不要混起来。它的名字相同而已 1234 struct State &#123; LayerVector layersSortedByZ; DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays;&#125;; 结构layersSortedByZ字段保存所有参与绘制的Layer对象，而字段displays保存的是所有输出设备的DisplayDeviceState对象这里用两个变量的目的是和Layer中使用两个变量是一样的。上面代码根据eTraversalNeeded标志来决定是否要检查所有的Layer对象。如果某个Layer对象中有eTransactionNeeded标志，将调用它的doTransaction函数。Layer的doTransaction函数返回的flags如果有eVisibleRegion，说明这个Layer需要更新，就把mVisibleRegionsDirty设置为true 2.3.2、处理显示设备的变化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172 if (transactionFlags &amp; eDisplayTransactionNeeded) &#123; // here we take advantage of Vector's copy-on-write semantics to // improve performance by skipping the transaction entirely when // know that the lists are identical const KeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; curr(mCurrentState.displays); const KeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; draw(mDrawingState.displays); if (!curr.isIdenticalTo(draw)) &#123; mVisibleRegionsDirty = true; const size_t cc = curr.size(); size_t dc = draw.size(); // find the displays that were removed // (ie: in drawing state but not in current state) // also handle displays that changed // (ie: displays that are in both lists) for (size_t i=0 ; i&lt;dc ; i++) &#123; const ssize_t j = curr.indexOfKey(draw.keyAt(i)); if (j &lt; 0) &#123; // in drawing state but not in current state if (!draw[i].isMainDisplay()) &#123; // Call makeCurrent() on the primary display so we can // be sure that nothing associated with this display // is current. const sp&lt;const DisplayDevice&gt; defaultDisplay(getDefaultDisplayDevice()); defaultDisplay-&gt;makeCurrent(mEGLDisplay, mEGLContext); sp&lt;DisplayDevice&gt; hw(getDisplayDevice(draw.keyAt(i))); if (hw != NULL) hw-&gt;disconnect(getHwComposer()); if (draw[i].type &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) mEventThread-&gt;onHotplugReceived(draw[i].type, false); mDisplays.removeItem(draw.keyAt(i)); &#125; else &#123; ALOGW(\"trying to remove the main display\"); &#125; &#125; else &#123; // this display is in both lists. see if something changed. const DisplayDeviceState&amp; state(curr[j]); const wp&lt;IBinder&gt;&amp; display(curr.keyAt(j)); const sp&lt;IBinder&gt; state_binder = IInterface::asBinder(state.surface); const sp&lt;IBinder&gt; draw_binder = IInterface::asBinder(draw[i].surface); if (state_binder != draw_binder) &#123; // changing the surface is like destroying and // recreating the DisplayDevice, so we just remove it // from the drawing state, so that it get re-added // below. sp&lt;DisplayDevice&gt; hw(getDisplayDevice(display)); if (hw != NULL) hw-&gt;disconnect(getHwComposer()); mDisplays.removeItem(display); mDrawingState.displays.removeItemsAt(i); dc--; i--; // at this point we must loop to the next item continue; &#125; const sp&lt;DisplayDevice&gt; disp(getDisplayDevice(display)); if (disp != NULL) &#123; if (state.layerStack != draw[i].layerStack) &#123; disp-&gt;setLayerStack(state.layerStack); &#125; if ((state.orientation != draw[i].orientation) || (state.viewport != draw[i].viewport) || (state.frame != draw[i].frame)) &#123; disp-&gt;setProjection(state.orientation, state.viewport, state.frame); &#125; if (state.width != draw[i].width || state.height != draw[i].height) &#123; disp-&gt;setDisplaySize(state.width, state.height); &#125; &#125; &#125; &#125; // find displays that were added // (ie: in current state but not in drawing state) for (size_t i=0 ; i&lt;cc ; i++) &#123; if (draw.indexOfKey(curr.keyAt(i)) &lt; 0) &#123; const DisplayDeviceState&amp; state(curr[i]); sp&lt;DisplaySurface&gt; dispSurface; sp&lt;IGraphicBufferProducer&gt; producer; sp&lt;IGraphicBufferProducer&gt; bqProducer; sp&lt;IGraphicBufferConsumer&gt; bqConsumer; BufferQueue::createBufferQueue(&amp;bqProducer, &amp;bqConsumer, new GraphicBufferAlloc()); int32_t hwcDisplayId = -1; if (state.isVirtualDisplay()) &#123; // Virtual displays without a surface are dormant: // they have external state (layer stack, projection, // etc.) but no internal state (i.e. a DisplayDevice). if (state.surface != NULL) &#123; int width = 0; DisplayUtils* displayUtils = DisplayUtils::getInstance(); int status = state.surface-&gt;query( NATIVE_WINDOW_WIDTH, &amp;width); ALOGE_IF(status != NO_ERROR, \"Unable to query width (%d)\", status); int height = 0; status = state.surface-&gt;query( NATIVE_WINDOW_HEIGHT, &amp;height); ALOGE_IF(status != NO_ERROR, \"Unable to query height (%d)\", status); if (MAX_VIRTUAL_DISPLAY_DIMENSION == 0 || (width &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION &amp;&amp; height &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION)) &#123; int usage = 0; status = state.surface-&gt;query( NATIVE_WINDOW_CONSUMER_USAGE_BITS, &amp;usage); ALOGW_IF(status != NO_ERROR, \"Unable to query usage (%d)\", status); if ( (status == NO_ERROR) &amp;&amp; displayUtils-&gt;canAllocateHwcDisplayIdForVDS(usage)) &#123; hwcDisplayId = allocateHwcDisplayId(state.type); &#125; &#125; displayUtils-&gt;initVDSInstance(mHwc, hwcDisplayId, state.surface, dispSurface, producer, bqProducer, bqConsumer, state.displayName, state.isSecure, state.type); &#125; &#125; else &#123; ALOGE_IF(state.surface!=NULL, \"adding a supported display, but rendering \" \"surface is provided (%p), ignoring it\", state.surface.get()); hwcDisplayId = allocateHwcDisplayId(state.type); // for supported (by hwc) displays we provide our // own rendering surface dispSurface = new FramebufferSurface(*mHwc, state.type, bqConsumer); producer = bqProducer; &#125; const wp&lt;IBinder&gt;&amp; display(curr.keyAt(i)); if (dispSurface != NULL &amp;&amp; producer != NULL) &#123; sp&lt;DisplayDevice&gt; hw = new DisplayDevice(this, state.type, hwcDisplayId, mHwc-&gt;getFormat(hwcDisplayId), state.isSecure, display, dispSurface, producer, mRenderEngine-&gt;getEGLConfig()); hw-&gt;setLayerStack(state.layerStack); hw-&gt;setProjection(state.orientation, state.viewport, state.frame); hw-&gt;setDisplayName(state.displayName); // When a new display device is added update the active // config by querying HWC otherwise the default config // (config 0) will be used. if (hwcDisplayId &gt;= DisplayDevice::DISPLAY_PRIMARY &amp;&amp; hwcDisplayId &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) &#123; int activeConfig = mHwc-&gt;getActiveConfig(hwcDisplayId); if (activeConfig &gt;= 0) &#123; hw-&gt;setActiveConfig(activeConfig); &#125; &#125; mDisplays.add(display, hw); if (state.isVirtualDisplay()) &#123; if (hwcDisplayId &gt;= 0) &#123; mHwc-&gt;setVirtualDisplayProperties(hwcDisplayId, hw-&gt;getWidth(), hw-&gt;getHeight(), hw-&gt;getFormat()); &#125; &#125; else &#123; mEventThread-&gt;onHotplugReceived(state.type, true); &#125; &#125; &#125; &#125; &#125;&#125; 这段代码的作用是处理显示设备的变化，分成3种情况：1.显示设备减少了，需要把显示设备对应的DisplayDevice移除2.显示设备发生了变化，例如用户设置了Surface、重新设置了layerStack、旋转了屏幕等，这就需要重新设置显示对象的属性3.显示设备增加了，创建新的DisplayDevice加入系统中。 2.3.3、设置TransfromHit12345678910111213141516171819202122232425262728293031323334353637383940 if (transactionFlags &amp; (eTraversalNeeded|eDisplayTransactionNeeded)) &#123; ...... sp&lt;const DisplayDevice&gt; disp; uint32_t currentlayerStack = 0; for (size_t i=0; i&lt;count; i++) &#123; // NOTE: we rely on the fact that layers are sorted by // layerStack first (so we don't have to traverse the list // of displays for every layer). const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); uint32_t layerStack = layer-&gt;getDrawingState().layerStack; if (i==0 || currentlayerStack != layerStack) &#123; currentlayerStack = layerStack; // figure out if this layerstack is mirrored // (more than one display) if so, pick the default display, // if not, pick the only display it's on. disp.clear(); for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); if (hw-&gt;getLayerStack() == currentlayerStack) &#123; if (disp == NULL) &#123; disp = hw; &#125; else &#123; disp = NULL; break; &#125; &#125; &#125; &#125; if (disp == NULL) &#123; // NOTE: TEMPORARY FIX ONLY. Real fix should cause layers to // redraw after transform hint changes. See bug 8508397. // could be null when this layer is using a layerStack // that is not visible on any display. Also can occur at // screen off/on times. disp = getDefaultDisplayDevice(); &#125; layer-&gt;updateTransformHint(disp); &#125;&#125; 这段代码的作用是根据每种显示设备的不同，设置和显示设备关联在一起的Layer（主要看Layer的layerStack是否和DisplayDevice的layerStack）的TransformHint（主要指设备的显示方向orientation）。 2.3.4、处理Layer增加情况123456789101112131415161718192021222324252627282930/* * Perform our own transaction if needed */const LayerVector&amp; layers(mDrawingState.layersSortedByZ);if (currentLayers.size() &gt; layers.size()) &#123; // layers have been added mVisibleRegionsDirty = true;&#125;// some layers might have been removed, so// we need to update the regions they're exposing.if (mLayersRemoved) &#123; mLayersRemoved = false; mVisibleRegionsDirty = true; const size_t count = layers.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); if (currentLayers.indexOf(layer) &lt; 0) &#123; // this layer is not visible anymore // TODO: we could traverse the tree from front to back and // compute the actual visible region // TODO: we could cache the transformed region const Layer::State&amp; s(layer-&gt;getDrawingState()); Region visibleReg = s.active.transform.transform( Region(Rect(s.active.w, s.active.h))); invalidateLayerStack(s.layerStack, visibleReg); &#125; &#125;&#125; 这段代码处理Layer的增加情况，如果Layer增加了，需要重新计算设备的更新区域，因此把mVisibleRegionsDirty设为true，如果Layer删除了，需要把Layer的可见区域加入到系统需要更新的区域中。 2.3.5、设置mDrawingState12commitTransaction();updateCursorAsync(); 调用commitTransaction和updateCursorAsync函数 commitTransaction函数作用是把mDrawingState的值设置成mCurrentState的值。而updateCursorAsync函数会更新所有显示设备中光标的位置。 2.3.6 小结handleTransaction函数的作用的就是处理系统在两次刷新期间的各种变化。SurfaceFlinger模块中不管是SurfaceFlinger类还是Layer类，都采用了双缓冲的方式来保存他们的属性，这样的好处是刚改变SurfaceFlinger对象或者Layer类对象的属性是，不需要上锁，大大的提高了系统效率。只有在最后的图像输出是，才进行一次上锁，并进行内存的属性变化处理。正因此，应用进程必须收到VSync信号才开始改变Surface的内容。 2.4、handlePageFlip函数handlePageFlip函数代码如下：[SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool SurfaceFlinger::handlePageFlip()&#123;Region dirtyRegion;bool visibleRegions = false;const LayerVector&amp; layers(mDrawingState.layersSortedByZ);bool frameQueued = false;// Store the set of layers that need updates. This set must not change as// buffers are being latched, as this could result in a deadlock.// Example: Two producers share the same command stream and:// 1.) Layer 0 is latched// 2.) Layer 0 gets a new frame// 2.) Layer 1 gets a new frame// 3.) Layer 1 is latched.// Display is now waiting on Layer 1's frame, which is behind layer 0's// second frame. But layer 0's second frame could be waiting on display.Vector&lt;Layer*&gt; layersWithQueuedFrames;for (size_t i = 0, count = layers.size(); i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); if (layer-&gt;hasQueuedFrame()) &#123; frameQueued = true; if (layer-&gt;shouldPresentNow(mPrimaryDispSync)) &#123; layersWithQueuedFrames.push_back(layer.get()); &#125; else &#123; layer-&gt;useEmptyDamage(); &#125; &#125; else &#123; layer-&gt;useEmptyDamage(); &#125;&#125;for (size_t i = 0, count = layersWithQueuedFrames.size() ; i&lt;count ; i++) &#123; Layer* layer = layersWithQueuedFrames[i]; const Region dirty(layer-&gt;latchBuffer(visibleRegions)); layer-&gt;useSurfaceDamage(); const Layer::State&amp; s(layer-&gt;getDrawingState()); invalidateLayerStack(s.layerStack, dirty);&#125;mVisibleRegionsDirty |= visibleRegions;// If we will need to wake up at some time in the future to deal with a// queued frame that shouldn't be displayed during this vsync period, wake// up during the next vsync period to check again.if (frameQueued &amp;&amp; layersWithQueuedFrames.empty()) &#123; signalLayerUpdate();&#125;// Only continue with the refresh if there is actually new work to doreturn !layersWithQueuedFrames.empty();&#125; handlePageFlip函数先调用每个Layer对象的hasQueuedFrame函数，确定这个Layer对象是否有需要更新的图层，然后把需要更新的Layer对象放到layersWithQueuedFrames中。我们先来看Layer的hasQueuedFrame方法就是看其mQueuedFrames是否大于0 和mSidebandStreamChanged。前面小节分析只要Surface有数据写入，就会调用Layer的onFrameAvailable函数，然后mQueuedFrames值加1.继续看handlePageFlip函数，接着调用需要更新的Layer对象的latchBuffer函数，然后根据返回的更新区域调用invalidateLayerStack函数来设置更新设备对象的更新区域。下面我们看看latchBuffer函数 LatchBuffer函数调用updateTextImage来得到需要的图像。这里参数r是Reject对象，其作用是判断在缓冲区的尺寸是否符合要求。调用updateTextImage函数如果得到的结果是PRESENT_LATER,表示推迟处理，然后调用signalLayerUpdate函数来发送invalidate消息，这次绘制过程就不处理这个Surface的图像了。如果不需要推迟处理，把mQueuedFrames的值减1.最后LatchBuffer函数调用mSurfaceFlingerConsumer的getCurrentBuffer来取回当前的图像缓冲区指针，保存在mActiveBuffer中。 2.5 小结这样经过handleTransaction handlePageFlip两个函数处理，SurfaceFlinger中无论是Layer属性的变化还是图像的变化都处理好了，只等VSync信号到来就可以输出了。 三、rebuildLayerStacks函数前面介绍，VSync信号到来后，先是调用了rebuildLayerStacks函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445void SurfaceFlinger::rebuildLayerStacks() &#123;updateExtendedMode();// rebuild the visible layer list per screenif (CC_UNLIKELY(mVisibleRegionsDirty)) &#123; ATRACE_CALL(); mVisibleRegionsDirty = false; invalidateHwcGeometry(); //计算每个显示设备上可见的Layer const LayerVector&amp; layers(mDrawingState.layersSortedByZ); for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; Region opaqueRegion; Region dirtyRegion; Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ; const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]); const Transform&amp; tr(hw-&gt;getTransform()); const Rect bounds(hw-&gt;getBounds()); if (hw-&gt;isDisplayOn()) &#123; //计算每个layer的可见区域，确定设备需要重新绘制的区域 computeVisibleRegions(hw-&gt;getHwcDisplayId(), layers, hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion); const size_t count = layers.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); &#123; //只需要和显示设备的LayerStack相同的layer Region drawRegion(tr.transform( layer-&gt;visibleNonTransparentRegion)); drawRegion.andSelf(bounds); if (!drawRegion.isEmpty()) &#123; //如果Layer的显示区域和显示设备的窗口有交集 //把Layer加入列表中 layersSortedByZ.add(layer); &#125; &#125; &#125; &#125; //设置显示设备的可见Layer列表 hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ); hw-&gt;undefinedRegion.set(bounds); hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion)); hw-&gt;dirtyRegion.orSelf(dirtyRegion); &#125;&#125;&#125; rebuildLayerStacks函数的作用是重建每个显示设备的可见layer对象列表。对于按显示轴（Z轴）排列的Layer对象，排在最前面的当然会优先显示，但是Layer图像可能有透明域，也可能有尺寸没有覆盖整个屏幕，因此下面的layer也有显示的机会。rebuildLayerStacks函数对每个显示设备，先计算和显示设备具有相同layerStack值的Layer对象在该显示设备上的可见区域。然后将可见区域和显示设备的窗口区域有交集的layer组成一个新的列表，最后把这个列表设置到显示设备对象中。computeVisibleRegions函数首先计算每个Layer在设备上的可见区域visibleRegion。计算方法就是用整个Layer的区域减去上层所有不透明区域aboveOpaqueLayers。而上层所有不透明区域值是一个逐层累计的过程，每层都需要把自己的不透明区域累加到aboveOpaqueLayers中。而每层的不透明区域的计算方法：如果Layer的alpha的值为255，并且layer的isOpaque函数为true，则本层的不透明区域等于Layer所在区域，否则为0.这样一层层算下来，就很容易得到每层的可见区域大小了。其次，计算整个显示设备需要更新的区域outDirtyRegion。outDirtyRegion的值也是累计所有层的需要重回的区域得到的。如果Layer中的显示内容发生了变化，则整个可见区域visibleRegion都需要更新，同时还要包括上一次的可见区域，然后在去掉被上层覆盖后的区域得到的就是Layer需要更新的区域。如果Layer显示的内容没有变化，但是考虑到窗口大小的变化或者上层窗口的变化，因此Layer中还是有区域可以需要重绘的地方。这种情况下最简单的算法是用Layer计算出可见区域减去以前的可见区域就可以了。但是在computeVisibleRegions函数还引入了被覆盖区域，通常被覆盖区域和可见区域并不重复，因此函数中计算暴露区域是用可见区域减去被覆盖区域的。 四、setUpHWComposer函数setUpHWComposer函数的作用是更新HWComposer对象中图层对象列表以及图层属性。[SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102void SurfaceFlinger::setUpHWComposer() &#123;for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; bool dirty = !mDisplays[dpy]-&gt;getDirtyRegion(false).isEmpty(); bool empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == 0; bool wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers; ...... bool mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty); ...... mDisplays[dpy]-&gt;beginFrame(mustRecompose); if (mustRecompose) &#123; mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty; &#125;&#125;//得到系统HWComposer对象 HWComposer&amp; hwc(getHwComposer());if (hwc.initCheck() == NO_ERROR) &#123; // build the h/w work list if (CC_UNLIKELY(mHwWorkListDirty)) &#123; mHwWorkListDirty = false; for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;= 0) &#123; const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers( hw-&gt;getVisibleLayersSortedByZ()); const size_t count = currentLayers.size(); //根据Layer数量在HWComposer中创建hwc_layer_list_t列表 if (hwc.createWorkList(id, count) == NO_ERROR) &#123; HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123; const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); layer-&gt;setGeometry(hw, *cur); if (mDebugDisableHWC || mDebugRegion || mDaltonize || mHasColorMatrix) &#123; cur-&gt;setSkip(true); &#125; &#125; &#125; &#125; &#125; &#125; // set the per-frame data for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;= 0) &#123; bool freezeSurfacePresent = false; isfreezeSurfacePresent(freezeSurfacePresent, hw, id); const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers( hw-&gt;getVisibleLayersSortedByZ()); const size_t count = currentLayers.size(); HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123; /* * update the per-frame h/w composer data for each layer * and build the transparent region of the FB */ const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); //将Layer的mActiveBuffer设置到HWComposer中 layer-&gt;setPerFrameData(hw, *cur); setOrientationEventControl(freezeSurfacePresent,id); &#125; &#125; &#125; // If possible, attempt to use the cursor overlay on each display. for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;= 0) &#123; const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers( hw-&gt;getVisibleLayersSortedByZ()); const size_t count = currentLayers.size(); HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123; const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); if (layer-&gt;isPotentialCursor()) &#123; cur-&gt;setIsCursorLayerHint(); break; &#125; &#125; &#125; &#125; dumpDrawCycle(true); status_t err = hwc.prepare(); ALOGE_IF(err, \"HWComposer::prepare failed (%s)\", strerror(-err)); for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); hw-&gt;prepareFrame(hwc); &#125;&#125;&#125; HWComposer中有一个类型为DisplayData结构的数组mDisplayData，它维护着每个显示设备的信息。DisplayData结构中有一个类型为hwc_display_contents_l字段list，这个字段又有一个hwc_layer_l类型的数组hwLayers，记录该显示设备所有需要输出的Layer信息。setUpHWComposer函数调用HWComposer的createWorkList函数就是根据每种显示设备的Layer数量，创建和初始化hwc_display_contents_l对象和hwc_layer_l数组创建完HWComposer中的列表后，接下来是对每个Layer对象调用它的setPerFrameData函数，参数是HWComposer和HWCLayerInterface。setPerFrameData函数将Layer对象的当前图像缓冲区mActiveBuffer设置到HWCLayerInterface对象对应的hwc_layer_l对象中。HWComposer类中除了前面介绍的Gralloc还管理着Composer模块，这个模块实现了硬件的图像合成功能。setUpHWComposer函数接下来调用HWComposer类的prepare函数，而prepare函数会调用Composer模块的prepare接口。最后到各个厂家的实现hwc_prepare函数将每种HWComposer中的所有图层的类型都设置为HWC_FRAMEBUFFER就结束了。 五、合成所有层的图像 （doComposition()函数）doComposition函数是合成所有层的图像，代码如下：[SurfaceFlinger.cpp] 123456789101112131415161718192021void SurfaceFlinger::doComposition() &#123;ATRACE_CALL();const bool repaintEverything = android_atomic_and(0, &amp;mRepaintEverything);for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]); if (hw-&gt;isDisplayOn()) &#123; // transform the dirty region into this screen's coordinate space const Region dirtyRegion(hw-&gt;getDirtyRegion(repaintEverything)); // repaint the framebuffer (if needed) doDisplayComposition(hw, dirtyRegion); hw-&gt;dirtyRegion.clear(); hw-&gt;flip(hw-&gt;swapRegion); hw-&gt;swapRegion.clear(); &#125; // inform the h/w that we're done compositing hw-&gt;compositionComplete();&#125;postFramebuffer();&#125; doComposition函数针对每种显示设备调用doDisplayComposition函数来合成，合成后调用postFramebuffer函数，我们先来看看doDisplayComposition函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void SurfaceFlinger::doDisplayComposition(const sp&lt;const DisplayDevice&gt;&amp; hw, const Region&amp; inDirtyRegion) &#123;// We only need to actually compose the display if:// 1) It is being handled by hardware composer, which may need this to// keep its virtual display state machine in sync, or// 2) There is work to be done (the dirty region isn't empty)bool isHwcDisplay = hw-&gt;getHwcDisplayId() &gt;= 0;if (!isHwcDisplay &amp;&amp; inDirtyRegion.isEmpty()) &#123; ALOGV(\"Skipping display composition\"); return;&#125;ALOGV(\"doDisplayComposition\");Region dirtyRegion(inDirtyRegion);// compute the invalid region//swapRegion设置为需要更新的区域 hw-&gt;swapRegion.orSelf(dirtyRegion);uint32_t flags = hw-&gt;getFlags();//获得显示设备支持的更新方式标志 if (flags &amp; DisplayDevice::SWAP_RECTANGLE) &#123; // we can redraw only what's dirty, but since SWAP_RECTANGLE only // takes a rectangle, we must make sure to update that whole // rectangle in that case dirtyRegion.set(hw-&gt;swapRegion.bounds());&#125; else &#123; if (flags &amp; DisplayDevice::PARTIAL_UPDATES) &#123;//支持部分更新 // We need to redraw the rectangle that will be updated // (pushed to the framebuffer). // This is needed because PARTIAL_UPDATES only takes one // rectangle instead of a region (see DisplayDevice::flip()) //将更新区域调整为整个窗口大小 dirtyRegion.set(hw-&gt;swapRegion.bounds()); &#125; else &#123; // we need to redraw everything (the whole screen) dirtyRegion.set(hw-&gt;bounds()); hw-&gt;swapRegion = dirtyRegion; &#125;&#125;//合成 if (!doComposeSurfaces(hw, dirtyRegion)) return;// update the swap region and clear the dirty regionhw-&gt;swapRegion.orSelf(dirtyRegion);//没有硬件composer的情况，输出图像 // swap buffers (presentation)hw-&gt;swapBuffers(getHwComposer());&#125; doDisplayComposition函数根据显示设备支持的更新方式，重新设置需要更新区域的大小。真正的合成工作是在doComposerSurfaces函数中完成，这个函数在layer的类型为HWC_FRAMEBUFFER,或者不支持硬件的composer的情况下，调用layer的draw函数来一层一层低合成最后的图像。合成完后，doDisplayComposition函数调用了hw的swapBuffers函数，这个函数前面介绍过了，它将在系统不支持硬件的composer情况下调用eglSwapBuffers来输出图像到显示设备。 六、postFramebuffer()函数上一节的doComposition函数最后调用了postFramebuffer函数，代码如下：[SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void SurfaceFlinger::postFramebuffer()&#123;ATRACE_CALL();const nsecs_t now = systemTime();mDebugInSwapBuffers = now;HWComposer&amp; hwc(getHwComposer());if (hwc.initCheck() == NO_ERROR) &#123; if (!hwc.supportsFramebufferTarget()) &#123; // EGL spec says: // \"surface must be bound to the calling thread's current context, // for the current rendering API.\" getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext); &#125; hwc.commit();&#125;// make the default display current because the VirtualDisplayDevice code cannot// deal with dequeueBuffer() being called outside of the composition loop; however// the code below can call glFlush() which is allowed (and does in some case) call// dequeueBuffer().getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(hw-&gt;getVisibleLayersSortedByZ()); hw-&gt;onSwapBuffersCompleted(hwc); const size_t count = currentLayers.size(); int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;=0 &amp;&amp; hwc.initCheck() == NO_ERROR) &#123; HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i = 0; cur != end &amp;&amp; i &lt; count; ++i, ++cur) &#123; currentLayers[i]-&gt;onLayerDisplayed(hw, &amp;*cur); &#125; &#125; else &#123; for (size_t i = 0; i &lt; count; i++) &#123; currentLayers[i]-&gt;onLayerDisplayed(hw, NULL); &#125; &#125;&#125;mLastSwapBufferTime = systemTime() - now;mDebugInSwapBuffers = 0;uint32_t flipCount = getDefaultDisplayDevice()-&gt;getPageFlipCount();if (flipCount % LOG_FRAME_STATS_PERIOD == 0) &#123; logFrameStats();&#125;&#125; postFramebuffer先判断系统是否支持composer，如果不支持，我们知道图像已经在doComposition函数时调用hw-&gt;swapBuffers输出了，就返回了。如果支持硬件composer，postFramebuffer函数将调用HWComposer的commit函数继续执行。[HWComposer.cpp] 12345678910111213141516171819202122232425262728293031323334353637status_t HWComposer::commit() &#123;int err = NO_ERROR;if (mHwc) &#123; if (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123; // On version 1.0, the OpenGL ES target surface is communicated // by the (dpy, sur) fields and we are guaranteed to have only // a single display. mLists[0]-&gt;dpy = eglGetCurrentDisplay(); mLists[0]-&gt;sur = eglGetCurrentSurface(EGL_DRAW); &#125; for (size_t i=VIRTUAL_DISPLAY_ID_BASE; i&lt;mNumDisplays; i++) &#123; DisplayData&amp; disp(mDisplayData[i]); if (disp.outbufHandle) &#123; mLists[i]-&gt;outbuf = disp.outbufHandle; mLists[i]-&gt;outbufAcquireFenceFd = disp.outbufAcquireFence-&gt;dup(); &#125; &#125; err = mHwc-&gt;set(mHwc, mNumDisplays, mLists); for (size_t i=0 ; i&lt;mNumDisplays ; i++) &#123; DisplayData&amp; disp(mDisplayData[i]); disp.lastDisplayFence = disp.lastRetireFence; disp.lastRetireFence = Fence::NO_FENCE; if (disp.list) &#123; if (disp.list-&gt;retireFenceFd != -1) &#123; disp.lastRetireFence = new Fence(disp.list-&gt;retireFenceFd); disp.list-&gt;retireFenceFd = -1; &#125; disp.list-&gt;flags &amp;= ~HWC_GEOMETRY_CHANGED; &#125; &#125;&#125;return (status_t)err;&#125; 合成效果图： （六）、Android SurfaceFlinger - VSync工作原理一、VSYNC 总体概念6.1.1、VSYNC 概念VSYNC（Vertical Synchronization）是一个相当古老的概念，对于游戏玩家，它有一个更加大名鼎鼎的中文名字—-垂直同步。“垂直同步(vsync)”指的是显卡的输出帧数和屏幕的垂直刷新率相同，这完全是一个CRT显示器上的概念。其实无论是VSYNC还是垂直同步这个名字，因为LCD根本就没有垂直扫描的这种东西，因此这个名字本身已经没有意义。但是基于历史的原因，这个名称在图形图像领域被沿袭下来。在当下，垂直同步的含义我们可以理解为，使得显卡生成帧的速度和屏幕刷新的速度的保持一致。举例来说，如果屏幕的刷新率为60Hz，那么生成帧的速度就应该被固定在1/60 s。 6.1.2、Android VSYNC — 黄油计划谷歌为解决Android系统流畅性问题。在4.1版本引入了一个重大的改进—Project Butter黄油计划。Project Butter对Android Display系统进行了重构，引入了三个核心元素，即VSYNC、Triple Buffer和Choreographer。VSYNC最重要的作用是防止出现画面撕裂（screentearing）。所谓画面撕裂，就是指一个画面上出现了两帧画面的内容，如下图。为什么会出现这种情况呢？这种情况一般是因为显卡输出帧的速度高于显示器的刷新速度，导致显示器并不能及时处理输出的帧，而最终出现了多个帧的画面都留在了显示器上的问题。这也就是我们所说的画面撕裂。这个图中有三个元素，Display是显示屏幕，GPU和CPU负责渲染帧数据，每个帧以方框表示，并以数字进行编号，如0、1、2等等。VSync用于指导双缓冲区的交换。以时间的顺序来看下将会发生的异常：Step1. Display显示第0帧数据，此时CPU和GPU渲染第1帧画面，而且赶在Display显示下一帧前完成Step2. 因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，正常显示第1帧Step3. 由于某些原因，比如CPU资源被占用，系统没有及时地开始处理第2帧，直到第2个VSync快来前才开始处理Step4. 第2个VSync来时，由于第2帧数据还没有准备就绪，显示的还是第1帧。这种情况被Android开发组命名为“Jank”。Step5. 当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync。所以总的来说，就是屏幕平白无故地多显示了一次第1帧。原因大家应该都看到了，就是CPU没有及时地开始着手处理第2帧的渲染工作，以致“延误军机”。 其实总结上面的这个情况之所以发生，首先的原因就在于第二帧没有及时的绘制（当然即使第二帧及时绘制，也依然可能出现Jank，这就是同时引入三重缓冲的作用。我们将在三重缓冲一节中再讲解这种情况）。那么如何使得第二帧即使被绘制呢？这就是我们在Graphic系统中引入VSYNC的原因，考虑下面这张图： 如上图所示，一旦VSync出现后，立刻就开始执行下一帧的绘制工作。这样就可以大大降低Jank出现的概率。另外，VSYNC引入后，要求绘制也只能在收到VSYNC消息之后才能进行，因此，也就杜绝了另外一种极端情况的出现—-CPU（GPU）一直不停的进行绘制，帧的生成速度高于屏幕的刷新速度，导致生成的帧不能被显示，只能丢弃，这样就出现了丢帧的情况—-引入VSYNC后，绘制的速度就和屏幕刷新的速度保持一致了。 二、VSync信号产生那么VSYNC信号是如何生成的呢？Android系统中VSYNC信号分为两种，一种是硬件生成的信号，一种是软件模拟的信号。硬件信号是由HardwareComposer提供的，HWC封装了相关的HAL层，如果硬件厂商提供的HAL层实现能定时产生VSYNC中断，则直接使用硬件的VSYNC中断，否则HardwareComposer内部会通过VSyncThread来模拟产生VSYNC中断（其实现很简单，就是sleep固定时间，然后唤醒）。 SurfaceFlinger的启动过程中inti()会创建一个HWComposer对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071HWComposer::HWComposer( const sp&lt;SurfaceFlinger&gt;&amp; flinger, EventHandler&amp; handler) : mFlinger(flinger), mFbDev(0), mHwc(0), mNumDisplays(1), mCBContext(new cb_context), mEventHandler(handler), mDebugForceFakeVSync(false) &#123; ... //首先是一些和VSYNC有关的信息的初始化 //因为在硬件支持的情况下，VSYNC的功能就是由HWC提供的 for (size_t i=0 ; i&lt;HWC_NUM_PHYSICAL_DISPLAY_TYPES ; i++) &#123; mLastHwVSync[i] = 0; mVSyncCounts[i] = 0; &#125; //根据配置来看是否需要模拟VSYNC消息 char value[PROPERTY_VALUE_MAX]; property_get(\"debug.sf.no_hw_vsync\", value, \"0\"); mDebugForceFakeVSync = atoi(value); ... // don't need a vsync thread if we have a hardware composer needVSyncThread = false; // always turn vsync off when we start,只是暂时关闭信号，后面会再开启 eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0); //显然，如果需要模拟VSync信号的话，我们需要线程来做这个工作 if (needVSyncThread) &#123; // we don't have VSYNC support, we need to fake it //VSyncThread类的实现很简单，无非就是一个计时器而已，定时发送消息而已 //TODO VSYNC专题 mVSyncThread = new VSyncThread(*this); &#125; ... &#125; HWComposer::HWComposer( const sp&lt;SurfaceFlinger&gt;&amp; flinger, EventHandler&amp; handler) : mFlinger(flinger), mFbDev(0), mHwc(0), mNumDisplays(1), mCBContext(new cb_context), mEventHandler(handler), mDebugForceFakeVSync(false) &#123; ... //首先是一些和VSYNC有关的信息的初始化 //因为在硬件支持的情况下，VSYNC的功能就是由HWC提供的 for (size_t i=0 ; i&lt;HWC_NUM_PHYSICAL_DISPLAY_TYPES ; i++) &#123; mLastHwVSync[i] = 0; mVSyncCounts[i] = 0; &#125; //根据配置来看是否需要模拟VSYNC消息 char value[PROPERTY_VALUE_MAX]; property_get(\"debug.sf.no_hw_vsync\", value, \"0\"); mDebugForceFakeVSync = atoi(value); ... // don't need a vsync thread if we have a hardware composer needVSyncThread = false; // always turn vsync off when we start,只是暂时关闭信号，后面会再开启 eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0); //显然，如果需要模拟VSync信号的话，我们需要线程来做这个工作 if (needVSyncThread) &#123; // we don't have VSYNC support, we need to fake it //VSyncThread类的实现很简单，无非就是一个计时器而已，定时发送消息而已 //TODO VSYNC专题 mVSyncThread = new VSyncThread(*this); &#125; ... &#125; 我们来看下上面这段代码。首先mDebugForceFakeVSync是为了调制，可以通过这个变量设置强制使用软件VSYNC模拟。然后针对不同的屏幕，初始化了他们的mLastHwVSync和mVSyncCounts值。如果硬件支持，那么就把needVSyncThread设置为false，表示不需要软件模拟。接着通过eventControl来暂时的关闭了VSYNC信号，这一点将在下面讲解eventControl时一并讲解。最后，如果需要软件模拟Vsync信号的话，那么我们将通过一个单独的VSyncThread线程来做这个工作(fake VSYNC是这个线程唯一的作用)。我们来看下这个线程。 软件模拟 1234567891011121314151617181920212223242526272829303132333435bool HWComposer::VSyncThread::threadLoop() &#123; const nsecs_t period = mRefreshPeriod; //当前的时间 const nsecs_t now = systemTime(CLOCK_MONOTONIC); //下一次VSYNC到来的时间 nsecs_t next_vsync = mNextFakeVSync; //为了等待下个时间到来应该休眠的时间 nsecs_t sleep = next_vsync - now; //错过了VSYNC的时间 if (sleep &lt; 0) &#123; // we missed, find where the next vsync should be //重新计算下应该休息的时间 sleep = (period - ((now - next_vsync) % period)); //更新下次VSYNC的时间 next_vsync = now + sleep; &#125; //更新下下次VSYNC的时间 mNextFakeVSync = next_vsync + period; struct timespec spec; spec.tv_sec = next_vsync / 1000000000; spec.tv_nsec = next_vsync % 1000000000; int err; do &#123; //纳秒精度级的休眠 err = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;spec, NULL); &#125; while (err&lt;0 &amp;&amp; errno == EINTR); if (err == 0) &#123; //休眠之后，到了该发生VSYNC的时间了 mHwc.mEventHandler.onVSyncReceived(0, next_vsync); &#125; return true; &#125; 这个函数其实很简单，无非就是一个简单的时间计算，计算过程我已经写在了程序注释里面。总之到了应该发生VSYNC信号的时候，就调用了mHwc.mEventHandler.onVSyncReceived(0, next_vsync)函数来通知VSYNC的到来。 我们注意到mEventHandler实际上是在HWC创建时被传入的，我们来看下HWC创建时的代码. 123456mHwc = new HWComposer(this, *static_cast&lt;HWComposer::EventHandler *&gt;(this)); class SurfaceFlinger : public BnSurfaceComposer, private IBinder::DeathRecipient, private HWComposer::EventHandler 可以看到这个mEventHandler实际上就是SurfaceFlinger。也就是说，VSYNC信号到来时，SurfaceFlinger的onVSyncReceived函数处理了这个消息。这里我们暂时先不展开SurfaceFlinger内的逻辑处理，等我们下面分析完硬件实现后，一并进行分析 硬件实现上面我们讲了软件如何模拟一个VSYNC信号并通知SurfaceFlinger,那么硬件又是如何实现这一点的呢？我们再一次回到HWC的创建过程中来： 123456789101112131415if (mHwc) &#123; ALOGE(\"Lee Using %s version %u.%u\", HWC_HARDWARE_COMPOSER, (hwcApiVersion(mHwc) &gt;&gt; 24) &amp; 0xff, (hwcApiVersion(mHwc) &gt;&gt; 16) &amp; 0xff); if (mHwc-&gt;registerProcs) &#123; mCBContext-&gt;hwc = this; mCBContext-&gt;procs.invalidate = &amp;hook_invalidate; mCBContext-&gt;procs.vsync = &amp;hook_vsync; if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) mCBContext-&gt;procs.hotplug = &amp;hook_hotplug; else mCBContext-&gt;procs.hotplug = NULL; memset(mCBContext-&gt;procs.zero, 0, sizeof(mCBContext-&gt;procs.zero)); mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs); &#125; 来看下上面这段实现。当HWC有vsync信号生成时，硬件模块会通过procs.vsync来通知软件部分，因此也就是调用了hook_vsync函数。 123456789101112131415void HWComposer::hook_vsync(const struct hwc_procs* procs, int disp, int64_t timestamp) &#123; cb_context* ctx = reinterpret_cast&lt;cb_context*&gt;( const_cast&lt;hwc_procs_t*&gt;(procs)); ctx-&gt;hwc-&gt;vsync(disp, timestamp); &#125; void HWComposer::vsync(int disp, int64_t timestamp) &#123; //只有真实的硬件设备才会产生VSYNC if (uint32_t(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123; &#123; mLastHwVSync[disp] = timestamp; &#125; mEventHandler.onVSyncReceived(disp, timestamp); &#125; 我们发现最后殊途同归，硬件信号最终也通过onVSyncReceived函数通知到了SurfaceFlinger了。下面我们来分析下SurfaceFlinger的处理过程。 三、Surfaceflinger对VSYNC消息的处理先来直接看下Surfaceflinger的onVSyncReceived函数： 12345678910111213141516void SurfaceFlinger::onVSyncReceived(int32_t type, nsecs_t timestamp) &#123; bool needsHwVsync = false; &#123; // Scope for the lock Mutex::Autolock _l(mHWVsyncLock); if (type == 0 &amp;&amp; mPrimaryHWVsyncEnabled) &#123; needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp); &#125; &#125; if (needsHwVsync) &#123; enableHardwareVsync(); &#125; else &#123; disableHardwareVsync(false); &#125;&#125; mPrimaryDispSync是什么？addResyncSample有什么作用？要回答这三个问题，我们首先还是得回到SurfaceFlinger的init函数中来。 6.3.1、Surfaceflinger.init()先看一下总体flow： 123456789101112131415161718192021void SurfaceFlinger::init() &#123; ALOGI( &quot;SurfaceFlinger&apos;s main thread ready to run. &quot; &quot;Initializing graphics H/W...&quot;); &#123; ...... // start the EventThread sp&lt;VSyncSource&gt; vsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, vsyncPhaseOffsetNs, true, &quot;app&quot;); mEventThread = new EventThread(vsyncSrc, *this); sp&lt;VSyncSource&gt; sfVsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, sfVsyncPhaseOffsetNs, true, &quot;sf&quot;); mSFEventThread = new EventThread(sfVsyncSrc, *this); mEventQueue.setEventThread(mSFEventThread); ...... &#125; ...... mEventControlThread = new EventControlThread(this); mEventControlThread-&gt;run(&quot;EventControl&quot;, PRIORITY_URGENT_DISPLAY); ......&#125; 2个EventThread对象分别是mEventThread，给app用，mSFEventThread，给surfaceflinger自己用。下面给出这4个Thread关系图。 这两个DispSyncSource就是KK引入的重大变化。Android 4.4(KitKat)引入了VSync的虚拟化，即把硬件的VSync信号先同步到一个本地VSync模型中，再从中一分为二，引出两条VSync时间与之有固定偏移的线程。示意图如下： Google这样修改的目的又是什么呢？=在当前三重缓冲区的架构下，即对于一帧内容，先等App UI画完了，SurfaceFlinger再出场对其进行合并渲染后放入framebuffer，最后整到屏幕上。而现有的VSync模型是让大家一起开始干活。这个架构其实会产生一个问题，因为App和SurfaceFlinger被同时唤醒，导致他们二者总是一起工作，必然导致VSync来临的时刻，这二者之间产生了CPU资源的抢占。因此，谷歌给这两个工作都加上一个小小的延迟，让这两个工作并不是同时被唤醒，这样大家就可以错开使用资源的高峰期，提高工作的效率。 这两个延迟，其实就分别对应上面代码中的vsyncSrc（绘制延迟）和sfVsyncSrc（合成延迟）。在创建了两个DispSyncSource变量后，我们使用它们来初始化了两个EventThread。下面我们来详细看下EventThread的创建流程： 123456789101112131415161718192021222324EventThread::EventThread(const sp&lt;VSyncSource&gt;&amp; src, SurfaceFlinger&amp; flinger) : mVSyncSource(src), mFlinger(flinger), mUseSoftwareVSync(false), mVsyncEnabled(false), mDebugVsyncEnabled(false), mVsyncHintSent(false) &#123; for (int32_t i=0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123; mVSyncEvent[i].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC; mVSyncEvent[i].header.id = 0; mVSyncEvent[i].header.timestamp = 0; mVSyncEvent[i].vsync.count = 0; &#125; struct sigevent se; se.sigev_notify = SIGEV_THREAD; se.sigev_value.sival_ptr = this; se.sigev_notify_function = vsyncOffCallback; se.sigev_notify_attributes = NULL; timer_create(CLOCK_MONOTONIC, &amp;se, &amp;mTimerId);&#125;void EventThread::onFirstRef() &#123; run(\"EventThread\", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);&#125; EventThread的构造函数很简单。重点是它的onFirstRef函数启动了一个EventThread线程，于是下面的代码才是重点： 123456789101112131415bool EventThread::threadLoop() &#123; DisplayEventReceiver::Event event; Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections; signalConnections = waitForEvent(&amp;event); // dispatch events to listeners... const size_t count = signalConnections.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Connection&gt;&amp; conn(signalConnections[i]); // now see if we still need to report this event status_t err = conn-&gt;postEvent(event); ...... &#125; return true;&#125; 上面的函数本身并不复杂，其中调用了一个waitForEvent的函数。这个函数相当之长，为了防止代码展开太多，我们这里暂时不再详细分析这个函数。我们目前只需要知道这个函数的最重要的作用是等待Event的到来，并且查找对event感兴趣的监听者，而在没有event到来时，线程处于休眠状态，等待event的唤醒（我们将下一篇VSYNC的接收和处理中展开分析这个函数）。这样，EventThread线程就运行起来，处在等待被event唤醒的状态下。MessageQueue和EventThread建立连接简单说明完EventThread之后，我们再次回到SurfaceFlinger的init过程中来。回到init()函数代码中来：将SurfaceFlinger的MessageQueue真正和我们刚才创建的EventThread建立起了连接，这样SurfaceFlinger才能真正接收到来自HWC的VSYNC信号。我们来看下这段代码： 12345678void MessageQueue::setEventThread(const sp&lt;EventThread&gt;&amp; eventThread) &#123; mEventThread = eventThread; mEvents = eventThread-&gt;createEventConnection(); mEventTube = mEvents-&gt;getDataChannel(); mLooper-&gt;addFd(mEventTube-&gt;getFd(), 0, ALOOPER_EVENT_INPUT, MessageQueue::cb_eventReceiver, this); &#125; 这里代码逻辑其实很简单，就是创建了一个到EventThread的连接，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。向Eventhread注册一个事件的监听者——createEventConnection在SurfaceFlinger的init函数中，我们调用了mEventQueue.setEventThread(mSFEventThread)函数，我们在前面一章中已经提到过，这个函数将SurfaceFlinger的MessageQueue真正和我们刚才创建的EventThread建立起了连接。我们来看下这段代码： 12345678910111213141516sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() const &#123; return new Connection(const_cast&lt;EventThread*&gt;(this)); &#125; EventThread::Connection::Connection( const sp&lt;EventThread&gt;&amp; eventThread) : count(-1), mEventThread(eventThread), mChannel(new BitTube()) &#123; &#125; void EventThread::Connection::onFirstRef() &#123; mEventThread-&gt;registerDisplayEventConnection(this); &#125; status_t EventThread::registerDisplayEventConnection( const sp&lt;EventThread::Connection&gt;&amp; connection) &#123; mDisplayEventConnections.add(connection); mCondition.broadcast(); &#125; 这个函数会导致一个Connection类的创建，而这个connection类会被保存在EventThread下的一个容器内。通过createEventConnection这样一个简单的方法，我们其实就注册了一个事件的监听者，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。 6.3.2、VSync信号的处理我们在前面一章也提到了无论是软件方式还是硬件方式，SurfaceFlinger收到VSync信号后，处理函数都是onVSyncReceived函数： VSync消息处理——addResyncSample 12345678bool DispSync::addResyncSample(nsecs_t timestamp) &#123; size_t idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES; mResyncSamples[idx] = timestamp; ...... updateModelLocked(); .......&#125; 粗略浏览下这个函数，发现前半部分其实在做一些简单的计数统计，重点实现显然是updateModelLocked函数： 123456789101112131415161718192021222324252627282930void DispSync::updateModelLocked() &#123; if (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123; nsecs_t durationSum = 0; for (size_t i = 1; i &lt; mNumResyncSamples; i++) &#123; size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES; size_t prev = (idx + MAX_RESYNC_SAMPLES - 1) % MAX_RESYNC_SAMPLES; durationSum += mResyncSamples[idx] - mResyncSamples[prev]; &#125; mPeriod = durationSum / (mNumResyncSamples - 1); double sampleAvgX = 0; double sampleAvgY = 0; double scale = 2.0 * M_PI / double(mPeriod); for (size_t i = 0; i &lt; mNumResyncSamples; i++) &#123; size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES; nsecs_t sample = mResyncSamples[idx]; double samplePhase = double(sample % mPeriod) * scale; sampleAvgX += cos(samplePhase); sampleAvgY += sin(samplePhase); &#125; sampleAvgX /= double(mNumResyncSamples); sampleAvgY /= double(mNumResyncSamples); mPhase = nsecs_t(atan2(sampleAvgY, sampleAvgX) / scale); ...... mThread-&gt;updateModel(mPeriod, mPhase); &#125; &#125; 不得不说，前面大段的数学计算让人有些困惑，我们暂且跳过，先分析下主线流程，也就是mThread-&gt;updateModel(mPeriod, mPhase)这个调用： DispSyncThread.updateModel的用途 123456void updateModel(nsecs_t period, nsecs_t phase) &#123; Mutex::Autolock lock(mMutex); mPeriod = period; mPhase = phase; mCond.signal(); &#125; updateModel是DispSyncThread类的函数，这个函数本身代码很短，其实它的主要作用是mCond.signal发送一个信号给等待中的线程。那么究竟是谁在等待这个条件呢？其实等待这个条件的正是DispSyncThread的循环函数： 12345678910111213141516171819202122232425262728virtual bool threadLoop() &#123; status_t err; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); nsecs_t nextEventTime = 0; while (true) &#123; Vector&lt;CallbackInvocation&gt; callbackInvocations; nsecs_t targetTime = 0; &#123; // Scope for lock Mutex::Autolock lock(mMutex); ...... if (mPeriod == 0) &#123; err = mCond.wait(mMutex); ...... &#125; nextEventTime = computeNextEventTimeLocked(now); targetTime = nextEventTime; ...... &#125; now = systemTime(SYSTEM_TIME_MONOTONIC); ...... callbackInvocations = gatherCallbackInvocationsLocked(now); &#125; if (callbackInvocations.size() &gt; 0) &#123; fireCallbackInvocations(callbackInvocations); &#125; &#125; return false; &#125; 大量的时间相关的计算和状态的转变我们不再深入研究，我们来看下这个线程被通知唤醒之后做的两个主要的函数的处理，gatherCallbackInvocationsLocked()和fireCallbackInvocations()。 gatherCallbackInvocationsLocked()的代码其实很简单： 12345678910111213141516Vector&lt;CallbackInvocation&gt; gatherCallbackInvocationsLocked(nsecs_t now) &#123; Vector&lt;CallbackInvocation&gt; callbackInvocations; nsecs_t ref = now - mPeriod; for (size_t i = 0; i &lt; mEventListeners.size(); i++) &#123; nsecs_t t = computeListenerNextEventTimeLocked(mEventListeners[i], ref); if (t &lt; now) &#123; CallbackInvocation ci; ci.mCallback = mEventListeners[i].mCallback; ci.mEventTime = t; callbackInvocations.push(ci); mEventListeners.editItemAt(i).mLastEventTime = t; &#125; &#125; return callbackInvocations; &#125; 其实就是从mEventListeners取出之前注册的事件监听者，放入callbackInvocations中，等待后面的调用。至于监听者从何处而来？在waitforevent时通过enableVSyncLocked注册的。 继续看下fireCallbackInvocations()函数： 12345void fireCallbackInvocations(const Vector&lt;CallbackInvocation&gt;&amp; callbacks) &#123; for (size_t i = 0; i &lt; callbacks.size(); i++) &#123; callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime); &#125; &#125;` 我们目前只分析主线的走向,接下来调用了DispSyncSource的onDispSyncEvent在： 1234567891011121314151617virtual void onDispSyncEvent(nsecs_t when) &#123; sp&lt;VSyncSource::Callback&gt; callback; &#123; callback = mCallback; &#125; if (callback != NULL) &#123; callback-&gt;onVSyncEvent(when); &#125; &#125; void EventThread::onVSyncEvent(nsecs_t timestamp) &#123; Mutex::Autolock _l(mLock); mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC; mVSyncEvent[0].header.id = 0; mVSyncEvent[0].header.timestamp = timestamp; mVSyncEvent[0].vsync.count++; mCondition.broadcast(); &#125; 我们看到这里mCondition.broadcas发出了命令，那么EventThread中waitforEvent的等待就会被唤醒。而一旦唤醒，我们就回到了EventThread的loop中，我们来看下代码： 123456789101112131415bool EventThread::threadLoop() &#123; DisplayEventReceiver::Event event; Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections; signalConnections = waitForEvent(&amp;event); // dispatch events to listeners... const size_t count = signalConnections.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Connection&gt;&amp; conn(signalConnections[i]); // now see if we still need to report this event status_t err = conn-&gt;postEvent(event); ...... &#125; return true; &#125; 这里主要就是通过conn-&gt;postEvent来分发事件： 12345678910status_t EventThread::Connection::postEvent( const DisplayEventReceiver::Event&amp; event) &#123; ssize_t size = DisplayEventReceiver::sendEvents(mChannel, &amp;event, 1); return size &lt; 0 ? status_t(size) : status_t(NO_ERROR); &#125; ssize_t DisplayEventReceiver::sendEvents(const sp&lt;BitTube&gt;&amp; dataChannel, Event const* events, size_t count) &#123; return BitTube::sendObjects(dataChannel, events, count); &#125; 其实看到这里的BitTube我们就明白了，在本文开始时候我们提到： 通过createEventConnection这样一个简单的方法，我们其实就注册了一个事件的监听者，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。 所以我们这里可以来看看MessageQueue::cb_eventReceiver函数了： 123456789101112131415161718int MessageQueue::cb_eventReceiver(int fd, int events, void* data) &#123; MessageQueue* queue = reinterpret_cast&lt;MessageQueue *&gt;(data); return queue-&gt;eventReceiver(fd, events); &#125; int MessageQueue::eventReceiver(int fd, int events) &#123; ssize_t n; DisplayEventReceiver::Event buffer[8]; while ((n = DisplayEventReceiver::getEvents(mEventTube, buffer, 8)) &gt; 0) &#123; for (int i=0 ; i&lt;n ; i++) &#123; if (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123; mHandler-&gt;dispatchInvalidate(); break; &#125; &#125; &#125; return 1; &#125; 我们看到收到消息之后MessageQueue对消息进行了分发，我们目前走的是dispatchInvalidate()。 123456789101112131415161718192021222324252627282930313233343536373839void MessageQueue::Handler::dispatchInvalidate() &#123; if ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == 0) &#123; mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::INVALIDATE)); &#125; &#125; void MessageQueue::Handler::handleMessage(const Message&amp; message) &#123; switch (message.what) &#123; case INVALIDATE: android_atomic_and(~eventMaskInvalidate, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; case REFRESH: android_atomic_and(~eventMaskRefresh, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; case TRANSACTION: android_atomic_and(~eventMaskTransaction, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; &#125; &#125; void SurfaceFlinger::onMessageReceived(int32_t what) &#123; ATRACE_CALL(); switch (what) &#123; case MessageQueue::TRANSACTION: handleMessageTransaction(); break; case MessageQueue::INVALIDATE: handleMessageTransaction(); handleMessageInvalidate(); signalRefresh(); break; case MessageQueue::REFRESH: handleMessageRefresh(); break; &#125; &#125; 到了这里，就进入了SurfaceFlinger的处理流程，我们看到对于INVALIDATE的消息，实际上系统在处理过程中实际还是会发送一个Refresh消息。 6.4、App向Eventhread注册一个事件的监听者—createEventConnection()在ViewRootImpl的构造函数中会实例化Choreographer对象 1234public ViewRootImpl(Context context, Display display) &#123; . . . . . mChoreographer = Choreographer.getInstance(); &#125; 在mChoreographer 的构造函数中实例化FrameDisplayEventReceiver对象 1234private Choreographer(Looper looper) &#123; . . . . . . mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper) : null; &#125; 在FrameDisplayEventReceiver的父类构造函数中会调用到，android_view_DisplayEventReceiver.cpp中的nativeInit方法,在nativeInit方法中有如下过程 1234567static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject messageQueueObj) &#123; . . . . . . sp&lt;NativeDisplayEventReceiver&gt; receiver = new NativeDisplayEventReceiver(env, receiverWeak, messageQueue); status_t status = receiver-&gt;initialize(); . . . . . . 创建NativeDisplayEventReceiver类 类型指针在NativeDisplayEventReceiver的构造函数中会调用DisplayEventReceiver类的无参构造函数实例化成员mReceiver； 123456789DisplayEventReceiver::DisplayEventReceiver() &#123; sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService()); if (sf != NULL) &#123; mEventConnection = sf-&gt;createDisplayEventConnection(); if (mEventConnection != NULL) &#123; mDataChannel = mEventConnection-&gt;getDataChannel(); &#125; &#125;&#125; 在这段代码中获取Surfaceflinger服务的代理对象，然后通过Binder IPC创建BpDisplayEventConnection对象该函数经由BnSurfaceComposer.onTransact函数辗转调用到SurfaceFlinger.createDisplayEventConnection函数： 123sp&lt;IDisplayEventConnection&gt; SurfaceFlinger::createDisplayEventConnection() &#123; return mEventThread-&gt;createEventConnection();&#125; 出现了熟悉的面孔mEventThread，该对象是一个EventThread对象，该对象在SurfaceFlinger.init函数里面创建，但是创建运行以后，貌似还没有进行任何的动作，这里调用createEventConnection函数： 123sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() const &#123; return new Connection(const_cast&lt;EventThread*&gt;(this));&#125; 然后mEventConnection-&gt;getDataChannel()方法再次通过Binder IPC创建 BitTube对象mDataChannel ，在Binder IPC创建mDataChannel 过程中会从服务端EventThread::Connection::Connection中（在EventThread类中定义）接收一个socketpair创建的FIFO文件描述符； EventThread::Connection::Connection创建描述符的代码：Connection构造函数调用BitTube的无参构造函数，在BitTube的构造函数中调用init函数； 123456789101112131415161718void BitTube::init(size_t rcvbuf, size_t sndbuf) &#123; int sockets[2]; if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets) == 0) &#123; size_t size = DEFAULT_SOCKET_BUFFER_SIZE; setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, sizeof(rcvbuf)); setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;sndbuf, sizeof(sndbuf)); // sine we don't use the \"return channel\", we keep it small... setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;size, sizeof(size)); setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;size, sizeof(size)); fcntl(sockets[0], F_SETFL, O_NONBLOCK); fcntl(sockets[1], F_SETFL, O_NONBLOCK); mReceiveFd = sockets[0]; mSendFd = sockets[1]; &#125; else &#123; mReceiveFd = -errno; ALOGE(\"BitTube: pipe creation failed (%s)\", strerror(-mReceiveFd)); &#125;&#125; 调用到NativeDisplayEventReceiver类的父类DisplayEventDispatcher中的initialize()方法， 将BpDisplayEventConnection对象获取到的mDataChannel （BitTube类型）中的文件描述符添加到UI主线程Looper的epoll中， 当文件描述符中被写入数据时，该epoll_wait会被唤醒； 直接看代码： 123456789101112status_t NativeDisplayEventReceiver::initialize() &#123; status_t result = mReceiver.initCheck(); if (result) &#123; ALOGW(\"Failed to initialize display event receiver, status=%d\", result); return result; &#125; int rc = mMessageQueue-&gt;getLooper()-&gt;addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT, this, NULL); if (rc &lt; 0) &#123; return UNKNOWN_ERROR; &#125; return OK;&#125; 这里的主要代码是mMessageQueue-&gt;getLooper()-&gt;addFd()这一行，其中的参数mReceiver.getFd()返回的是在创建NativeDisplayEventReceiver时从SurfaceFlinger服务端接收回来的socket接收端描述符，前面分析到mMessageQueue是与当前应用线程关联的java层的MessageQueue对应的native层的MessageQueue对象，下面看一下Looper.addFd这个函数，上面调用时传进来的this指针对应的是一个NativeDisplayEventReceiver对象，该类继承了LooperCallback： 1234567891011121314151617181920212223242526272829303132333435363738int Looper::addFd(int fd, int ident, int events, Looper_callbackFunc callback, void* data) &#123; return addFd(fd, ident, events, callback ? new SimpleLooperCallback(callback) : NULL, data);&#125;int Looper::addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data) &#123; int epollEvents = 0; if (events &amp; EVENT_INPUT) epollEvents |= EPOLLIN; if (events &amp; EVENT_OUTPUT) epollEvents |= EPOLLOUT; &#123; // acquire lock AutoMutex _l(mLock); Request request; request.fd = fd; request.ident = ident; request.callback = callback; request.data = data; struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union eventItem.events = epollEvents; eventItem.data.fd = fd; ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &lt; 0) &#123; int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem); if (epollResult &lt; 0) &#123; &#125; mRequests.add(fd, request); &#125; else &#123; int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem); if (epollResult &lt; 0) &#123; return -1; &#125; mRequests.replaceValueAt(requestIndex, request); &#125; &#125; // release lock return 1;&#125; 首先将上面传进来的NativeDisplayEventReceiver对象封装成一个SimpleLooperCallback对象，调用下面的addFd函数的时候主要步骤如下：（1）创建一个struct epoll_event结构体对象，将对应的内存全部用清0，并作对应的初始化；（2）查询通过addFd方法已经添加到epoll中监听的文件描述符；（3）查询不到的话，则调用epoll_ctl方法设置EPOLL_CTL_ADD属性将对应的文件描述符添加到epoll监听的描述符中；（4）根据前面addFd传入的参数EVENT_INPUT，说明当前应用线程的native层的Looper对象中的epoll机制已经开始监听来自于SurfaceFlinger服务端socket端的写入事件。 6.5、App请求Vsync信号前面讲解ViewRootImpl.setView()的时候，因涉及到Vsync信号知识，requestLayout()没有具体讲解，现在继续。12345678910111213Overridepublic void requestLayout() &#123; scheduleTraversals();&#125;void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); ...... &#125;&#125; [-&gt;Choreographer.java] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void postCallback(int callbackType, Runnable action, Object token) &#123; postCallbackDelayed(callbackType, action, token, 0);&#125;public void postCallbackDelayed(int callbackType, Runnable action, Object token, long delayMillis) &#123; ...... postCallbackDelayedInternal(callbackType, action, token, delayMillis);&#125;private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; ...... synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; //将要执行的回调封装成CallbackRecord对象，保存到mCallbackQueues数组中 mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125;private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; if (USE_VSYNC) &#123; if (isRunningOnLooperThreadLocked()) &#123; scheduleVsyncLocked(); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; final long nextFrameTime = Math.max( mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now); Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125; 消息处理： 12345678910111213141516171819202122232425 private final class FrameHandler extends Handler &#123; public FrameHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_DO_SCHEDULE_VSYNC: doScheduleVsync(); break; &#125; &#125;&#125; void doScheduleVsync() &#123; synchronized (mLock) &#123; if (mFrameScheduled) &#123; scheduleVsyncLocked(); &#125; &#125;&#125;private void scheduleVsyncLocked() &#123; //申请Vsync信号 mDisplayEventReceiver.scheduleVsync(); &#125; 在该函数中考虑了两种情况，一种是系统没有使用Vsync机制，在这种情况下，首先根据屏幕刷新频率计算下一次刷新时间，通过异步消息方式延时执行doFrame()函数实现屏幕刷新。如果系统使用了Vsync机制，并且当前线程具备消息循环，则直接请求Vsync信号，否则就通过主线程来请求Vsync信号。 6.5.1、Vsync请求过程我们知道在Choreographer构造函数中，构造了一个FrameDisplayEventReceiver对象，用于请求并接收Vsync信号，Vsync信号请求过程如下： 1234private void scheduleVsyncLocked() &#123; //申请Vsync信号 mDisplayEventReceiver.scheduleVsync(); &#125; [-&gt;DisplayEventReceiver.java] 12345678public void scheduleVsync() &#123; if (mReceiverPtr == 0) &#123; Log.w(TAG, \"Attempted to schedule a vertical sync pulse but the display event \" + \"receiver has already been disposed.\"); &#125; else &#123; nativeScheduleVsync(mReceiverPtr); &#125;&#125; [-&gt;android_view_DisplayEventReceiver.cpp ] 12345678910static void nativeScheduleVsync(JNIEnv* env, jclass clazz, jlong receiverPtr) &#123;sp&lt;NativeDisplayEventReceiver&gt; receiver = reinterpret_cast&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);status_t status = receiver-&gt;scheduleVsync();if (status) &#123; String8 message; message.appendFormat(\"Failed to schedule next vertical sync pulse. status=%d\", status); jniThrowRuntimeException(env, message.string());&#125;&#125; VSync请求过程又转交给了DisplayEventReceiver：[-&gt;DisplayEventReceiver.cpp] 1234567status_t DisplayEventReceiver::requestNextVsync() &#123;if (mEventConnection != NULL) &#123; mEventConnection-&gt;requestNextVsync(); return NO_ERROR;&#125;return NO_INIT;&#125; 这里的mEventConnection也是前面创建native层对象NativeDisplayEventReceiver时创建的，实际对象是一个BpDisplayEventConnection对象，也就是一个Binder客户端，对应的Binder服务端BnDisplayEventConnection是一个EventThread::Connection对象，对应的BpDisplayEventConnection.requestNextVsync函数和BnDisplayEventConnection.onTransact(REQUEST_NEXT_VSYNC)函数没有进行特别的处理，下面就调用到EventThread::Connection.requestNextVsync函数，从BnDisplayEventConnection.onTransact(REQUEST_NEXT_VSYNC)开始已经从用户进程将需要垂直同步信号的请求发送到了SurfaceFlinger进程，下面的函数调用开始进入SF进程： 123void EventThread::Connection::requestNextVsync() &#123; mEventThread-&gt;requestNextVsync(this); &#125; 辗转调用到EventThread.requestNextVsync函数，注意里面传了参数this，也就是当前的EventThread::Connection对象，需要明确的是，这里的mEventThread对象是创建EventThread::Connection对象的时候保存的，对应的是SurfaceFlinger对象的里面的mEventThread成员，该对象是一个在SurfaceFlinger.init里面创建并启动的线程对象，可见设计的时候就专门用这个SurfaceFlinger.mEventThread线程来接收来自应用进程的同步信号请求，每来一个应用进程同步信号请求，就通过SurfaceFlinger.mEventThread创建一个EventThread::Connection对象，并通过EventThread.registerDisplayEventConnection函数将创建的EventThread::Connection对象保存到EventThread.mDisplayEventConnections里面，上面有调用到了EventThread.requestNextVsync函数： 1234567void EventThread::requestNextVsync(const sp&lt;EventThread::Connection&gt;&amp; connection) &#123; Mutex::Autolock _l(mLock); if (connection-&gt;count &lt; 0) &#123; connection-&gt;count = 0; mCondition.broadcast(); &#125;&#125; 传进来的是一个前面创建的EventThread::Connection对象，里面判断到了EventThread::Connection.count成员变量，看一下EventThread::Connection构造函数中初始变量的值： 123EventThread::Connection::Connection(const sp&lt;EventThread&gt;&amp; eventThread) : count(-1), mEventThread(eventThread), mChannel(new BitTube())&#123;&#125; 可以看到初始值是-1，这个值就是前面那个问题的关键，EventThread::Connection.count标示了这次应用进程的垂直同步信号的请求是一次性的，还是多次重复的，看一下注释里面对于这个变量的说明： 1234// count &gt;= 1 : continuous event. count is the vsync rate// count == 0 : one-shot event that has not fired// count ==-1 : one-shot event that fired this round / disabledint32_t count; 很清楚的说明了，count = 0说明当前的垂直同步信号请求是一个一次性的请求，并且还没有被处理。上面EventThread::requestNextVsync里面将count设置成0，同时调用了mCondition.broadcast()唤醒所有正在等待mCondition的线程，这个会触发EventThread.waitForEvent函数从： 1mCondition.wait(mLock); 中醒来，醒来之后经过一轮do…while循环就会返回，返回以后调用序列如下：（1）EventThread::Connection.postEvent(event)（2）DisplayEventReceiver::sendEvents(mChannel, &amp;event, 1)，mChannel参数就是前面创建DisplayEventReceiver是创建的BitTube对象（3）BitTube::sendObjects(dataChannel, events, count)，static函数，通过dataChannel指向BitTube对象最终调用到BitTube::sendObjects函数： 12345ssize_t BitTube::sendObjects(const sp&lt;BitTube&gt;&amp; tube, void const* events, size_t count, size_t objSize)&#123; const char* vaddr = reinterpret_cast&lt;const char*&gt;(events); ssize_t size = tube-&gt;write(vaddr, count*objSize); return size &lt; 0 ? size : size / static_cast&lt;ssize_t&gt;(objSize);&#125; 继续调用到BitTube::write函数： 123456789ssize_t BitTube::write(void const* vaddr, size_t size)&#123; ssize_t err, len; do &#123; len = ::send(mSendFd, vaddr, size, MSG_DONTWAIT | MSG_NOSIGNAL); // cannot return less than size, since we're using SOCK_SEQPACKET err = len &lt; 0 ? errno : 0; &#125; while (err == EINTR); return err == 0 ? len : -err;&#125; 这里调用到了::send函数，::是作用域描述符，如果前面没有类名之类的，代表的就是全局的作用域，也就是调用全局函数send，这里很容易就能想到这是一个socket的写入函数，也就是将event事件数据写入到BitTube中互联的socket中，这样在另一端马上就能收到写入的数据，前面分析到这个BitTube的socket的两端连接着SurfaceFlinger进程和应用进程，也就是说通过调用BitTube::write函数，将最初由SurfaceFlinger捕获到的垂直信号事件经由BitTube中互联的socket从SurfaceFlinger进程发送到了应用进程中BitTube的socket接收端。下面就要分析应用进程是如何接收并使用这个垂直同步信号事件的。 6.5.2、应用进程接收VSync6.5.2.1、解析VSync事件VSync同步信号事件已经发送到用户进程中的socket接收端，在前面NativeDisplayEventReceiver.initialize中分析到应用进程端的socket接收描述符已经被添加到Choreographer所在线程的native层的Looper机制中，在epoll中监听EPOLLIN事件，当socket收到数据后，epoll会马上返回，下面分步骤看一下Looper.pollInner()数：（1）epoll_wait 12struct epoll_event eventItems[EPOLL_MAX_EVENTS];int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); 在监听到描述符对应的事件后，epoll_wait会马上返回，并将产生的具体事件类型写入到参数eventItems里面，最终返回的eventCount是监听到的事件的个数（2）事件分析 12345678910111213141516171819202122232425for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeReadPipeFd) &#123; //判断是不是pipe读管道的事件 这里如果是EventThread,这里就是一个socket的描述符,而不是mWakeReadPipeFd if (epollEvents &amp; EPOLLIN) &#123; awoken(); // 清空读管道中的数据 &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents); &#125; &#125; else &#123; //EventThread接收到同步信号走的这里 ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) &#123; int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; pushResponse(events, mRequests.valueAt(requestIndex)); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on fd %d that is \" \"no longer registered.\", epollEvents, fd); &#125; &#125; &#125; Looper目前了解到的主要监听的文件描述符种类有两种：1）消息事件，epoll_wait监听pipe管道的接收端描述符mWakeReadPipeFd2）与VSync信号，epoll_wait监听socket接收端描述符，并在addFd的过程中将相关的信息封装在一个Request结构中，并以fd为key存储到了mRequests中，具体可以回过头看3.1.2关于addFd的分析；因此，上面走的是else的分支，辨别出当前的事件类型后，调用pushResponse： 123456void Looper::pushResponse(int events, const Request&amp; request) &#123; Response response; response.events = events; response.request = request; //复制不是引用，调用拷贝构造函数 mResponses.push(response);&#125; 该函数将Request和events封装在一个Response对象里面，存储到了mResponses里面，也就是mResponses里面放的是“某某fd上接收到了类别为events的时间”记录，继续向下看Looper.pollInner函数（3）事件分发处理 1234567891011121314151617// Invoke all response callbacks.for (size_t i = 0; i &lt; mResponses.size(); i++) &#123; Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) &#123; removeFd(fd); &#125; // Clear the callback reference in the response structure promptly because we // will not clear the response vector itself until the next poll. response.request.callback.clear(); result = POLL_CALLBACK; &#125;&#125; 这里的response.request是从pushResponse里面复制过来的，里面的request对应的Request对象是在addFd的时候创建的，ident成员就是POLL_CALLBACK，所以继续走到response.request.callback-&gt;handleEvent这个函数，回忆一下3.1.2里面的addFd函数，这里的callback实际上是一个SimpleLooperCallback（定义在Looper.cpp中）对象，看一下里面的handleEvent函数： 123int SimpleLooperCallback::handleEvent(int fd, int events, void* data) &#123; return mCallback(fd, events, data);&#125; 这里的mCallback就是当时在addFd的时候传进来的callBack参数，实际上对应的就是NativeDisplayEventReceiver对象本身，因此最终就将垂直同步信号事件分发到了NativeDisplayEventReceiver.handleEvent函数中。 6.5.3、VSync事件分发调用到NativeDisplayEventReceiver.handleEvent函数，该函数定义在android_view_DisplayEventReceiver.cpp中，直接列出该函数： 1234567891011121314151617181920212223int NativeDisplayEventReceiver::handleEvent(int receiveFd, int events, void* data) &#123; if (events &amp; (Looper::EVENT_ERROR | Looper::EVENT_HANGUP)) &#123; ALOGE(\"Display event receiver pipe was closed or an error occurred. \" \"events=0x%x\", events); return 0; // remove the callback &#125; if (!(events &amp; Looper::EVENT_INPUT)) &#123; ALOGW(\"Received spurious callback for unhandled poll event. \" \"events=0x%x\", events); return 1; // keep the callback &#125; // Drain all pending events, keep the last vsync. nsecs_t vsyncTimestamp; int32_t vsyncDisplayId; uint32_t vsyncCount; if (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123; ALOGV(\"receiver %p ~ Vsync pulse: timestamp=%\" PRId64 \", id=%d, count=%d\", this, vsyncTimestamp, vsyncDisplayId, vsyncCount); mWaitingForVsync = false; dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount); &#125; return 1; // keep the callback&#125; 首先判断事件是不是正确的Looper::EVENT_INPUT事件，然后调用到NativeDisplayEventReceiver.processPendingEvents函数： 123456789101112131415161718192021222324252627282930bool NativeDisplayEventReceiver::processPendingEvents(nsecs_t* outTimestamp, int32_t* outId, uint32_t* outCount) &#123; bool gotVsync = false; DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE]; ssize_t n; while ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; 0) &#123; for (ssize_t i = 0; i &lt; n; i++) &#123; const DisplayEventReceiver::Event&amp; ev = buf[i]; switch (ev.header.type) &#123; case DisplayEventReceiver::DISPLAY_EVENT_VSYNC: // Later vsync events will just overwrite the info from earlier // ones. That's fine, we only care about the most recent. gotVsync = true; *outTimestamp = ev.header.timestamp; *outId = ev.header.id; *outCount = ev.vsync.count; break; case DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG: dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected); break; default: ALOGW(\"receiver %p ~ ignoring unknown event type %#x\", this, ev.header.type); break; &#125; &#125; &#125; if (n &lt; 0) &#123; ALOGW(\"Failed to get events from display event receiver, status=%d\", status_t(n)); &#125; return gotVsync;&#125; 这里的mReceiver也就是前面创建NativeDisplayEventReceiver对象是创建的成员变量对象DisplayEventReceiver，下面调用到DisplayEventReceiver.getEvents函数，应该是要从出现同步信号事件的socket中读取数据，上面Looper机制中epoll中监听到socket以后，返回到NativeDisplayEventReceiver.handleEvent里面，但是socket里面的数据还没有读取，下面的调用流程为：（1）mReceiver.getEvents(buf, EVENT_BUFFER_SIZE) —-&gt; DisplayEventReceiver::getEvents(DisplayEventReceiver::Event events, size_t count)（2）BitTube::recvObjects(dataChannel, events, count) —-&gt; BitTube::recvObjects(const sp&amp; tube, void events, size_t count, size_t objSize)看一下这个recvObjects函数： 123456ssize_t BitTube::recvObjects(const sp&lt;BitTube&gt;&amp; tube, void* events, size_t count, size_t objSize)&#123; char* vaddr = reinterpret_cast&lt;char*&gt;(events); ssize_t size = tube-&gt;read(vaddr, count*objSize); return size &lt; 0 ? size : size / static_cast&lt;ssize_t&gt;(objSize);&#125; 这里在NativeDisplayEventReceiver中创建了一个缓冲区，并在recvObjects中将socket中的Event数据读到这个缓冲区中，这个Event.header.type一般都是DISPLAY_EVENT_VSYNC，因此在上面的processPendingEvents函数中会将Event数据保存在outCount所指向的内存中，并返回true。 接下来返回到NativeDisplayEventReceiver.handleEvent后会调用到dispatchVsync函数： 12345void NativeDisplayEventReceiver::dispatchVsync(nsecs_t timestamp, int32_t id, uint32_t count) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); env-&gt;CallVoidMethod(mReceiverObjGlobal, gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count); mMessageQueue-&gt;raiseAndClearException(env, \"dispatchVsync\");&#125; 这里的处理很直接，直接调用mReceiverObjGlobal对象在gDisplayEventReceiverClassInfo.dispatchVsync中指定的函数，将后面的timestamp（时间戳） id（设备ID） count（经过的同步信号的数量，一般没有设置采样频率应该都是1），下面分别看一下mReceiverObjGlobal以及gDisplayEventReceiverClassInfo.dispatchVsync代表的是什么？（1）mReceiverObjGlobal 1234NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env, jobject receiverObj, const sp&lt;MessageQueue&gt;&amp; messageQueue) : mReceiverObjGlobal(env-&gt;NewGlobalRef(receiverObj)), mMessageQueue(messageQueue), mWaitingForVsync(false) &#123; ALOGV(\"receiver %p ~ Initializing input event receiver.\", this);&#125; 可以看到mReceiverObjGlobal是创建NativeDisplayEventReceiver对象时传进来的第二个参数，该对象是在nativeInit函数中创建： 1sp receiver = new NativeDisplayEventReceiver(env, receiverObj, messageQueue); 进一步的，receiverObj是调用nativeInit函数时传进来的第一个参数（第一个参数env是系统用于连接虚拟机时自动加上的），nativeInit函数又是在Choreographer中创建FrameDisplayEventReceiver对象时，在基类DisplayEventReceiver构造器中调用的，因此这里的mReceiverObjGlobal对应的就是Choreographer中的FrameDisplayEventReceiver成员mDisplayEventReceiver。（2）gDisplayEventReceiverClassInfo.dispatchVsync在JNI中有很多这样的类似的结构体对象，这些对象都是全局结构体对象，这里的gDisplayEventReceiverClassInfo就是这样的一个对象，里面描述了一些在整个文件内可能会调用到的java层的相关类以及成员函数的相关信息，看一下gDisplayEventReceiverClassInfo： 12345static struct &#123; jclass clazz; jmethodID dispatchVsync; jmethodID dispatchHotplug;&#125; gDisplayEventReceiverClassInfo; 看一下里面的变量名称就能知道大致的含义，clazz成员代表的是某个java层的类的class信息，dispatchVsync和dispatchHotplug代表的是java层类的方法的方法信息，看一下该文件中注册JNI函数的方法： 12345678int register_android_view_DisplayEventReceiver(JNIEnv* env) &#123; int res = RegisterMethodsOrDie(env, \"android/view/DisplayEventReceiver\", gMethods, NELEM(gMethods)); jclass clazz = FindClassOrDie(env, \"android/view/DisplayEventReceiver\"); gDisplayEventReceiverClassInfo.clazz = MakeGlobalRefOrDie(env, clazz); gDisplayEventReceiverClassInfo.dispatchVsync = GetMethodIDOrDie(env, gDisplayEventReceiverClassInfo.clazz, \"dispatchVsync\", \"(JII)V\"); gDisplayEventReceiverClassInfo.dispatchHotplug = GetMethodIDOrDie(env, gDisplayEventReceiverClassInfo.clazz, \"dispatchHotplug\", \"(JIZ)V\"); return res;&#125; RegisterMethodsOrDie调用注册了java层调用native方法时链接到的函数的入口，下面clazz对应的就是java层的“android/view/DisplayEventReceiver.java”类，gDisplayEventReceiverClassInfo.dispatchVsync里面保存的就是clazz类信息中与dispatchVsync方法相关的信息，同样dispatchHotplug也是。分析到这里，就知道应用进程native接收到同步信号事件后，会调用Choreographer中的FrameDisplayEventReceiver成员mDisplayEventReceiver的dispatchVsync方法。 6.5.4、应用接收Vsync看一下FrameDisplayEventReceiver.dispatchVsync方法，也就是DisplayEventReceiver.dispatchVsync方法(Choreographer.java)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Called from native code. @SuppressWarnings(&quot;unused&quot;) private void dispatchVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; onVsync(timestampNanos, builtInDisplayId, frame); &#125; 注释表明这个方法是从native代码调用的，该函数然后会调用FrameDisplayEventReceiver.onVsync方法： @Override public void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; // Ignore vsync from secondary display. // This can be problematic because the call to scheduleVsync() is a one-shot. // We need to ensure that we will still receive the vsync from the primary // display which is the one we really care about. Ideally we should schedule // vsync for a particular display. // At this time Surface Flinger won&apos;t send us vsyncs for secondary displays // but that could change in the future so let&apos;s log a message to help us remember // that we need to fix this. //注释：忽略来自非主显示器的Vsync信号，但是我们前面调用的scheduleVsync函数只能请求到一次Vsync信号，因此需要重新调用scheduleVsync函数 //请求来自主显示设备的Vsync信号 if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123; Log.d(TAG, &quot;Received vsync from secondary display, but we don&apos;t support &quot; + &quot;this case yet. Choreographer needs a way to explicitly request &quot; + &quot;vsync for a specific display to ensure it doesn&apos;t lose track &quot; + &quot;of its scheduled vsync.&quot;); scheduleVsync(); return; &#125; // Post the vsync event to the Handler. // The idea is to prevent incoming vsync events from completely starving // the message queue. If there are no messages in the queue with timestamps // earlier than the frame time, then the vsync event will be processed immediately. // Otherwise, messages that predate the vsync event will be handled first. long now = System.nanoTime(); if (timestampNanos &gt; now) &#123; Log.w(TAG, &quot;Frame time is &quot; + ((timestampNanos - now) * 0.000001f) + &quot; ms in the future! Check that graphics HAL is generating vsync &quot; + &quot;timestamps using the correct timebase.&quot;); timestampNanos = now; &#125; if (mHavePendingVsync) &#123; Log.w(TAG, &quot;Already have a pending vsync event. There should only be &quot; + &quot;one at a time.&quot;); &#125; else &#123; mHavePendingVsync = true; &#125; mTimestampNanos = timestampNanos; //同步信号时间戳 mFrame = frame; //同步信号的个数，理解就是从调用scheduleVsync到onVsync接收到信号之间经历的同步信号的个数，一般都是1 Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS); &#125; 貌似这里的处理只是往Choreographer对象中的mHandler对应的线程Looper中发送一个消息，消息的内容有两个特点：（1）将this，也就是当前的FrameDisplayEventReceiver对象作为参数，后面会回调到FrameDisplayEventReceiver.run方法；（2）为Message设置FLAG_ASYNCHRONOUS属性；发送这个FLAG_ASYNCHRONOUS消息后，后面会回调到FrameDisplayEventReceiver.run方法，至于为什么，后面再写文章结合View.invalidate方法的过程分析，看一下FrameDisplayEventReceiver.run方法： 12345@Overridepublic void run() &#123; mHavePendingVsync = false; doFrame(mTimestampNanos, mFrame);&#125; 调用Choreographer.doFrame方法，如果是重绘事件doFrame方法会最终调用到ViewRootImpl.performTraversals方法进入实际的绘制流程。经过上面的分析可以知道，调用一次Choreographer.scheduleVsyncLocked只会请求一次同步信号，也就是回调一次FrameDisplayEventReceiver.onVsync方法，在思考一个问题，一个应用进程需要多次请求Vsync同步信号会不会使用同样的一串对象？多个线程又是怎么样的？答：一般绘制操作只能在主线程里面进行，因此一般来说只会在主线程里面去请求同步信号，可以认为不会存在同一个应用的多个线程请求SF的Vsync信号，Choreographer是一个线程内的单例模式，存储在了 ThreadLocal sThreadInstance对象里面，所以主线程多次请求使用的是同一个Choreographer对象，所以后面的一串对象应该都是可以复用的。 总体架构：伐木累:::终于完了，由于Android Graphics系统涉及模块代码纵横交叉复杂，其中代码图示有误的地方请见谅，也没有精力一一核对了，还请海涵~~~主要是分析Android Graphics总体的一个流程思想，有需要再一点点深挖。 （七）、参考文档(特别感谢各位前辈的分析和图示)：Android Vsync 原理林学森的Android专栏Android Graphics了解 Systrace图解Android - Android GUI 系统Android SurfaceFlinger 学习之路&amp;Android多媒体开发Android7.0 基础业务AMS、数据业务、电源管理业务 源码分析【Android 显示模块】 - 深入剖析Android系统 - CSDN博客深入理解Android卷一全文-第八章(深入理解Surface系统)android系统 - armwind的专栏 - CSDN博客android显示系统 - kc58236582的博客 - CSDN博客SurfaceView, TextureView, SurfaceTexture等的区别【Demo】Android graphics 学习－生产者、消费者、BufferQueue介绍深入Android Graphics Pipeline：从按钮到帧缓冲（第一部分）深入Android Graphics Pipeline：从按钮到帧缓冲（第二部分）窗口：Profiling 视图（OpenGL/OpenGL ES* 工作负载） Android N中UI硬件渲染（hwui）的HWUI_NEW_OPS(基于Android 7.1)Android’s Graphics Buffer Management System (Part I: gralloc)Android’s Graphics Buffer Management System (Part II: BufferQueue)Android GDI之SurfaceFlingerAndroid SurfaceFlinger 学习之路(五)—-VSync 工作原理Android 5.1 SurfaceFlinger VSYNC详解Android 5.1 SurfaceFlinger VSYNC详解Android消息机制Looper与VSync的传播Android垂直同步信号VSync的产生及传播结构详解Android 4.4(KitKat)中VSync信号的虚拟化Android 4.4(KitKat)窗口管理子系统 - 体系框架Android中用OpenGL ES Tracer分析绘制过程android view的绘制中，View绘制的时间如何和vsync屏幕刷新频率保持同步的？【深入理解Android卷一全文-第八章】入理解Surface系统Android 窗口管理：Z-Order管理","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Android Binder 系统 分析","slug":"Android-7-1-2-Android-N-Android-Binder系统分析","date":"2017-12-31T16:00:00.000Z","updated":"2018-03-23T07:20:40.000Z","comments":true,"path":"2018/01/01/Android-7-1-2-Android-N-Android-Binder系统分析/","link":"","permalink":"http://zhoujinjian.cc/2018/01/01/Android-7-1-2-Android-N-Android-Binder系统分析/","excerpt":"Android Binder系统概述：Binder是Android系统中大量使用的IPC（Inter-process communication，进程间通讯）机制。无论是应用程序对系统服务的请求，还是应用程序自身提供对外服务，都需要使用到Binder。因此，Binder机制在Android系统中的地位非常重要，可以说，理解Binder是理解Android系统的绝对必要前提。","text":"Android Binder系统概述：Binder是Android系统中大量使用的IPC（Inter-process communication，进程间通讯）机制。无论是应用程序对系统服务的请求，还是应用程序自身提供对外服务，都需要使用到Binder。因此，Binder机制在Android系统中的地位非常重要，可以说，理解Binder是理解Android系统的绝对必要前提。 framework/base/core/java/ (Java)framework/base/core/jni/ (JNI)framework/native/libs/binder (Native)framework/native/cmds/servicemanager/ (Native)kernel/drivers/staging/android (Driver) Java framework framework/base/core/java/android/os/● IInterface.java● IBinder.java● Parcel.java● IServiceManager.java● ServiceManager.java● ServiceManagerNative.java● Binder.java framework/base/core/jni/● android_os_Parcel.cpp● AndroidRuntime.cpp● android_util_Binder.cpp (核心类) Native framework framework/native/libs/binder● IServiceManager.cpp● BpBinder.cpp● Binder.cpp● IPCThreadState.cpp (核心类)● ProcessState.cpp (核心类) framework/native/include/binder/● IServiceManager.h● IInterface.h framework/native/cmds/servicemanager/● bctest.c● binder.h● binder.c● service_manager.c● servicemanager.rc Kernel kernel/drivers/staging/android/ ● binder.c● binder.h 博客原图链接一、Android Binder系统C程序示例（1）、简述Binder跨进程机制Android系统中，每个应用程序是由Android的Activity，Service，Broadcast，ContentProvider这四组件的中一个或多个组合而成，这四组件所涉及的多进程间的通信底层都是依赖于Binder IPC机制。 从进程角度来看IPC机制 现在Client进程需要访问Server进程中的服务，会经过以下步骤：1、Server进程首先向ServiceManager注册服务（ServiceManager先于Server启动）2、Client进程向ServiceManager查询服务得到一个句柄Handle（Server进程可能不止一个服务，用Handle区分是哪一个服务）3、Client进程 封装数据Buffer通过Binder驱动发送给Server进程，Server进程取得数据后解析数据，使用Server进程的Handle服务对应的函数处理数据，处理完成后通过Binder驱动传输给Client进程 1.1、Server进程向ServiceManager注册服务ServiceManager是一个守护进程。它的main()函数源码如下： ServiceManager是如何启动的？这里简要介绍一下ServiceManager的启动方式。当Kernel启动加载完驱动之后，会启动Android的init进程，init进程会解析servicemanager.rc，进而启动servicemanager.rc中定义的守护进程。 1234567891011121314151617[-&gt;ServiceManager.c]int main(int argc, char **argv)&#123; struct binder_state *bs; void *svcmgr = BINDER_SERVICE_MANAGER; bs = binder_open(128*1024); if (binder_become_context_manager(bs)) &#123; ... &#125; svcmgr_handle = svcmgr; binder_loop(bs, svcmgr_handler); return 0;&#125; 123456789101112131415161718192021222324252627282930void binder_loop(struct binder_state *bs, binder_handler func)&#123; int res; struct binder_write_read bwr; unsigned readbuf[32]; bwr.write_size = 0; bwr.write_consumed = 0; bwr.write_buffer = 0; // 告诉Kernel，ServiceManager进程进入了消息循环状态。 readbuf[0] = BC_ENTER_LOOPER; binder_write(bs, readbuf, sizeof(unsigned)); for (;;) &#123; bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (unsigned) readbuf; // 向Kernel中发送消息(先写后读)。 // 先将消息传递给Kernel，然后再从Kernel读取消息反馈 res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); ... // 解析读取的消息反馈 res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func); ... &#125;&#125; binder_loop()主要工作：(1)、通过ioctl(,BINDER_WRITE_READ,)进入消息循环，休眠等待Client请求(2)、当Client通过驱动请求服务时，binder驱动会唤醒ServiceManager，通过binder_parse()解析处理数据，回复信息 代码调用关系图： 时序流程图： main()主要进行了三项工作：(1) 、通过binder_open()打开”/dev/binder”文件，即打开Binder设备文件。(2) 、调用binder_become_context_manager()，通过ioctl()告诉Binder驱动程序自己是Binder上下文管理者。(3) 、调用binder_loop()进入消息循环，等待Client的请求。如果没有Client请求，则进入睡眠等待状态；当有Client请求时，就被唤醒，然后读取并处理Client请求。 1.2、分析Android binder原生示例程序bctest.c：12345678910111213141516int main(int argc, char **argv)&#123; struct binder_state *bs; uint32_t svcmgr = BINDER_SERVICE_MANAGER; uint32_t handle; bs = binder_open(128*1024); ... while (argc &gt; 0) &#123; //svcmgr_lookup方法调用binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_ADD_SERVICE) handle = svcmgr_lookup(bs, svcmgr, \"alt_svc_mgr\"); //svcmgr_publish方法调用binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_CHECK_SERVICE) svcmgr_publish(bs, svcmgr, argv[1], &amp;token); &#125; return 0;&#125; 1.3、示例程序（bctest.c）注册服务、获取服务过程注册服务的过程（bctest.c）: (1) 、bs = binder_open(128*1024)(2) 、binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_ADD_SERVICE)参数说明： // msg含有服务的名字 // reply它会含有servicemanager回复的数据 // target为0表示servicemanager // code: 表示要调用servicemanager中的”addservice函数” 获取服务的过程（bctest.c）: (1) 、bs = binder_open(128*1024)(2) 、binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_CHECK_SERVICE)参数说明： // msg含有服务的名字 // reply它会含有servicemanager回复的数据, 表示提供服务的进程 // target为0表示servicemanager // code: 表示要调用servicemanager中的”getservice函数” binder_call远程实现：根据msg、target、code就知道需要调用哪个服务的哪一个函数。 12345678910111213141516171819202122232425262728293031323334353637int binder_call(struct binder_state *bs, struct binder_io *msg, struct binder_io *reply, uint32_t target, uint32_t code)&#123; int res; struct binder_write_read bwr; struct &#123; uint32_t cmd; struct binder_transaction_data txn; &#125; __attribute__((packed)) writebuf; unsigned readbuf[32]; writebuf.cmd = BC_TRANSACTION; writebuf.txn.target.handle = target; writebuf.txn.code = code; writebuf.txn.flags = 0; writebuf.txn.data_size = msg-&gt;data - msg-&gt;data0; writebuf.txn.offsets_size = ((char*) msg-&gt;offs) - ((char*) msg-&gt;offs0); writebuf.txn.data.ptr.buffer = (uintptr_t)msg-&gt;data0; writebuf.txn.data.ptr.offsets = (uintptr_t)msg-&gt;offs0; bwr.write_size = sizeof(writebuf); bwr.write_consumed = 0; bwr.write_buffer = (uintptr_t) &amp;writebuf; hexdump(msg-&gt;data0, msg-&gt;data - msg-&gt;data0); for (;;) &#123; bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (uintptr_t) readbuf; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); res = binder_parse(bs, reply, (uintptr_t) readbuf, bwr.read_consumed, 0); &#125;&#125; 注： 结构体简介binder_io 封装一次发送的数据binder_write_read 存储一次读写操作的数据binder_transaction_data 存储一次事务的数据 （1）构造参数，使用binder_io 描述（2）数据转换binder_io -&gt; binder_write_read；首先根据binder_io 、target、code三者构造binder_transaction_data，然后将binder_write_read.write_buffer指向binder_transaction_data（3）调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);发送数据 （2）、Android Binder系统_ServiceManager我们先跳过ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)所涉及的内核知识和流程，稍后再Android Binder系统-Driver层详细介绍。 2.1、ServiceManager中service句柄如何管理前面分析过，ServiceManager开机初始会启动成为一个守护进程， ServiceManager是如何管理service句柄的？进程里有一个全局性的svclist变量： 1struct svcinfo *svclist = 0; 它记录着所有添加进系统的“Service”信息，这些信息被组织成一条单向链表，我们不妨称这条链表为“Service向量表”。示意图如下： 链表节点类型为svcinfo 添加服务简单理解就是 新建svcinfo节点插入到单链表中，查询服务就是看单链表是否有此服务。 2.2、解析Binder上传数据-(binder_parse函数)回到ServiceManager的main()函数。binder_loop()会先向binder驱动发出了BC_ENTER_LOOPER命令，接着进入一个for循环不断调用ioctl()读取发来的数据，接着解析这些数据。假设现在Client有请求，Binder驱动就通过会上传数据。读取数据后会交由binder_parse()解析。 1binder_loop(bs, svcmgr_handler); 注意binder_loop()的参数svcmgr_handler()函数指针。而且这个参数会进一步传递给binder_parse()。binder_parse()负责解析从binder驱动读来的数据，其代码截选如下： 1234567891011121314151617181920212223242526272829303132333435363738int binder_parse(struct binder_state *bs, struct binder_io *bio, uintptr_t ptr, size_t size, binder_handler func)&#123; int r = 1; uintptr_t end = ptr + (uintptr_t) size; while (ptr &lt; end) &#123; uint32_t cmd = *(uint32_t *) ptr; ptr += sizeof(uint32_t); switch(cmd) &#123; ... //驱动有数据后会返回次cmd case BR_TRANSACTION: &#123; struct binder_transaction_data *txn = (struct binder_transaction_data *) ptr; binder_dump_txn(txn); if (func) &#123; unsigned rdata[256/4]; struct binder_io msg; struct binder_io reply; int res; bio_init(&amp;reply, rdata, sizeof(rdata), 4); bio_init_from_txn(&amp;msg, txn); res = func(bs, txn, &amp;msg, &amp;reply); if (txn-&gt;flags &amp; TF_ONE_WAY) &#123; binder_free_buffer(bs, txn-&gt;data.ptr.buffer); &#125; else &#123; binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res); &#125; ... &#125; ptr += sizeof(*txn); break; &#125; ... &#125; return r;&#125; 从前文的代码我们可以看到，binder_loop()声明了一个128节的buffer（即uint32_t readbuf[32]），每次用BINDER_WRITE_READ命令从驱动读取一些内容，并传入binder_parse()。 binder_parse()在合适的时机，会回调其func参数（binder_handler func）指代的回调函数，即前文说到的svcmgr_handler()函数。 binder_loop()就这样一直循环下去，完成了整个ServiceManager的工作。 2.3、数据转换binder_transaction_data-&gt;binder_io初始化reply；根据txt(Binder驱动反馈的信息)初始化msg12bio_init(&amp;reply, rdata, sizeof(rdata), 4);bio_init_from_txn(&amp;msg, txn); 2.4、如何添加服务SVC_MGR_ADD_SERVICE前面讲过 binder_parse()在合适的时机，会回调其func参数（binder_handler func）指代的回调函数，即前文说到的svcmgr_handler()函数。并且会根据binder_transaction_data的code判断具体调用哪一个函数。 12345678910111213141516171819202122232425262728293031323334int svcmgr_handler(struct binder_state *bs, struct binder_transaction_data *txn, struct binder_io *msg, struct binder_io *reply)&#123; struct svcinfo *si; uint16_t *s; size_t len; uint32_t handle; uint32_t strict_policy; int allow_isolated; ...... switch(txn-&gt;code) &#123; case SVC_MGR_GET_SERVICE: case SVC_MGR_CHECK_SERVICE: s = bio_get_string16(msg, &amp;len); handle = do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid); bio_put_ref(reply, handle); return 0; case SVC_MGR_ADD_SERVICE: s = bio_get_string16(msg, &amp;len); handle = bio_get_ref(msg); allow_isolated = bio_get_uint32(msg) ? 1 : 0; if (do_add_service(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, txn-&gt;sender_pid)) return -1; break;... &#125; bio_put_uint32(reply, 0); return 0;&#125; 由代码可知code = SVC_MGR_ADD_SERVICE 会调用do_add_service()函数 123456789101112131415161718192021222324252627int do_add_service(struct binder_state *bs, const uint16_t *s, size_t len, uint32_t handle, uid_t uid, int allow_isolated, pid_t spid)&#123; struct svcinfo *si; ... si = find_svc(s, len); if (si) &#123; ... &#125; else &#123; si = malloc(sizeof(*si) + (len + 1) * sizeof(uint16_t)); ... si-&gt;handle = handle; si-&gt;len = len; memcpy(si-&gt;name, s, (len + 1) * sizeof(uint16_t)); si-&gt;name[len] = '\\0'; si-&gt;death.func = (void*) svcinfo_death; si-&gt;death.ptr = si; si-&gt;allow_isolated = allow_isolated; si-&gt;next = svclist; svclist = si; &#125; binder_acquire(bs, handle); binder_link_to_death(bs, handle, &amp;si-&gt;death); return 0;&#125; 可见添加Service只是新建了一个svcinfo然后插入到前面所说的“Service向量表”中。 2.5、如何获取服务SVC_MGR_CHECK_SERVICE123456uint32_t do_find_service(const uint16_t *s, size_t len, uid_t uid, pid_t spid)&#123; struct svcinfo *si = find_svc(s, len); ... return si-&gt;handle;&#125; 获取服务会查询“Service向量表”是否有此服务，然后返回Service的句柄handle。 2.6、ServiceManager回复数据前面分析回调svcmgr_handler()函数处理数据后，会调用binder_send_reply()函数回复消息给驱动。1binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res) 2.7、总结：示例程序（bctest.c）注册、获取服务一般分以下步骤：（1）源进程通过binder_open()打开”/dev/binder”文件，即打开Binder设备文件。（2）源进程构造数据：[a].构造binder_io [b].转为binder_transaction_data [c].放入binder_write_read（3）源进程调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);发送数据给驱动（4）驱动上报数据到目的进程ServiceManager（5）目的进程ServiceManager处理完数据，重新构造数据，通过调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);发送数据给驱动（6）驱动然后将数据反馈到源进程 （3）、Android Binder系统C程序3.1、Android Binder系统C程序_框架总结bctest.c注册服务获取服务的一般流程框架： 3.2、Android Binder系统C程序_编码参考bctest.c编码：test_server：向ServiceManager添加服务”hello” &amp;&amp; “goodbye” Servicetest_client ：查询获取服务(ServiceManager)链接：Binder_C_App 3.3、Android Binder系统C程序_测试./test_server &amp;./test_client hello./test_client hello 100ask.taobao.com./test_client goodbye./test_client goodbye 100ask.taobao.com 二、Android Binder系统-Driver层前面打开驱动binder_open(128*1024)、ServiceManager启动是如何与驱动交互成为管理者的，以及添加服务获取服务驱动部分都没有详细讲解，现在一起来看下。 （1）、Binder驱动概述1.1 概述Binder驱动是Android专用的，但底层的驱动架构与Linux驱动一样。binder驱动在以misc设备进行注册，作为虚拟字符设备，没有直接操作硬件，只是对设备内存的处理。主要是驱动设备的初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。如启动ServiceManager调用: 1.2 系统调用用户态的程序调用Kernel层驱动是需要陷入内核态，进行系统调用(syscall)，比如打开Binder驱动方法的调用链为： open-&gt; open() -&gt; binder_open()。 open()为用户空间的方法，open()便是系统调用中相应的处理方法，通过查找，对应调用到内核binder驱动的binder_open()方法，至于其他的从用户态陷入内核态的流程也基本一致。 （2）、Binder核心方法2.1、binder_init()主要工作是为了注册misc设备binder_init函数中最主要的工作其实下面这行：1ret = misc_register(&amp;binder_miscdev); 该行代码真正向内核中注册了Binder设备。binder_miscdev的定义如下： 12345static struct miscdevice binder_miscdev = &#123; .minor = MISC_DYNAMIC_MINOR, .name = \"binder\", .fops = &amp;binder_fops&#125;; 这里指定了Binder设备的名称是“binder”。这样，在用户空间便可以通过对/dev/binder文件进行操作来使用Binder。binder_miscdev同时也指定了该设备的fops。fops是另外一个结构体，这个结构中包含了一系列的函数指针，其定义如下： 12345678910static const struct file_operations binder_fops = &#123; .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .compat_ioctl = binder_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release,&#125;; 2.2、主要结构Binder驱动中包含了很多的结构体。为了便于下文讲解，这里我们先对这些结构体做一些介绍。 驱动中的结构体可以分为两类： 一类是与用户空间共用的，这些结构体在Binder通信协议过程中会用到。因此，这些结构体定义在binder.h中，包括： 结构体名称 说明 flat_binder_object 描述在Binder IPC中传递的对象，见下文 binder_write_read 存储一次读写操作的数据 binder_version 存储Binder的版本号 transaction_flags 描述事务的flag，例如是否是异步请求，是否支持fd binder_transaction_data 存储一次事务的数据 binder_ptr_cookie 包含了一个指针和一个cookie binder_handle_cookie 包含了一个句柄和一个cookie binder_pri_desc 暂未用到 binder_pri_ptr_cookie 暂未用到 从前面Binder系统C程序框架分析，这其中，binder_write_read和binder_transaction_data这两个结构体最为重要，它们存储了IPC调用过程中的数据。关于这一点，我们在下文中会讲解。 Binder驱动中，还有一类结构体是仅仅Binder驱动内部实现过程中需要的，它们定义在binder.c中，包括： 结构体名称 说明 binder_node 描述Binder实体节点，即：对应了一个Server binder_ref 描述对于Binder实体的引用 binder_buffer 描述Binder通信过程中存储数据的Buffer binder_proc 描述使用Binder的进程 binder_thread 描述使用Binder的线程 binder_work 描述通信过程中的一项任务 binder_transaction 描述一次事务的相关信息 binder_deferred_state 描述延迟任务 binder_ref_death 描述Binder实体死亡的信息 binder_transaction_log debugfs日志 binder_transaction_log_entry debugfs日志条目 这里需要读者关注的结构体已经用加粗做了标注。 2.3、Binder协议Binder协议可以分为控制协议和驱动协议两类。 控制协议是进程通过ioctl(“/dev/binder”) 与Binder设备进行通讯的协议，该协议包含以下几种命令： 结构体名称 说明 参数类型 BINDER_WRITE_READ 读写操作，最常用的命令。IPC过程就是通过这个命令进行数据传递 binder_write_read BINDER_SET_MAX_THREADS 设置进程支持的最大线程数量 size_t BINDER_SET_CONTEXT_MGR 设置自身为ServiceManager 无 BINDER_THREAD_EXIT 通知驱动Binder线程退出 无 BINDER_VERSION 获取Binder驱动的版本号 binder_version BINDER_SET_IDLE_PRIORITY 暂未用到 - BINDER_SET_IDLE_TIMEOUT 暂未用到 - Binder的驱动协议描述了对于Binder驱动的具体使用过程。驱动协议又可以分为两类： 一类是binder_driver_command_protocol，描述了进程发送给Binder驱动的命令一类是binder_driver_return_protocol，描述了Binder驱动发送给进程的命令binder_driver_command_protocol共包含17个命令，分别是： 结构体名称 说明 参数类型 BC_TRANSACTION Binder事务，即：Client对于Server的请求 binder_transaction_data BC_REPLY 事务的应答，即：Server对于Client的回复 binder_transaction_data BC_FREE_BUFFER 通知驱动释放Buffer binder_uintptr_t BC_ACQUIRE 强引用计数+1 __u32 BC_RELEASE 强引用计数-1 __u32 BC_INCREFS 弱引用计数+1 __u32 BC_DECREFS 弱引用计数-1 __u32 BC_ACQUIRE_DONE BR_ACQUIRE的回复 binder_ptr_cookie BC_INCREFS_DONE BR_INCREFS的回复 binder_ptr_cookie BC_ENTER_LOOPER 通知驱动主线程ready void BC_REGISTER_LOOPER 通知驱动子线程ready void BC_EXIT_LOOPER 通知驱动线程已经退出 void BC_REQUEST_DEATH_NOTIFICATION 请求接收死亡通知 binder_handle_cookie BC_CLEAR_DEATH_NOTIFICATION 去除接收死亡通知 binder_handle_cookie BC_DEAD_BINDER_DONE 已经处理完死亡通知 binder_uintptr_t BC_ATTEMPT_ACQUIRE 暂未实现 - BC_ACQUIRE_RESULT 暂未实现 - binder_driver_return_protocol共包含18个命令，分别是： 结构体名称 说明 参数类型 BR_OK 操作完成 void BR_NOOP 操作完成 void BR_ERROR 发生错误 __s32 BR_TRANSACTION 通知进程收到一次Binder请求（Server端） binder_transaction_data BR_REPLY 通知进程收到Binder请求的回复（Client） binder_transaction_data BR_TRANSACTION_COMPLETE 驱动对于接受请求的确认回复 void BR_FAILED_REPLY 告知发送方通信目标不存在 void BR_SPAWN_LOOPER 通知Binder进程创建一个新的线程 void BR_ACQUIRE 强引用计数+1请求 binder_ptr_cookie BR_RELEASE 强引用计数-1请求 binder_ptr_cookie BR_INCREFS 弱引用计数+1请求 binder_ptr_cookie BR_DECREFS 若引用计数-1请求 binder_ptr_cookie BR_DEAD_BINDER 发送死亡通知 binder_uintptr_t BR_CLEAR_DEATH_NOTIFICATION_DONE 清理死亡通知完成 binder_uintptr_t BR_DEAD_REPLY 告知发送方对方已经死亡 void BR_ACQUIRE_RESULT 暂未实现 - BR_ATTEMPT_ACQUIRE 暂未实现 - BR_FINISHED 暂未实现 - 单独看上面的协议可能很难理解，这里我们以一次Binder请求过程来详细看一下Binder协议是如何通信的，就比较好理解了。 这幅图的说明如下： Binder是C/S架构的，通信过程牵涉到：Client，Server以及Binder驱动三个角色Client对于Server的请求以及Server对于Client回复都需要通过Binder驱动来中转数据BC_XXX命令是进程发送给驱动的命令BR_XXX命令是驱动发送给进程的命令整个通信过程由Binder驱动控制 2.4、binder_open()任何进程在使用Binder之前，都需要先通过open(“/dev/binder”)打开Binder设备。上文已经提到，用户空间的open系统调用对应了驱动中的binder_open函数。在这个函数，Binder驱动会为调用的进程做一些初始化工作。binder_open函数代码如下所示： 1234567891011121314151617181920212223242526272829static int binder_open(struct inode *nodp, struct file *filp)&#123; struct binder_proc *proc; // 创建进程对应的binder_proc对象 proc = kzalloc(sizeof(*proc), GFP_KERNEL); if (proc == NULL) return -ENOMEM; get_task_struct(current); proc-&gt;tsk = current; // 初始化binder_proc INIT_LIST_HEAD(&amp;proc-&gt;todo); init_waitqueue_head(&amp;proc-&gt;wait); proc-&gt;default_priority = task_nice(current); // 锁保护 binder_lock(__func__); binder_stats_created(BINDER_STAT_PROC); // 添加到全局列表binder_procs中 hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); proc-&gt;pid = current-&gt;group_leader-&gt;pid; INIT_LIST_HEAD(&amp;proc-&gt;delivered_death); filp-&gt;private_data = proc; binder_unlock(__func__); return 0;&#125; 在Binder驱动中，通过binder_procs记录了所有使用Binder的进程。每个初次打开Binder设备的进程都会被添加到这个列表中的。 另外，请读者回顾一下上文介绍的Binder驱动中的几个关键结构体： binder_procbinder_nodebinder_threadbinder_refbinder_buffer 在实现过程中，为了便于查找，这些结构体互相之间都留有字段存储关联的结构。 下面这幅图描述了这里说到的这些内容： 2.5、binder_mmap()在打开Binder设备之后，进程还会通过mmap进行内存映射。mmap的作用有如下两个： 申请一块内存空间，用来接收Binder通信过程中的数据对这块内存进行地址映射，以便将来访问binder_mmap函数对应了mmap系统调用的处理，这个函数也是Binder驱动的精华所在（这里说的binder_mmap函数也包括其内部调用的binder_update_page_range函数，见下文）。 前文我们说到，使用Binder机制，数据只需要经历一次拷贝就可以了，其原理就在这个函数中。 binder_mmap这个函数中，会申请一块物理内存，然后在用户空间和内核空间同时对应到这块内存上。在这之后，当有Client要发送数据给Server的时候，只需一次，将Client发送过来的数据拷贝到Server端的内核空间指定的内存地址即可，由于这个内存地址在服务端已经同时映射到用户空间，因此无需再做一次复制，Server即可直接访问，整个过程如下图所示： 这幅图的说明如下： Server在启动之后，调用对/dev/binder设备调用mmap内核中的binder_mmap函数进行对应的处理：申请一块物理内存，然后在用户空间和内核空间同时进行映射Client通过BINDER_WRITE_READ命令发送请求，这个请求将先到驱动中，同时需要将数据从Client进程的用户空间拷贝到内核空间驱动通过BR_TRANSACTION通知Server有人发出请求，Server进行处理。由于这块内存也在用户空间进行了映射，因此Server进程的代码可以直接访问了解原理之后，我们再来看一下Binder驱动的相关源码。这段代码有两个函数： binder_mmap函数对应了mmap的系统调用的处理binder_update_page_range函数真正实现了内存分配和地址映射 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697static int binder_mmap(struct file *filp, struct vm_area_struct *vma)&#123; int ret; struct vm_struct *area; struct binder_proc *proc = filp-&gt;private_data; const char *failure_string; struct binder_buffer *buffer; ... // 在内核空间获取一块地址范围 area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP); if (area == NULL) &#123; ret = -ENOMEM; failure_string = \"get_vm_area\"; goto err_get_vm_area_failed; &#125; proc-&gt;buffer = area-&gt;addr; // 记录内核空间与用户空间的地址偏移 proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer; mutex_unlock(&amp;binder_mmap_lock); ... proc-&gt;pages = kzalloc(sizeof(proc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL); if (proc-&gt;pages == NULL) &#123; ret = -ENOMEM; failure_string = \"alloc page array\"; goto err_alloc_pages_failed; &#125; proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start; vma-&gt;vm_ops = &amp;binder_vm_ops; vma-&gt;vm_private_data = proc; /* binder_update_page_range assumes preemption is disabled */ preempt_disable(); // 通过下面这个函数真正完成内存的申请和地址的映射 // 初次使用，先申请一个PAGE_SIZE大小的内存 ret = binder_update_page_range(proc, 1, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma); ...&#125;static int binder_update_page_range(struct binder_proc *proc, int allocate, void *start, void *end, struct vm_area_struct *vma)&#123; void *page_addr; unsigned long user_page_addr; struct vm_struct tmp_area; struct page **page; struct mm_struct *mm; ... for (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123; int ret; struct page **page_array_ptr; page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE]; BUG_ON(*page); // 真正进行内存的分配 *page = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO); if (*page == NULL) &#123; pr_err(\"%d: binder_alloc_buf failed for page at %p\\n\", proc-&gt;pid, page_addr); goto err_alloc_page_failed; &#125; tmp_area.addr = page_addr; tmp_area.size = PAGE_SIZE + PAGE_SIZE /* guard page? */; page_array_ptr = page; // 在内核空间进行内存映射 ret = map_vm_area(&amp;tmp_area, PAGE_KERNEL, &amp;page_array_ptr); if (ret) &#123; pr_err(\"%d: binder_alloc_buf failed to map page at %p in kernel\\n\", proc-&gt;pid, page_addr); goto err_map_kernel_failed; &#125; user_page_addr = (uintptr_t)page_addr + proc-&gt;user_buffer_offset; // 在用户空间进行内存映射 ret = vm_insert_page(vma, user_page_addr, page[0]); if (ret) &#123; pr_err(\"%d: binder_alloc_buf failed to map page at %lx in userspace\\n\", proc-&gt;pid, user_page_addr); goto err_vm_insert_page_failed; &#125; /* vm_insert_page does not seem to increment the refcount */ &#125; if (mm) &#123; up_write(&amp;mm-&gt;mmap_sem); mmput(mm); &#125; preempt_disable(); return 0;... binder_update_page_range主要完成工作：分配物理空间，将物理空间映射到内核空间，将物理空间映射到进程空间. 另外，不同参数下该方法也可以释放物理页面。 2.6、binder_ioctl()内存管理上文中，我们看到binder_mmap的时候，会申请一个PAGE_SIZE(通常是4K)的内存。而实际使用过程中，一个PAGE_SIZE的大小通常是不够的。 在驱动中，会根据实际的使用情况进行内存的分配。有内存的分配，当然也需要内存的释放。这里我们就来看看Binder驱动中是如何进行内存的管理的。 首先，我们还是从一次IPC请求说起。 当一个Client想要对Server发出请求时，它首先将请求发送到Binder设备上，由Binder驱动根据请求的信息找到对应的目标节点，然后将请求数据传递过去。 进程通过ioctl系统调用来发出请求：ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr) 这里的bs-&gt;fd对应了打开Binder设备时的fd。BINDER_WRITE_READ对应了具体要做的操作码，这个操作码将由Binder驱动解析。bwr存储了请求数据，其类型是binder_write_read。 binder_write_read其实是一个相对外层的数据结构，其内部会包含一个binder_transaction_data结构的数据。binder_transaction_data包含了发出请求者的标识，请求的目标对象以及请求所需要的参数。它们的关系如下图所示： binder_ioctl函数对应了ioctl系统调用的处理。这个函数的逻辑比较简单，就是根据ioctl的命令来确定进一步处理的逻辑，具体如下: ● 如果命令是BINDER_WRITE_READ，并且● 如果 bwr.write_size &gt; 0，则调用binder_thread_write● 如果 bwr.read_size &gt; 0，则调用binder_thread_read● 如果命令是BINDER_SET_MAX_THREADS，则设置进程的max_threads，即进程支持的最大线程数● 如果命令是BINDER_SET_CONTEXT_MGR，则设置当前进程为ServiceManager，见下文● 如果命令是BINDER_THREAD_EXIT，则调用binder_free_thread，释放binder_thread● 如果命令是BINDER_VERSION，则返回当前的Binder版本号这其中，最关键的就是binder_thread_write方法。当Client请求Server的时候，便会发送一个BINDER_WRITE_READ命令，同时框架会将将实际的数据包装好。此时，binder_transaction_data中的code将是BC_TRANSACTION，由此便会调用到binder_transaction方法，这个方法是对一次Binder事务的处理，这其中会调用binder_alloc_buf函数为此次事务申请一个缓存。 12345678910111213141516struct binder_buffer &#123; struct list_head entry; struct rb_node rb_node; unsigned free:1; unsigned allow_user_free:1; unsigned async_transaction:1; unsigned debug_id:29; struct binder_transaction *transaction; struct binder_node *target_node; size_t data_size; size_t offsets_size; uint8_t data[0];&#125;; 而在binder_proc（描述了使用Binder的进程）中，包含了几个字段用来管理进程在Binder IPC过程中缓存，如下： 12345678910struct binder_proc &#123; ... struct list_head buffers; // 进程拥有的buffer列表 struct rb_root free_buffers; // 空闲buffer列表 struct rb_root allocated_buffers; // 已使用的buffer列表 size_t free_async_space; // 剩余的异步调用的空间 size_t buffer_size; // 缓存的上限 ...&#125;; 进程在mmap时，会设定支持的总缓存大小的上限（下文会讲到）。而进程每当收到BC_TRANSACTION，就会判断已使用缓存加本次申请的和有没有超过上限。如果没有，就考虑进行内存的分配。 进程的空闲缓存记录在binder_proc的free_buffers中，这是一个以红黑树形式存储的结构。每次尝试分配缓存的时候，会从这里面按大小顺序进行查找，找到最接近需要的一块缓存。查找的逻辑如下： 123456789101112131415while (n) &#123; buffer = rb_entry(n, struct binder_buffer, rb_node); BUG_ON(!buffer-&gt;free); buffer_size = binder_buffer_size(proc, buffer); if (size &lt; buffer_size) &#123; best_fit = n; n = n-&gt;rb_left; &#125; else if (size &gt; buffer_size) n = n-&gt;rb_right; else &#123; best_fit = n; break; &#125;&#125; 找到之后，还需要对binder_proc中的字段进行相应的更新： 123456789101112131415161718192021rb_erase(best_fit, &amp;proc-&gt;free_buffers);buffer-&gt;free = 0;binder_insert_allocated_buffer(proc, buffer);if (buffer_size != size) &#123; struct binder_buffer *new_buffer = (void *)buffer-&gt;data + size; list_add(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry); new_buffer-&gt;free = 1; binder_insert_free_buffer(proc, new_buffer);&#125;binder_debug(BINDER_DEBUG_BUFFER_ALLOC, \"%d: binder_alloc_buf size %zd got %p\\n\", proc-&gt;pid, size, buffer);buffer-&gt;data_size = data_size;buffer-&gt;offsets_size = offsets_size;buffer-&gt;async_transaction = is_async;if (is_async) &#123; proc-&gt;free_async_space -= size + sizeof(struct binder_buffer); binder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC, \"%d: binder_alloc_buf size %zd async free %zd\\n\", proc-&gt;pid, size, proc-&gt;free_async_space);&#125; 下面我们再来看看内存的释放。 BC_FREE_BUFFER命令是通知驱动进行内存的释放，binder_free_buf函数是真正实现的逻辑，这个函数与binder_alloc_buf是刚好对应的。在这个函数中，所做的事情包括： 重新计算进程的空闲缓存大小通过binder_update_page_range释放内存更新binder_proc的buffers，free_buffers，allocated_buffers字段 2.7、Binder中的“面向对象”Binder机制淡化了进程的边界，使得跨越进程也能够调用到指定服务的方法，其原因是因为Binder机制在底层处理了在进程间的“对象”传递。 在Binder驱动中，并不是真的将对象在进程间来回序列化，而是通过特定的标识来进行对象的传递。Binder驱动中，通过flat_binder_object来描述需要跨越进程传递的对象。其定义如下： 12345678910struct flat_binder_object &#123; __u32 type; __u32 flags; union &#123; binder_uintptr_t binder; /* local object */ __u32 handle; /* remote object */ &#125;; binder_uintptr_t cookie;&#125;; 这其中，type有如下5种类型。 1234567enum &#123; BINDER_TYPE_BINDER = B_PACK_CHARS('s', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS('w', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_HANDLE = B_PACK_CHARS('s', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS('w', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_FD = B_PACK_CHARS('f', 'd', '*', B_TYPE_LARGE),&#125;; 当对象传递到Binder驱动中的时候，由驱动来进行翻译和解释，然后传递到接收的进程。 例如当Server把Binder实体传递给Client时，在发送数据流中，flat_binder_object中的type是BINDER_TYPE_BINDER，同时binder字段指向Server进程用户空间地址。但这个地址对于Client进程是没有意义的（Linux中，每个进程的地址空间是互相隔离的），驱动必须对数据流中的flat_binder_object做相应的翻译：将type该成BINDER_TYPE_HANDLE；为这个Binder在接收进程中创建位于内核中的引用并将引用号填入handle中。对于发生数据流中引用类型的Binder也要做同样转换。经过处理后接收进程从数据流中取得的Binder引用才是有效的，才可以将其填入数据包binder_transaction_data的target.handle域，向Binder实体发送请求。 由于每个请求和请求的返回都会经历内核的翻译，因此这个过程从进程的角度来看是完全透明的。进程完全不用感知这个过程，就好像对象真的在进程间来回传递一样。 2.8、驱动层的线程管理上文多次提到，Binder本身是C/S架构。由Server提供服务，被Client使用。既然是C/S架构，就可能存在多个Client会同时访问Server的情况。 在这种情况下，如果Server只有一个线程处理响应，就会导致客户端的请求可能需要排队而导致响应过慢的现象发生。解决这个问题的方法就是引入多线程。 Binder机制的设计从最底层–驱动层，就考虑到了对于多线程的支持。具体内容如下： 使用Binder的进程在启动之后，通过BINDER_SET_MAX_THREADS告知驱动其支持的最大线程数量驱动会对线程进行管理。在binder_proc结构中，这些字段记录了进程中线程的信息：max_threads，requested_threads，requested_threads_started，ready_threadsbinder_thread结构对应了Binder进程中的线程驱动通过BR_SPAWN_LOOPER命令告知进程需要创建一个新的线程进程通过BC_ENTER_LOOPER命令告知驱动其主线程已经ready进程通过BC_REGISTER_LOOPER命令告知驱动其子线程（非主线程）已经ready进程通过BC_EXIT_LOOPER命令告知驱动其线程将要退出在线程退出之后，通过BINDER_THREAD_EXIT告知Binder驱动。驱动将对应的binder_thread对象销毁 2.9、再聊ServiceManager上文已经说过，每一个Binder Server在驱动中会有一个binder_node进行对应。同时，Binder驱动会负责在进程间传递服务对象，并负责底层的转换。另外，我们也提到，每一个Binder服务都需要有一个唯一的名称。由ServiceManager来管理这些服务的注册和查找。 而实际上，为了便于使用，ServiceManager本身也实现为一个Server对象。任何进程在使用ServiceManager的时候，都需要先拿到指向它的标识。然后通过这个标识来使用ServiceManager。 这似乎形成了一个互相矛盾的现象： 通过ServiceManager我们才能拿到Server的标识ServiceManager本身也是一个Server解决这个矛盾的办法其实也很简单：Binder机制为ServiceManager预留了一个特殊的位置。这个位置是预先定好的，任何想要使用ServiceManager的进程只要通过这个特定的位置就可以访问到ServiceManager了（而不用再通过ServiceManager的接口）。 在Binder驱动中，有一个全局的binder_node 变量： 一般情况下，对于每一个Server驱动层会对应一个binder_node节点，然而binder_context_mgr_node比较特殊，它没有对应的应用层binder实体。在整个系统里，它是如此特殊，以至于系统规定，任何应用都必须使用句柄0来跨进程地访问它。 1static struct binder_node *binder_context_mgr_node; 这个变量指向的就是ServiceManager。 当有进程通过ioctl并指定命令为BINDER_SET_CONTEXT_MGR的时候，驱动被认定这个进程是ServiceManager，binder_ioctl()函数中对应的处理如下： 12345678910111213case BINDER_SET_CONTEXT_MGR: if (binder_context_mgr_node != NULL) &#123; &#125; ret = security_binder_set_context_mgr(proc-&gt;tsk); else &#123; binder_context_mgr_uid = current-&gt;cred-&gt;euid; binder_context_mgr_node = binder_new_node(proc, 0, 0);//在Binder驱动层创建binder_node结构体对象 binder_context_mgr_node-&gt;local_weak_refs++; binder_context_mgr_node-&gt;local_strong_refs++; binder_context_mgr_node-&gt;has_strong_ref = 1; binder_context_mgr_node-&gt;has_weak_ref = 1; &#125; break; ServiceManager应当要先于所有Binder Server之前启动。在它启动完成并告知Binder驱动之后，驱动便设定好了这个特定的节点。 在这之后，当有其他模块想要使用ServerManager的时候，只要将请求指向ServiceManager所在的位置即可。 在Binder驱动中，通过handle = 0这个位置来访问ServiceManager。例如，binder_transaction中，判断如果target.handler为0，则认为这个请求是发送给ServiceManager的，相关代码如下： 123456789101112131415161718if (tr-&gt;target.handle) &#123; struct binder_ref *ref; ref = binder_get_ref(proc, tr-&gt;target.handle, true); if (ref == NULL) &#123; binder_user_error(\"%d:%d got transaction to invalid handle\\n\", proc-&gt;pid, thread-&gt;pid); return_error = BR_FAILED_REPLY; goto err_invalid_target_handle; &#125; target_node = ref-&gt;node;&#125; else &#123; target_node = binder_context_mgr_node; if (target_node == NULL) &#123; return_error = BR_DEAD_REPLY; goto err_no_context_mgr_node; &#125;&#125; 2.10、binder_node等重要结构体 binder_procbinder_nodebinder_threadbinder_refbinder_buffer 1. Binder实体binder_node Binder实体，是各个Server以及ServiceManager在内核中的存在形式。Binder实体实际上是内核中binder_node结构体的对象，它的作用是在内核中保存Server和ServiceManager的信息(例如，Binder实体中保存了Server对象在用户空间的地址)。简言之，Binder实体是Server在Binder驱动中的存在形式，内核通过Binder实体可以找到用户空间的Server对象。在上图中，Server和ServiceManager在Binder驱动中都对应的存在一个Binder实体。 2. Binder引用binder_ref 说到Binder实体，就不得不说”Binder引用”。所谓Binder引用，实际上是内核中binder_ref结构体的对象，它的作用是在表示”Binder实体”的引用。换句话说，每一个Binder引用都是某一个Binder实体的引用，通过Binder引用可以在内核中找到它对应的Binder实体。如果将Server看作是Binder实体的话，那么Client就好比Binder引用。Client要和Server通信，它就是通过保存一个Server对象的Binder引用，再通过该Binder引用在内核中找到对应的Binder实体，进而找到Server对象，然后将通信内容发送给Server对象。 Binder实体和Binder引用都是内核(即，Binder驱动)中的数据结构。每一个Server在内核中就表现为一个Binder实体，而每一个Client则表现为一个Binder引用。这样，每个Binder引用都对应一个Binder实体，而每个Binder实体则可以多个Binder引用。 3、Binder buffer：binder_buffer 4、Binder进程binder_proc 5、Binder线程binder_thread binder机制到底是如何从Binder对象找到其对应的Binder实体呢？ 注意其中的那4个rb_root域，“rb”的意思是“red black”，可见binder_proc里搞出了4个红黑树。 其中，nodes树用于记录binder实体，refs_by_desc树和refs_by_node树则用于记录binder代理。之所以会有两个代理树，是为了便于快速查找，我们暂时只关心其中之一就可以了。threads树用于记录执行传输动作的线程信息。 在一个进程中，有多少“被其他进程进行跨进程调用的”binder实体，就会在该进程对应的nodes树中生成多少个红黑树节点。另一方面，一个进程要访问多少其他进程的binder实体，则必须在其refs_by_desc树中拥有对应的引用节点。 这4棵树的节点类型是不同的，threads树的节点类型为binder_thread，nodes树的节点类型为binder_node，refs_by_desc树和refs_by_node树的节点类型相同，为binder_ref。这些节点内部都会包含rb_node子结构，该结构专门负责连接节点的工作，和前文的hlist_node有点儿异曲同工，这也是linux上一个常用的小技巧。我们以nodes树为例 nodes树是用于记录binder实体的，所以nodes树中的每个binder_node节点，必须能够记录下相应binder实体的信息。因此请大家注意binder_node的ptr域和cookie域。 另一方面，refs_by_desc树和refs_by_node树的每个binder_ref节点则和上层的一个BpBinder对应，而且更重要的是，它必须具有和“目标binder实体的binder_node”进行关联的信息。 请注意binder_ref的那个node域，它负责和binder_node关联。另外，binder_ref中有两个类型为rb_node的域：rb_node_desc域和rb_node_node域，它们分别用于连接refs_by_desc树和refs_by_node。也就是说虽然binder_proc中有两棵引用树，但这两棵树用到的具体binder_ref节点其实是复用的。 binder_node.ptr对应于flat_binder_object.binder；binder_node.cookie对应于flat_binder_object.cookie。 上图只表示了从进程1向进程2发起跨进程传输的意思，其实反过来也是可以的，即进程2也可以通过自己的“引用树”节点找到进程1的“实体树”节点，并进行跨进程传输。 OK，现在我们可以更深入地说明binder句柄的作用了，比如进程1的BpBinder在发起跨进程调用时，向binder驱动传入了自己记录的句柄值，binder驱动就会在“进程1对应的binder_proc结构”的引用树中查找和句柄值相符的binder_ref节点，一旦找到binder_ref节点，就可以通过该节点的node域找到对应的binder_node节点，这个目标binder_node当然是从属于进程2的binder_proc啦，不过不要紧，因为binder_ref和binder_node都处于binder驱动的地址空间中，所以是可以用指针直接指向的。目标binder_node节点的cookie域，记录的其实是进程2中BBinder的地址，binder驱动只需把这个值反映给应用层，应用层就可以直接拿到BBinder了。这就是Binder完成精确打击的大体过程。 三、Android Binder系统驱动情景分析为了更深刻的了解Binder系统 注册服务、获取服务、使用服务的过程，在Driver层(kernel/drivers/staging/android/binder.c)的binder_thread_read()函数、binder_transaction()函数入打印log，让前面编写的C程序示例与binder驱动交互打印更详细的过程。 12345static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply)int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed) 已添加好打印log的binder.c文件见GitHub（注：搜索[/* print] 关键字）事先已经准备好打印log，现在结合log和Binder事务处理开始详细分析。注：log稍后分析再贴出。 （1）、Binder系统驱动情景分析—服务“Hello”注册过程 1.1、ServiceManager休眠等待回顾一下ServiceManager启动流程，ServiceManager进入binder_loop()后会休眠等待响应client请求。12345678910111213141516171819202122binder_loop()&#123; // 告诉Kernel，ServiceManager进程进入了消息循环状态。 readbuf[0] = BC_ENTER_LOOPER; binder_write(bs, readbuf, sizeof(unsigned)); bwr.write_size = 0; bwr.write_consumed = 0; bwr.write_buffer = 0; for (;;) &#123; bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (unsigned) readbuf; // 向Kernel中发送消息(先写后读)。 // 先将消息传递给Kernel，然后再从Kernel读取消息反馈 res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); // 解析读取的消息反馈 res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func); ... &#125;&#125; binder_write(bs, readbuf, sizeof(unsigned));会调用ioctl向内核发送数据。 1234567891011121314 int binder_write(struct binder_state *bs, void *data, size_t len)&#123; struct binder_write_read bwr; int res; bwr.write_size = len; bwr.write_consumed = 0; bwr.write_buffer = (uintptr_t) data; bwr.read_size = 0; bwr.read_consumed = 0; bwr.read_buffer = 0; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); return res;&#125; 如果 bwr.write_size &gt; 0，则调用binder_thread_write如果 bwr.read_size &gt;0，则调用binder_thread_read 123456789101112131415161718192021222324252627282930313233343536373839static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; // 中断等待函数。 ret = wait_event_interruptible(...); // 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。 thread = binder_get_thread(proc); ... switch (cmd) &#123; case BINDER_WRITE_READ: &#123; struct binder_write_read bwr; ... // 将binder_write_read从\"用户空间\" 拷贝到 \"内核空间\" if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; ... &#125; // 如果write_size&gt;0，则进行写操作 if (bwr.write_size &gt; 0) &#123; ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); ... &#125; // 如果read_size&gt;0，则进行读操作 if (bwr.read_size &gt; 0) &#123; ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); ... &#125; ... if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123; &#125; break; &#125; &#125; return ret;&#125; bwr.write_size &gt; 0; 继续查看binder_thread_write() 注：只有BR_TRANSACTION、BR_REPLY、BC_TRANSACTION、BC_REPLY涉及两进程其他所有BC_XXX、BR_XXX都只是App和驱动交互用于改变报告状态。 1234567891011121314151617181920212223242526int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed)&#123; uint32_t cmd; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // 读取binder_write_read.write_buffer中的内容。 // 每次读取32bit(即4个字节) while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123; // 从用户空间读取32bit到内核中，并赋值给cmd。 if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); switch (cmd) &#123; case BC_ENTER_LOOPER: thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED; break; ... &#125; // 更新bwr.write_consumed的值 *consumed = ptr - buffer; &#125; return 0;&#125; 当前线程进入BC_ENTER_LOOPER状态，等待请求。继续binder_loop()中的for(;;;)循环，bwr.read_size &gt;0;会通过binder_thread_read()读操作。 123456789101112131415161718static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block)&#123; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; int ret = 0; int wait_for_proc_work; // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区 if (*consumed == 0) &#123; if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; // 修改指针位置 ptr += sizeof(uint32_t); &#125; ...&#125; 可以看到驱动put_user(BR_NOOP, (uint32_t __user *)ptr)发送BR_NOOP到ServiceManager 对于所有的读操作，数据头都是BR_NOOP，如BR_REPLY123 ./service_manager &amp;[ 32.566620] service_manager (1362, 1362), binder_thread_write : BC_ENTER_LOOPER[ 32.566712] service_manager (1362, 1362), binder_thread_read : BR_NOOP 1.2、Clent（此处为Test_server）请求SM添加服务构造数据发送给驱动我们执行Test_server时，打印了很多数据，我们首先看一下数据的构造过程 和 组织格式，这有助于加深我们对binder系统的理解。 123456789101112131415161718int svcmgr_publish(struct binder_state *bs, uint32_t target, const char *name, void *ptr)&#123; int status; unsigned iodata[512/4]; struct binder_io msg, reply; bio_init(&amp;msg, iodata, sizeof(iodata), 4); bio_put_uint32(&amp;msg, 0); // strict mode header bio_put_string16_x(&amp;msg, SVC_MGR_NAME); bio_put_string16_x(&amp;msg, name); bio_put_obj(&amp;msg, ptr); if (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE)) return -1; status = bio_get_uint32(&amp;reply); binder_done(bs, &amp;msg, &amp;reply); return status;&#125; bio_init()、bio_put_uint32()、bio_put_string16_x()函数比较简洁。我们看下bio_put_obj()函数。构建初始化flat_binder_object结构体：12345678910111213void bio_put_obj(struct binder_io *bio, void *ptr)&#123; struct flat_binder_object *obj; obj = bio_alloc_obj(bio); if (!obj) return; obj-&gt;flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;// obj-&gt;type = BINDER_TYPE_BINDER;// obj-&gt;binder = (uintptr_t)ptr;// obj-&gt;cookie = 0;//0&#125; 数据结构示意图： Clent（此处为Test_server），test_server.c调用流程：-&gt;svcmgr_publish()-&gt;binder_call()-&gt;ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)-&gt;binder_thread_write()-&gt;binder_transaction() 现在数据构造好了，binder_call()会调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr) 123456789101112131415161718192021222324252627282930313233343536int binder_call(struct binder_state *bs, struct binder_io *msg, struct binder_io *reply, uint32_t target, uint32_t code)&#123; int res; struct binder_write_read bwr; struct &#123; uint32_t cmd; struct binder_transaction_data txn; &#125; __attribute__((packed)) writebuf; unsigned readbuf[32]; writebuf.cmd = BC_TRANSACTION; writebuf.txn.target.handle = target; writebuf.txn.code = code; writebuf.txn.flags = 0; writebuf.txn.data_size = msg-&gt;data - msg-&gt;data0; writebuf.txn.offsets_size = ((char*) msg-&gt;offs) - ((char*) msg-&gt;offs0); writebuf.txn.data.ptr.buffer = (uintptr_t)msg-&gt;data0; writebuf.txn.data.ptr.offsets = (uintptr_t)msg-&gt;offs0; bwr.write_size = sizeof(writebuf); bwr.write_consumed = 0; bwr.write_buffer = (uintptr_t) &amp;writebuf; hexdump(msg-&gt;data0, msg-&gt;data - msg-&gt;data0); for (;;) &#123; bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (uintptr_t) readbuf; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); ... res = binder_parse(bs, reply, (uintptr_t) readbuf, bwr.read_consumed, 0); &#125;&#125; [ 38.320197] test_server (1363, 1363), binder_thread_write : BC_TRANSACTION发送数据，进而会调用binder_thread_write()处理数据。 123456789101112131415161718192021222324252627282930313233343536373839binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; // 中断等待函数。 ret = wait_event_interruptible(...); // 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。 thread = binder_get_thread(proc); ... switch (cmd) &#123; case BINDER_WRITE_READ: &#123; struct binder_write_read bwr; ... // 将binder_write_read从\"用户空间\" 拷贝到 \"内核空间\" if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; ... &#125; // 如果write_size&gt;0，则进行写操作 if (bwr.write_size &gt; 0) &#123; ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); ... &#125; // 如果read_size&gt;0，则进行读操作 if (bwr.read_size &gt; 0) &#123; ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); ... &#125; ... if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123; &#125; break; &#125; &#125; return ret;&#125; 由于write_size&gt;0，调用binder_thread_write()处理数据：1234567891011121314151617181920212223242526272829303132333435int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed)&#123; uint32_t cmd; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // 读取binder_write_read.write_buffer中的内容。 // 每次读取32bit(即4个字节) while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123; // 从用户空间读取32bit到内核中，并赋值给cmd。 if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... switch (cmd) &#123; ... case BC_TRANSACTION: case BC_REPLY: &#123; struct binder_transaction_data tr; if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; &#125; ... &#125; // 更新bwr.write_consumed的值 *consumed = ptr - buffer; &#125; return 0;&#125; 由之前binder_call()分析，writebuf.cmd = BC_TRANSACTION;会执行binder_transaction()函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply)&#123; struct binder_transaction *t; struct binder_work *tcomplete; size_t *offp, *off_end; struct binder_proc *target_proc; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; struct list_head *target_list; wait_queue_head_t *target_wait; struct binder_transaction *in_reply_to = NULL; struct binder_transaction_log_entry *e; uint32_t return_error; ... if (reply) &#123; &#125; else &#123; if (tr-&gt;target.handle) &#123; target_node = ref-&gt;node; &#125; else &#123; // 事务目标对象是ServiceManager的binder实体 // 即，该事务是交给Service Manager来处理的。 target_node = binder_context_mgr_node; &#125; // 设置处理事务的目标进程 target_proc = target_node-&gt;proc; ... &#125; if (target_thread) &#123; ... &#125; else &#123; target_list = &amp;target_proc-&gt;todo; target_wait = &amp;target_proc-&gt;wait; &#125; ... // 分配一个待处理的事务t，t是binder事务(binder_transaction对象) t = kzalloc(sizeof(*t), GFP_KERNEL); // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。 tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); ... // 事务将交给target_proc进程进行处理 t-&gt;to_proc = target_proc; // 事务将交给target_thread线程进行处理 t-&gt;to_thread = target_thread; ... // 分配空间,从目的进程映射的空间分配buf t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); ... // 保存事务 t-&gt;buffer-&gt;transaction = t; // 保存事务的目标对象(即处理该事务的binder对象) t-&gt;buffer-&gt;target_node = target_node; offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); // 将\"用户空间的数据\"拷贝到内核中 // tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小 if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123; ... &#125; // 将\"用户空间的数据中所含对象的偏移地址\"拷贝到内核中 // tr-&gt;data.ptr.offsets就是数据中的对象偏移地址数组，tr-&gt;offsets_size就数据中的对象个数 // 拷贝之后，offp就是flat_binder_object对象数组在内核空间的偏移数组的起始地址 if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123; ... &#125; ... // off_end就是flat_binder_object对象数组在内核空间的偏移地址的结束地址 off_end = (void *)offp + tr-&gt;offsets_size; // 将所有的flat_binder_object对象读取出来 // 对TestServer而言，只有一个flat_binder_object对象。 for (; offp &lt; off_end; offp++) &#123; struct flat_binder_object *fp; ... fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp); switch (fp-&gt;type) &#123; case BINDER_TYPE_BINDER: case BINDER_TYPE_WEAK_BINDER: &#123; struct binder_ref *ref; // 在proc中查找binder实体对应的binder_node struct binder_node *node = binder_get_node(proc, fp-&gt;binder); // 若找不到，则新建一个binder_node；下次就可以直接使用了。 if (node == NULL) &#123; node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie); &#125; ... // 在target_proc(即，ServiceManager的进程上下文)中查找是否包行\"该Binder实体的引用\"， // 如果没有找到的话，则将\"该binder实体的引用\"添加到target_proc-&gt;refs_by_node红黑树中。这样，就可以通过Service Manager对该Binder实体进行管理了。 ref = binder_get_ref_for_node(target_proc, node); // 现在修改目的进程type，表示ServiceManager持有TestServer引用，TestServer进程才能拥有实体。 if (fp-&gt;type == BINDER_TYPE_BINDER) fp-&gt;type = BINDER_TYPE_HANDLE; else fp-&gt;type = BINDER_TYPE_WEAK_HANDLE; // 修改handle。handle和binder是联合体，这里将handle设为引用的描述。 // 根据该handle可以找到\"该binder实体在target_proc中的binder引用\"； // 即，可以根据该handle，可以从Service Manager找到对应的Binder实体的引用，从而获取Binder实体。 fp-&gt;handle = ref-&gt;desc; // 增加引用计数，防止\"该binder实体\"在使用过程中被销毁。 binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE, &amp;thread-&gt;todo); ... &#125; break; ... &#125; &#125; if (reply) &#123; .. &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123; BUG_ON(t-&gt;buffer-&gt;async_transaction != 0); t-&gt;need_reply = 1; t-&gt;from_parent = thread-&gt;transaction_stack; // 将当前事务添加到当前线程的事务栈中 thread-&gt;transaction_stack = t; &#125; else &#123; ... &#125; // 设置事务的类型为BINDER_WORK_TRANSACTION t-&gt;work.type = BINDER_WORK_TRANSACTION; // 将事务添加到target_list队列中，即target_list的待处理事务中 list_add_tail(&amp;t-&gt;work.entry, target_list); // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。 list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); // 唤醒目标进程 if (target_wait) wake_up_interruptible(target_wait); return; ...&#125; 说明：这里的tr-&gt;target.handle=0，因此，会设置target_node为ServiceManager对应的Binder实体。下面是target_node,target_proc等值初始化之后的值。 1234target_node = binder_context_mgr_node; // 目标节点为Service Manager对应的Binder实体target_proc = target_node-&gt;proc; // 目标进程为Service Manager对应的binder_proc进程上下文信息target_list = &amp;target_thread-&gt;todo; // 待处理事务队列target_wait = &amp;target_thread-&gt;wait; // 等待队列 小结：驱动接收到TestServer发送的数据后，驱动主要工作：（1）根据Handle = 0 找到目的进程ServiceManager（2）把数据通过copy_from_user()放到目的进程ServiceManager的空间（mmap）（3）处理offs数据，即解析flat_binder_object结构体a. 为TestServer构造binder_node node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);b.构造binder_ref给目的进程ServiceManagerref = binder_get_ref_for_node(target_proc, node);c.增加引用计数TestServerbinder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE, &amp;thread-&gt;todo); 增加引用计数会添加work.entry（BR_INCREFS、BR_ACQUIR）到TestServer todod队列list_add_tail(&amp;node-&gt;work.entry, target_list) 说明：就新建Binder实体的引用，并将其添加到target_proc-&gt;refs_by_node红黑树 和 target_proc-&gt;refs_by_desc红黑树中。 这样，ServiceManager的进程上下文中就存在Hello Service的Binder引用，ServiceManager也就可以对Hello Service进行管理了！然后，修改fp-&gt;type=BINDER_TYPE_HANDLE，并使fp-&gt;handle = ref-&gt;desc。 （4)新建一个待处理事务t和待完成的工作tcomplete，并对它们进行初始化。待处理事务t会被提交给目标(即ServiceManager对应的Binder实体)进行处理；而待完成的工作tcomplete则是为了反馈给TestServer服务，告诉TestServer它的请求Binder驱动已经收到了。注意，这里仅仅是告诉TestServer该请求已经被收到，而不是处理完毕！待ServiceManager处理完毕该请求之后，Binder驱动会再次反馈相应的消息给TestServer。（5）binder_thread_write()中执行binder_transaction()后，会更新*consumed的值，即bwr.write_consumed的值（6）此时，TestServer进程还会继续运行，而且它也通过wake_up_interruptible()唤醒了ServiceManager进程。 12// 更新bwr.write_consumed的值*consumed = ptr - buffer; 接下来，ioctl()会执行binder_thread_read()来设置反馈数据给TestServer进程 123456789101112131415161718192021222324252627282930313233343536 static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block)&#123; // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区 if (*consumed == 0) &#123; if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); &#125; ... while (1) &#123; uint32_t cmd; struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // 如果当前线程的\"待完成工作\"不为空，则取出待完成工作。 if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); &#125; ... switch (w-&gt;type) &#123; ... case BINDER_WORK_TRANSACTION_COMPLETE: &#123; cmd = BR_TRANSACTION_COMPLETE; // 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; &#125; break; ... // 更新bwr.read_consumed的值 *consumed = ptr - buffer;&#125; 首先发送BR_NOOP给TestServer，然后处理todo队列，处理完成后会发送BR_TRANSACTION_COMPLETE。 现在内核已经处理完数据，我们从log看看数据发生了哪些变化：我们发现flat_binder_object结构体的type值发生了变化，binder变成了Handle，看一下结构体，handler 和 binder是一个union，占用同一个位置；Handle为1代表第一个引用，意思是在ServiceManager进程里面根据1能找到第一个binder_ref，根据binder_ref能找到服务hello的binder_node实体。 接下来就等待ServiceManager处理完成后，回复消息。 1.3、唤醒ServiceManager执行添加“hello”服务前面驱动已经创建好TestServer的binder_node，现在唤醒ServiceManager添加svcinfo看看ServiceManager被唤醒后，会干些什么。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block)&#123; ... wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp; list_empty(&amp;thread-&gt;todo); while (1) &#123; struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // 如果当前线程的\"待完成工作\"不为空，则取出待完成工作。 if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) ... switch (w-&gt;type) &#123; case BINDER_WORK_TRANSACTION: &#123; t = container_of(w, struct binder_transaction, work); &#125; break; ... &#125; // t-&gt;buffer-&gt;target_node是目标节点。 // 这里，addService请求的目标是ServiceManager，因此target_node是ServiceManager对应的节点； // 它的值在事务交互时(binder_transaction中)，被赋值为ServiceManager对应的Binder实体。 if (t-&gt;buffer-&gt;target_node) &#123; // 事务目标对应的Binder实体(即，ServiceManager对应的Binder实体) struct binder_node *target_node = t-&gt;buffer-&gt;target_node; // Binder实体在用户空间的地址(ServiceManager的ptr为NULL) tr.target.ptr = target_node-&gt;ptr; // Binder实体在用户空间的其它数据(ServiceManager的cookie为NULL) tr.cookie = target_node-&gt;cookie; t-&gt;saved_priority = task_nice(current); if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) binder_set_nice(t-&gt;priority); else if (!(t-&gt;flags &amp; TF_ONE_WAY) || t-&gt;saved_priority &gt; target_node-&gt;min_priority) binder_set_nice(target_node-&gt;min_priority); **cmd = BR_TRANSACTION;//将命令改为BR_TRANSACTION &#125; else &#123; tr.target.ptr = NULL; tr.cookie = NULL; cmd = BR_REPLY; &#125; // 交易码 tr.code = t-&gt;code; tr.flags = t-&gt;flags; tr.sender_euid = t-&gt;sender_euid; if (t-&gt;from) &#123; struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk; tr.sender_pid = task_tgid_nr_ns(sender, current-&gt;nsproxy-&gt;pid_ns); &#125; else &#123; tr.sender_pid = 0; &#125; // 数据大小 tr.data_size = t-&gt;buffer-&gt;data_size; // 数据中对象的偏移数组的大小(即对象的个数) tr.offsets_size = t-&gt;buffer-&gt;offsets_size; // 数据 tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset; // 数据中对象的偏移数组 tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *)); // 将cmd指令写入到ptr，即传递到用户空间 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; // 将tr数据拷贝到用户空间 ptr += sizeof(uint32_t); if (copy_to_user(ptr, &amp;tr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); ... // 删除已处理的事务 list_del(&amp;t-&gt;work.entry); t-&gt;buffer-&gt;allow_user_free = 1; // 设置回复信息 if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123; // 该事务会发送给Service Manager守护进程进行处理。 // Service Manager处理之后，还需要给Binder驱动回复处理结果。 // 这里设置Binder驱动回复信息。 t-&gt;to_parent = thread-&gt;transaction_stack; // to_thread表示Service Manager反馈后，将反馈结果交给当前thread进行处理 t-&gt;to_thread = thread; // transaction_stack交易栈保存当前事务。用于之处反馈是针对哪个事务的。 thread-&gt;transaction_stack = t; &#125; else &#123; ... &#125; break; &#125;done: // 更新bwr.read_consumed的值 *consumed = ptr - buffer; ... return 0;&#125; 说明：ServiceManager进程在调用wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread))进入等待之后，被TestServer进程唤醒。唤醒之后，binder_has_thread_work()为true，因为ServiceManager的待处理事务队列中有个待处理事务(即，TestServer添加服务的请求)。(01) 进入while循环后，首先取出待处理事务。(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction*类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让ServiceManager读取后进行处理。 Service Manager守护进程在处理完事务之后，需要反馈结果给Binder驱动。因此，接下来会设置t-&gt;to_thread和t-&gt;transaction_stack等成员。最后，修改*consumed的值，即bwr.read_consumed的值，表示待读取内容的大小。执行完binder_thread_read()之后，回到binder_ioctl()中，执行copy_to_user()将数据拷贝到用户空间。接下来，就回到了Service Manager的守护进程当中，即回到binder_loop()中。binder_loop()会将ioctl()反馈的数据发送给binder_parse()进行解析。123456789101112131415161718192021222324252627int binder_parse(struct binder_state *bs, struct binder_io *bio, uintptr_t ptr, size_t size, binder_handler func)&#123; switch(cmd) &#123; case BR_NOOP: case BR_TRANSACTION: &#123; struct binder_transaction_data *txn = (struct binder_transaction_data *) ptr; if ((end - ptr) &lt; sizeof(*txn)) &#123; ALOGE(\"parse: txn too small!\\n\"); return -1; &#125; binder_dump_txn(txn); if (func) &#123; unsigned rdata[256/4]; struct binder_io msg; struct binder_io reply; int res; bio_init(&amp;reply, rdata, sizeof(rdata), 4); bio_init_from_txn(&amp;msg, txn); res = func(bs, txn, &amp;msg, &amp;reply); binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res); &#125; ptr += sizeof(*txn); break; &#125;&#125; 首先会调用svcmgr_handler()-&gt;do_add_service()1234567891011121314151617181920212223242526272829int do_add_service(struct binder_state *bs, const uint16_t *s, size_t len, uint32_t handle, uid_t uid, int allow_isolated, pid_t spid)&#123; struct svcinfo *si; si = find_svc(s, len); if (si) &#123; if (si-&gt;handle) &#123; svcinfo_death(bs, si); &#125; si-&gt;handle = handle; &#125; else &#123; si = malloc(sizeof(*si) + (len + 1) * sizeof(uint16_t)); si-&gt;handle = handle; si-&gt;len = len; memcpy(si-&gt;name, s, (len + 1) * sizeof(uint16_t)); si-&gt;name[len] = '\\0'; si-&gt;death.func = (void*) svcinfo_death; si-&gt;death.ptr = si; si-&gt;allow_isolated = allow_isolated; si-&gt;next = svclist; svclist = si; &#125; binder_acquire(bs, handle); binder_link_to_death(bs, handle, &amp;si-&gt;death); return 0;&#125; 可以看到首先为hello服务新分配一个结构体svcinfo，然后将handle赋值给svcinfo，这也是以后我们查找服务所得到的handle。然后调动了binder_acquire、binder_link_to_death发送信息给驱动。[ 38.467270] service_manager (1362, 1362), binder_thread_write : BC_ACQUIRE[ 38.480122] service_manager (1362, 1362), binder_thread_write : BC_REQUEST_DEATH_NOTIFICATION接着看binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res); 1234567891011121314void binder_send_reply(struct binder_state *bs, struct binder_io *reply, binder_uintptr_t buffer_to_free, int status)&#123; data.cmd_free = BC_FREE_BUFFER; data.buffer = buffer_to_free; data.cmd_reply = BC_REPLY; data.txn.target.ptr = 0; data.txn.cookie = 0; data.txn.code = 0; ... binder_write(bs, &amp;data, sizeof(data));&#125; 可以看到有BC_FREE_BUFFER、BC_REPLY，通过binder_write(bs, &amp;data, sizeof(data))回复BC_REPLY到驱动。 驱动处理消息跟之前流程类似，这里不再分析。简单总结：1、驱动接收到BC_REPLY请求，会新建一个待处理事务t（TestServer处理）和待完成的工作tcomplete（service_manager处理）2、然后唤醒TestServer处理BC_REPLY请求至此，已经成功添加Hello Servicesvcmgr: add_service(‘hello’), handle = 1 （2）、Binder系统驱动情景分析—TestClent获取“Hello”服务过程 2.0、构造数据 2.1、发送数据给ServiceManagerbwr初始化完成之后，调用ioctl(,BINDER_WRITE_READ,)和Binder驱动进行交互。 12345678910111213141516171819202122232425262728293031static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; switch (cmd) &#123; case BINDER_WRITE_READ: &#123; struct binder_write_read bwr; // 将binder_write_read从\"用户空间\" 拷贝到 \"内核空间\" if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; &#125; // 如果write_size&gt;0，则进行写操作 if (bwr.write_size &gt; 0) &#123; ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); &#125; // 如果read_size&gt;0，则进行读操作 if (bwr.read_size &gt; 0) &#123; ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); &#125; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123; ret = -EFAULT; goto err; &#125; break; &#125;&#125; 首先，会将binder_write_read从用户空间拷贝到内核空间之后。拷贝之后，读取出来的bwr.write_size和bwr.read_size都&gt;0，因此先写后读。即，先执行binder_thread_write()，然后执行binder_thread_read()。 2.2、binder_thread_write()处理数据1234567891011121314151617181920212223242526272829303132333435int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed)&#123; uint32_t cmd; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // 读取binder_write_read.write_buffer中的内容。 // 每次读取32bit(即4个字节) while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123; // 从用户空间读取32bit到内核中，并赋值给cmd。 if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... switch (cmd) &#123; ... case BC_TRANSACTION: case BC_REPLY: &#123; struct binder_transaction_data tr; if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; &#125; ... &#125; // 更新bwr.write_consumed的值 *consumed = ptr - buffer; &#125; return 0;&#125; 说明：MediaPlayer发送的指令是BC_TRANSACTION，这里只关心与BC_TRANSACTION相关的部分。在通过copy_from_user()将数据拷贝从用户空间拷贝到内核空间之后，就调用binder_transaction()进行处理。 2.3、Binder驱动中binder_transaction()的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply)&#123; struct binder_transaction *t; struct binder_work *tcomplete; size_t *offp, *off_end; struct binder_proc *target_proc; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; struct list_head *target_list; wait_queue_head_t *target_wait; struct binder_transaction *in_reply_to = NULL; struct binder_transaction_log_entry *e; uint32_t return_error; ... if (reply) &#123; ... &#125; else &#123; if (tr-&gt;target.handle) &#123; ... &#125; else &#123; // 该getService是从ServiceManager中获取MediaPlayer； // 因此事务目标对象是ServiceManager的binder实体。 target_node = binder_context_mgr_node; ... &#125; ... // 设置处理事务的目标进程 target_proc = target_node-&gt;proc; ... &#125; if (target_thread) &#123; ... &#125; else &#123; target_list = &amp;target_proc-&gt;todo; target_wait = &amp;target_proc-&gt;wait; &#125; ... // 分配一个待处理的事务t，t是binder事务(binder_transaction对象) t = kzalloc(sizeof(*t), GFP_KERNEL); ... // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。 tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); ... t-&gt;debug_id = ++binder_last_id; ... // 设置from，表示该事务是MediaPlayer线程发起的 if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) t-&gt;from = thread; else t-&gt;from = NULL; // 下面的一些赋值是初始化事务t t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid; // 事务将交给target_proc进程进行处理 t-&gt;to_proc = target_proc; // 事务将交给target_thread线程进行处理 t-&gt;to_thread = target_thread; // 事务编码 t-&gt;code = tr-&gt;code; // 事务标志 t-&gt;flags = tr-&gt;flags; // 事务优先级 t-&gt;priority = task_nice(current); ... // 分配空间 t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); ... t-&gt;buffer-&gt;allow_user_free = 0; t-&gt;buffer-&gt;debug_id = t-&gt;debug_id; // 保存事务 t-&gt;buffer-&gt;transaction = t; // 保存事务的目标对象(即处理该事务的binder对象) t-&gt;buffer-&gt;target_node = target_node; trace_binder_transaction_alloc_buf(t-&gt;buffer); if (target_node) binder_inc_node(target_node, 1, 0, NULL); offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); // 将\"用户空间的数据\"拷贝到内核中 // tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小 if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123; ... &#125; // 将\"用户空间的数据中所含对象的偏移地址\"拷贝到内核中 // MediaPlayer中不包含对象, offp=null if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123; ... &#125; ... // MediaPlayer中不包含对象, off_end为null off_end = (void *)offp + tr-&gt;offsets_size; // MediaPlayer中不包含对象, offp=off_end for (; offp &lt; off_end; offp++) &#123; ... &#125; if (reply) &#123; .. &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123; BUG_ON(t-&gt;buffer-&gt;async_transaction != 0); t-&gt;need_reply = 1; t-&gt;from_parent = thread-&gt;transaction_stack; // 将当前事务添加到当前线程的事务栈中 thread-&gt;transaction_stack = t; &#125; else &#123; ... &#125; // 设置事务的类型为BINDER_WORK_TRANSACTION t-&gt;work.type = BINDER_WORK_TRANSACTION; // 将事务添加到target_list队列中，即target_list的待处理事务中 list_add_tail(&amp;t-&gt;work.entry, target_list); // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。 list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); // 唤醒目标进程 if (target_wait) wake_up_interruptible(target_wait); return; ...&#125; 说明：参数reply=0，表明这是个请求事务，而不是反馈。binder_transaction新建会新建”一个待处理事务t”和”待完成的工作tcomplete”，并根据请求的数据对它们进行初始化。(01) TestClent的getService请求是提交给ServiceManager进行处理的，因此，”待处理事务t”会被添加到ServiceManager的待处理事务队列中。此时的target_thread是ServiceManager对应的线程，而target_proc则是ServiceManager对应的进程上下文环境。(02) 此时，Binder驱动已经收到了TestClent的getService请求；于是，将一个BINDER_WORK_TRANSACTION_COMPLETE类型的”待完成工作tcomplete”添加到当前线程(即，TestClent线程)的待处理事务队列中。目的是告诉TestClent，Binder驱动已经收到它的getService请求了。(03) 最后，调用wake_up_interruptible(target_wait)将ServiceManager唤醒。 接下来，还是先分析完TestClent线程，再看ServiceManager被唤醒后做了些什么。 binder_transaction()执行完毕之后，就会返回到binder_thread_write()中。binder_thread_write()更新bwr.write_consumed的值后，就返回到binder_ioctl()继续执行”读”动作。即执行binder_thread_read()。 2.4、Binder驱动中binder_thread_read()的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block)&#123; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; int ret = 0; int wait_for_proc_work; // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区 if (*consumed == 0) &#123; if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); &#125;retry: // 等待proc进程的事务标记。 // 当线程的事务栈为空 并且 待处理事务队列为空时，该标记位true。 wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp; list_empty(&amp;thread-&gt;todo); ... if (wait_for_proc_work) &#123; ... &#125; else &#123; if (non_block) &#123; ... &#125; else ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread)); &#125; ... while (1) &#123; uint32_t cmd; struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // 如果当前线程的\"待完成工作\"不为空，则取出待完成工作。 if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) ... else &#123; if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) /* no data added */ goto retry; break; &#125; ... switch (w-&gt;type) &#123; ... case BINDER_WORK_TRANSACTION_COMPLETE: &#123; cmd = BR_TRANSACTION_COMPLETE; // 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... // 待完成事务已经处理完毕，将其从待完成事务队列中删除。 list_del(&amp;w-&gt;entry); kfree(w); binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE); &#125; break; ... &#125; if (!t) continue; ... &#125; ... // 更新bwr.read_consumed的值 *consumed = ptr - buffer; ... return 0;&#125; 说明：(01) bwr.read_consumed=0，即if (*consumed == 0)为true。因此，会将BR_NOOP写入到bwr.read_buffer中。(02) thread-&gt;transaction_stack不为空，thread-&gt;todo也不为空。因为，前面在binder_transaction()中有将一个BINDER_WORK_TRANSACTION_COMPLETE类型的待完成工作添加到thread的待完成工作队列中。因此，wait_for_proc_work为false。(03) binder_has_thread_work(thread)为true。因此，在调用wait_event_interruptible()时，不会进入等待状态，而是继续运行。(04) 进入while循环后，通过list_first_entry()取出待完成工作w。w的类型w-&gt;type=BINDER_WORK_TRANSACTION_COMPLETE，进入到对应的switch分支。随后，将BR_TRANSACTION_COMPLETE写入到bwr.read_buffer中。此时，待处理工作已经完成，将其从当前线程的待处理工作队列中删除。(05) 最后，更新bwr.read_consumed的值。 经过binder_thread_read()处理之后，bwr.read_buffer中包含了两个指令：BR_NOOP和BR_TRANSACTION_COMPLETE。 2.5、ServiceManager处理getService请求下面看看ServiceManager被唤醒之后，是如何处理getService请求的 12345678910111213141516171819202122int binder_parse(struct binder_state *bs, struct binder_io *bio, uint32_t *ptr, uint32_t size, binder_handler func)&#123; while (ptr &lt; end) &#123; case BR_TRANSACTION: &#123; struct binder_txn *txn = (void *) ptr; ... if (func) &#123; unsigned rdata[256/4]; struct binder_io msg; // 用于保存&quot;Binder驱动反馈的信息&quot; struct binder_io reply; // 用来保存&quot;回复给Binder驱动的信息&quot; int res; // 初始化reply bio_init(&amp;reply, rdata, sizeof(rdata), 4); // 根据txt(Binder驱动反馈的信息)初始化msg bio_init_from_txn(&amp;msg, txn); // 消息处理 res = func(bs, txn, &amp;msg, &amp;reply); // 反馈消息给Binder驱动。 binder_send_reply(bs, &amp;reply, txn-&gt;data, res);&#125; binder_send_reply(bs, &amp;reply, txn-&gt;data, res);-&gt;binder_write() 123456789101112131415161718binder_write()int binder_write(struct binder_state *bs, void *data, unsigned len)&#123; struct binder_write_read bwr; int res; bwr.write_size = len; bwr.write_consumed = 0; bwr.write_buffer = (unsigned) data; bwr.read_size = 0; bwr.read_consumed = 0; bwr.read_buffer = 0; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); if (res &lt; 0) &#123; fprintf(stderr,\"binder_write: ioctl failed (%s)\\n\", strerror(errno)); &#125; return res;&#125; 说明：binder_write()会将数据封装到binder_write_read的变量bwr中；其中，bwr.read_size=0，而bwr.write_size&gt;0。接着，便通过ioctl(,BINDER_WRITE_READ,)和Binder驱动交互，将数据反馈给Binder驱动。 再次回到Binder驱动的binder_ioctl()对应的BINDER_WRITE_READ分支中。此时，由于bwr.read_size=0，而bwr.write_size&gt;0；因此，Binder驱动只调用binder_thread_write进行写操作，而不会进行读。 返回数据： handle = 1 代表第一个 2.6、Binder驱动中处理ServiceManager返回数据12345678910111213141516171819202122232425262728293031323334353637int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed)&#123; uint32_t cmd; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // 读取binder_write_read.write_buffer中的内容。 // 每次读取32bit(即4个字节) while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123; // 从用户空间读取32bit到内核中，并赋值给cmd。 if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... switch (cmd) &#123; case BC_FREE_BUFFER: ... case BC_TRANSACTION: case BC_REPLY: &#123; struct binder_transaction_data tr; if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; &#125; ... &#125; // 更新bwr.write_consumed的值 *consumed = ptr - buffer; &#125; return 0;&#125; binder_thread_write()进入BC_REPLY之后，会将数据拷贝到内核空间，然后调用binder_transaction()进行处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply)&#123; struct binder_transaction *t; struct binder_work *tcomplete; size_t *offp, *off_end; struct binder_proc *target_proc; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; struct list_head *target_list; wait_queue_head_t *target_wait; struct binder_transaction *in_reply_to = NULL; struct binder_transaction_log_entry *e; uint32_t return_error; ... if (reply) &#123; // 事务栈 in_reply_to = thread-&gt;transaction_stack; ... // 设置优先级 binder_set_nice(in_reply_to-&gt;saved_priority); ... thread-&gt;transaction_stack = in_reply_to-&gt;to_parent; // 发起请求的线程，即MediaPlayer所在线程。 // from的值，是MediaPlayer发起请求时在binder_transaction()中赋值的。 target_thread = in_reply_to-&gt;from; ... // MediaPlayer对应的进程 target_proc = target_thread-&gt;proc; &#125; else &#123; ... &#125; if (target_thread) &#123; e-&gt;to_thread = target_thread-&gt;pid; target_list = &amp;target_thread-&gt;todo; target_wait = &amp;target_thread-&gt;wait; &#125; else &#123; ... &#125; e-&gt;to_proc = target_proc-&gt;pid; // 分配一个待处理的事务t，t是binder事务(binder_transaction对象) t = kzalloc(sizeof(*t), GFP_KERNEL); if (t == NULL) &#123; return_error = BR_FAILED_REPLY; goto err_alloc_t_failed; &#125; // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。 tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); if (tcomplete == NULL) &#123; return_error = BR_FAILED_REPLY; goto err_alloc_tcomplete_failed; &#125; binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE); t-&gt;debug_id = ++binder_last_id; e-&gt;debug_id = t-&gt;debug_id; if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) t-&gt;from = thread; else t-&gt;from = NULL; // 下面的一些赋值是初始化事务t t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid; // 事务将交给target_proc进程进行处理 t-&gt;to_proc = target_proc; // 事务将交给target_thread线程进行处理 t-&gt;to_thread = target_thread; // 事务编码 t-&gt;code = tr-&gt;code; // 事务标志 t-&gt;flags = tr-&gt;flags; // 事务优先级 t-&gt;priority = task_nice(current); // 分配空间 t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); if (t-&gt;buffer == NULL) &#123; return_error = BR_FAILED_REPLY; goto err_binder_alloc_buf_failed; &#125; t-&gt;buffer-&gt;allow_user_free = 0; t-&gt;buffer-&gt;debug_id = t-&gt;debug_id; // 保存事务 t-&gt;buffer-&gt;transaction = t; // target_node为NULL t-&gt;buffer-&gt;target_node = target_node; trace_binder_transaction_alloc_buf(t-&gt;buffer); if (target_node) binder_inc_node(target_node, 1, 0, NULL); offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); // 将\"用户传入的数据\"保存到事务中 if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123; ... &#125; // 将\"用户传入的数据偏移地址\"保存到事务中 if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123; ... &#125; ... off_end = (void *)offp + tr-&gt;offsets_size; // 将flat_binder_object对象读取出来， // 这里就是Service Manager中反馈的MediaPlayerService对象。 for (; offp &lt; off_end; offp++) &#123; struct flat_binder_object *fp; ... fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp); switch (fp-&gt;type) &#123; ... case BINDER_TYPE_HANDLE: case BINDER_TYPE_WEAK_HANDLE: &#123; // 根据handle获取对应的Binder引用，即得到MediaPlayerService的Binder引用 struct binder_ref *ref = binder_get_ref(proc, fp-&gt;handle); if (ref == NULL) &#123; ... &#125; // ref-&gt;node-&gt;proc是MediaPlayerService的进程上下文环境， // 而target_proc是MediaPlayer的进程上下文环境 if (ref-&gt;node-&gt;proc == target_proc) &#123; ... &#125; else &#123; struct binder_ref *new_ref; // 在MediaPlayer进程中引用\"MediaPlayerService\"。 // 表现为，执行binder_get_ref_for_node()会，会先在MediaPlayer进程中查找是否存在MediaPlayerService对应的Binder引用； // 很显然是不存在的。于是，并新建MediaPlayerService对应的Binder引用，并将其添加到MediaPlayer的Binder引用红黑树中。 new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node); if (new_ref == NULL) &#123; ... &#125; // 将new_ref的引用描述复制给fp-&gt;handle。 fp-&gt;handle = new_ref-&gt;desc; binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, NULL); ... &#125; &#125; break; &#125; &#125; if (reply) &#123; binder_pop_transaction(target_thread, in_reply_to); &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123; ... &#125; else &#123; ... &#125; // 设置事务的类型为BINDER_WORK_TRANSACTION t-&gt;work.type = BINDER_WORK_TRANSACTION; // 将事务添加到target_list队列中，即target_list的待处理事务中 list_add_tail(&amp;t-&gt;work.entry, target_list); // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。 list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); // 唤醒目标进程 if (target_wait) wake_up_interruptible(target_wait); return; ...&#125; 说明：reply=1，这里只关注reply部分。(01) 此反馈最终是要回复给TestClient的。因此，target_thread被赋值为TestServer所在的线程，target_proc则是TestClient对应的进程，target_node为null。(02) 这里，先看看for循环里面的内容，取出BR_REPLY指令所发送的数据，然后获取数据中的flat_binder_object变量fp。因为fp-&gt;type为BINDER_TYPE_HANDLE，因此进入BINDER_TYPE_HANDLE对应的分支。接着，通过binder_get_ref()获取Hello Service对应的Binder引用；很明显，能够正常获取到Hello Service的Binder引用。因为在Hello Service调用addService请求时，已经创建了它的Binder引用。 binder_get_ref_for_node()的作用是在TestClent进程上下文中添加”TestServer对应的Binder引用”。这样，后面就可以根据该Binder引用一步步的获取TestServer对象。 最后，将Binder引用的描述赋值给fp-&gt;handle。(03) 此时，Service Manager已经处理了getService请求。便调用binder_pop_transaction(target_thread, in_reply_to)将事务从”target_thread的事务栈”中删除，即从MediaPlayer线程的事务栈中删除该事务。(04) 新建的”待处理事务t”的type为设为BINDER_WORK_TRANSACTION后，会被添加到MediaPlayer的待处理事务队列中。(05) 此时，Service Manager已经处理了getService请求，而Binder驱动在等待它的回复。于是，将一个BINDER_WORK_TRANSACTION_COMPLETE类型的”待完成工作tcomplete”(作为回复)添加到当前线程(即，Service Manager线程)的待处理事务队列中。(06) 最后，调用wake_up_interruptible()唤醒TestServer。TestServer被唤醒后，会对事务BINDER_WORK_TRANSACTION进行处理。 OK，到现在为止，还有两个待处理事务：(01) ServiceManager待处理事务列表中有个BINDER_WORK_TRANSACTION_COMPLETE类型的事务 (02) TestServer待处理事务列表中有个BINDER_WORK_TRANSACTION事务。 2.7. Testclient获取handle （3）、Binder系统驱动情景分析—TestClent使用“Hello”服务过程构造数据发送数据”weidongshan” 四、Android Binder系统-Native层前面我们分析内核驱动Binder使用过程，可以看到，binder系统在内核能正常完成IPC通信，接下来分析Android framwork层，最后是App层。 Framework是一个中间层，它对接了底层实现，封装了复杂的内部逻辑，并提供供外部使用的接口。Framework层是应用程序开发的基础。 Binder Framework层分为C++和Java两个部分，为了达到功能的复用，中间通过JNI进行衔接。 Binder Framework的C++部分，头文件位于这个路径：/frameworks/native/include/binder/，实现位于这个路径：/frameworks/native/libs/binder/ 。Binder库最终会编译成一个动态链接库：libbinder.so，供其他进程链接使用。 为了便于说明，下文中我们将Binder Framework 的C++部分称之为libbinder。首先说一下ServiceManager，然后详细介绍。 (1)、ServiceManager类图(Native层)IServiceManager相关类如下图所示： IServiceManager是表示servicemanager的接口，有如下方法： 1) getService获得binder service引用， 2) checkService获得binder service引用， 3) addService添加binder service， 4) listServices 列举所有binder service。 servicemanager的binder service服务端其实是在frameworks/base/cmds/servicemanager 里实现，BnServiceMananger实际上并未使用。BpServiceMananger就是利用获得的IBinder指针建立的IServiceMananger对象的实际类型。 (2)、Binder框架Native层libbinder中，将实现分为Proxy和Native两端。Proxy对应了上文提到的Client端，是服务对外提供的接口。而Native是服务实现的一端，对应了上文提到的Server端。类名中带有小写字母p的（例如BpInterface），就是指Proxy端。类名带有小写字母n的（例如BnInterface），就是指Native端。 Proxy代表了调用方，通常与服务的实现不在同一个进程，因此下文中，我们也称Proxy端为“远程”端。Native端是服务实现的自身，因此下文中，我们也称Native端为”本地“端。 这里，我们先对libbinder中的主要类做一个简要说明，了解一下它们的关系，然后再详细的讲解。 类名 说明 BpRefBase RefBase的子类，提供remote()方法获取远程Binder IInterface Binder服务接口的基类，Binder服务通常需要同时提供本地接口和远程接口 BpInterface 远程接口的基类，远程接口是供客户端调用的接口集 BnInterface 本地接口的基类，本地接口是需要服务中真正实现的接口集 IBiner Binder对象的基类，BBinder和BpBinder都是这个类的子类 BpBinder 远程Binder，这个类提供transact方法来发送请求，BpXXX实现中会用到 BBinder 本地Binder，服务实现方的基类，提供了onTransact接口来接收请求 ProcessState 代表了使用Binder的进程 IPCThreadState 代表了使用Binder的线程，这个类中封装了与Binder驱动通信的逻辑 Parcel 在Binder上传递的数据的包装器 下图描述了这些类之间的关系： 另外说明一下，Binder服务的实现类（图中紫色部分）通常都会遵守下面的命名规则： ☯ 服务的接口使用I字母作为前缀☯ 远程接口使用Bp作为前缀☯ 本地接口使用Bn作为前缀 看了上面这些介绍，你可能还是不太容易理解。不过不要紧，下面我们会逐步拆分讲解这些内容。 在这幅图中，浅黄色部分的结构是最难理解的，因此我们先从它们着手。 我们先来看看IBinder这个类。这个类描述了所有在Binder上传递的对象，它既是Binder本地对象BBinder的父类，也是Binder远程对象BpBinder的父类。这个类中的主要方法说明如下： 方法名 说明 localBinder 获取本地Binder对象 remoteBinder 获取远程Binder对象 transact 进行一次Binder操作 queryLocalInterface 尝试获取本地Binder，如何失败返回NULL getInterfaceDescriptor 获取Binder的服务接口描述，其实就是Binder服务的唯一标识 isBinderAlive 查询Binder服务是否还活着 pingBinder 发送PING_TRANSACTION给Binder服务 BpBinder的实例代表了远程Binder，这个类的对象将被客户端调用。其中handle方法会返回指向Binder服务实现者的句柄，这个类最重要就是提供了transact方法，这个方法会将远程调用的参数封装好发送的Binder驱动。 由于每个Binder服务通常都会提供多个服务接口，而这个方法中的uint32_t code参数就是用来对服务接口进行编号区分的。Binder服务的每个接口都需要指定一个唯一的code，这个code要在Proxy和Native端配对好。当客户端将请求发送到服务端的时候，服务端根据这个code（onTransact方法中）来区分调用哪个接口方法。 BBinder的实例代表了本地Binder，它描述了服务的提供方，所有Binder服务的实现者都要继承这个类（的子类），在继承类中，最重要的就是实现onTransact方法，因为这个方法是所有请求的入口。因此，这个方法是和BpBinder中的transact方法对应的，这个方法同样也有一个uint32_t code参数，在这个方法的实现中，由服务提供者通过code对请求的接口进行区分，然后调用具体实现服务的方法。 IBinder中定义了uint32_t code允许的范围： 12FIRST_CALL_TRANSACTION = 0x00000001,LAST_CALL_TRANSACTION = 0x00ffffff, Binder服务要保证自己提供的每个服务接口有一个唯一的code，例如hello服务: 123#define HELLO_SVR_CMD_SAYHELLO 1#define HELLO_SVR_CMD_SAYHELLO_TO 2#define HELLO_SVR_CMD_GET_FD 3 讲完了IBinder，BpBinder和BBinder三个类，我们再来看看BpReBase，IInterface，BpInterface和BnInterface。 每个Binder服务都是为了某个功能而实现的，因此其本身会定义一套接口集（通常是C++的一个类）来描述自己提供的所有功能。而Binder服务既有自身实现服务的类，也要有给客户端进程调用的类。为了便于开发，这两中类里面的服务接口应当是一致的，例如：假设服务实现方提供了一个接口为sayhello(void)的服务方法，那么其远程接口中也应当有一个sayhello(void)方法。因此为了实现方便，本地实现类和远程接口类需要有一个公共的描述服务接口的基类（即上图中的IXXXService）来继承。而这个基类通常是IInterface的子类，IInterface的定义如下： 1234567891011class IInterface : public virtual RefBase&#123;public: IInterface(); static sp&lt;IBinder&gt; asBinder(const IInterface*); static sp&lt;IBinder&gt; asBinder(const sp&lt;IInterface&gt;&amp;);protected: virtual ~IInterface(); virtual IBinder* onAsBinder() = 0;&#125;; 之所以要继承自IInterface类是因为这个类中定义了onAsBinder让子类实现。onAsBinder在本地对象的实现类中返回的是本地对象，在远程对象的实现类中返回的是远程对象。onAsBinder方法被两个静态方法asBinder方法调用。有了这些接口之后，在代码中便可以直接通过IXXX::asBinder方法获取到不用区分本地还是远程的IBinder对象。这个在跨进程传递Binder对象的时候有很大的作用（因为不用区分具体细节，只要直接调用和传递就好）。 下面，我们来看一下BpInterface和BnInterface的定义： 12345678910111213141516171819202122template&lt;typename INTERFACE&gt;class BnInterface : public INTERFACE, public BBinder&#123;public: virtual sp&lt;IInterface&gt; queryLocalInterface(const String16&amp; _descriptor); virtual const String16&amp; getInterfaceDescriptor() const;protected: virtual IBinder* onAsBinder();&#125;;// ----------------------------------------------------------------------template&lt;typename INTERFACE&gt;class BpInterface : public INTERFACE, public BpRefBase&#123;public: BpInterface(const sp&lt;IBinder&gt;&amp; remote);protected: virtual IBinder* onAsBinder();&#125;; 这两个类都是模板类，它们在继承自INTERFACE的基础上各自继承了另外一个类。这里的INTERFACE便是我们Binder服务接口的基类。另外，BnInterface继承了BBinder类，由此可以通过复写onTransact方法来提供实现。BpInterface继承了BpRefBase，通过这个类的remote方法可以获取到指向服务实现方的句柄。在客户端接口的实现类中，每个接口在组装好参数之后，都会调用remote()-&gt;transact来发送请求，而这里其实就是调用的BpBinder的transact方法，这样请求便通过Binder到达了服务实现方的onTransact中。这个过程如下图所示： 基于Binder框架开发的服务，除了满足上文提到的类名规则之外，还需要遵守其他一些共同的规约： ☯为了进行服务的区分，每个Binder服务需要指定一个唯一的标识，这个标识通过getInterfaceDescriptor返回，类型是一个字符串。通常，Binder服务会在类中定义static const android::String16 descriptor;这样一个常量来描述这个标识符，然后在getInterfaceDescriptor方法中返回这个常量。☯为了便于调用者获取到调用接口，服务接口的公共基类需要提供一个android::sp asInterface方法来返回基类对象指针。由于上面提到的这两点对于所有Binder服务的实现逻辑都是类似的。为了简化开发者的重复工作，在libbinder中，定义了两个宏来简化这些重复工作，它们是： 12345678910111213141516171819202122232425262728293031#define DECLARE_META_INTERFACE(INTERFACE) \\ static const android::String16 descriptor; \\ static android::sp&lt;I##INTERFACE&gt; asInterface( \\ const android::sp&lt;android::IBinder&gt;&amp; obj); \\ virtual const android::String16&amp; getInterfaceDescriptor() const; \\ I##INTERFACE(); \\ virtual ~I##INTERFACE(); \\#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME) \\ const android::String16 I##INTERFACE::descriptor(NAME); \\ const android::String16&amp; \\ I##INTERFACE::getInterfaceDescriptor() const &#123; \\ return I##INTERFACE::descriptor; \\ &#125; \\ android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface( \\ const android::sp&lt;android::IBinder&gt;&amp; obj) \\ &#123; \\ android::sp&lt;I##INTERFACE&gt; intr; \\ if (obj != NULL) &#123; \\ intr = static_cast&lt;I##INTERFACE*&gt;( \\ obj-&gt;queryLocalInterface( \\ I##INTERFACE::descriptor).get()); \\ if (intr == NULL) &#123; \\ intr = new Bp##INTERFACE(obj); \\ &#125; \\ &#125; \\ return intr; \\ &#125; \\ I##INTERFACE::I##INTERFACE() &#123; &#125; \\ I##INTERFACE::~I##INTERFACE() &#123; &#125; \\ 有了这两个宏之后，开发者只要在接口基类（IXXX）头文件中，使用DECLARE_META_INTERFACE宏便完成了需要的组件的声明。然后在cpp文件中使用IMPLEMENT_META_INTERFACE便完成了这些组件的实现。 2.1、Binder的初始化ProcessState在讲解Binder驱动的时候我们就提到：任何使用Binder机制的进程都必须要对/dev/binder设备进行open以及mmap之后才能使用，这部分逻辑是所有使用Binder机制进程共同的。对于这种共同逻辑的封装便是Framework层的职责之一。libbinder中，ProcessState类封装了这个逻辑，相关代码见下文。 这里是ProcessState构造函数，在这个函数中，初始化mDriverFD的时候调用了open_driver方法打开binder设备，然后又在函数体中，通过mmap进行内存映射。 12345678910111213141516171819ProcessState::ProcessState() : mDriverFD(open_driver()) , mVMStart(MAP_FAILED) , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mStarvationStartTimeMs(0) , mManagesContexts(false) , mBinderContextCheckFunc(NULL) , mBinderContextUserData(NULL) , mThreadPoolStarted(false) , mThreadPoolSeq(1)&#123; if (mDriverFD &gt;= 0) &#123; mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); ... &#125;&#125; open_driver的函数实现如下所示。在这个函数中完成了三个工作： ☯首先通过open系统调用打开了dev/binder设备☯然后通过ioctl获取Binder实现的版本号，并检查是否匹配☯最后通过ioctl设置进程支持的最大线程数量关于这部分逻辑背后的处理，在讲解Binder驱动的时候，我们已经讲解过了。 1234567891011121314static int open_driver()&#123; int fd = open(\"/dev/binder\", O_RDWR | O_CLOEXEC); if (fd &gt;= 0) &#123; int vers = 0; status_t result = ioctl(fd, BINDER_VERSION, &amp;vers); ... size_t maxThreads = DEFAULT_MAX_BINDER_THREADS; result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); &#125; else &#123; ... &#125; return fd;&#125; ProcessState是一个Singleton（单例）类型的类，在一个进程中，只会存在一个实例。通过ProcessState::self()接口获取这个实例。一旦获取这个实例，便会执行其构造函数，由此完成了对于Binder设备的初始化工作。 2.2、关于Binder传递数据的大小限制由于Binder的数据需要跨进程传递，并且还需要在内核上开辟空间，因此允许在Binder上传递的数据并不是无无限大的。mmap中指定的大小便是对数据传递的大小限制： 12#define BINDER_VM_SIZE ((1*1024*1024) - (4096 *2)) // 1M - 8kmVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); 这里我们看到，在进行mmap的时候，指定了最大size为BINDER_VM_SIZE，即 1M - 8k的大小。 因此我们在开发过程中，一次Binder调用的数据总和不能超过这个大小。 对于这个区域的大小，我们也可以在设备上进行确认。这里我们还之前提到的system_server为例。上面我们讲解了通过procfs来获取映射的内存地址，除此之外，我们也可以通过showmap命令，来确定这块区域的大小，相关命令如下： 1234angler:/ # ps | grep system_server system 1889 526 2353404 135968 SyS_epoll_ 72972eeaf4 S system_serverangler:/ # showmap 1889 | grep \"/dev/binder\" 1016 4 4 0 0 4 0 0 1 /dev/binder 这里可以看到，这块区域的大小正是 1M - 8K = 1016k。 Tips: 通过showmap命令可以看到进程的详细内存占用情况。在实际的开发过程中，当我们要对某个进程做内存占用分析的时候，这个命令是相当有用的。建议读者尝试通过showmap命令查看system_server或其他感兴趣进程的完整map，看看这些进程都依赖了哪些库或者模块，以及内存占用情况是怎样的。 2.3、与驱动的通信IPCThreadState上文提到ProcessState是一个单例类，一个进程只有一个实例。而负责与Binder驱动通信的IPCThreadState也是一个单例类。但这个类不是一个进程只有一个实例，而是一个线程有一个实例。 IPCThreadState负责了与驱动通信的细节处理。这个类中的关键几个方法说明如下： 方法 说明 transact 公开接口。供Proxy发送数据到驱动，并读取返回结果 sendReply 供Server端写回请求的返回结果 waitForResponse 发送请求后等待响应结果 talkWithDriver 通过ioctl BINDER_WRITE_READ来与驱动通信 writeTransactionData 写入一次事务的数据 executeCommand 处理binder_driver_return_protocol协议命令 freeBuffer 通过BC_FREE_BUFFER命令释放Buffer BpBinder::transact方法在发送请求的时候，其实就是直接调用了IPCThreadState对应的方法来发送请求到Binder驱动的，相关代码如下： 123456789101112status_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; if (mAlive) &#123; status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags); if (status == DEAD_OBJECT) mAlive = 0; return status; &#125; return DEAD_OBJECT;&#125; 而IPCThreadState::transact方法主要逻辑如下： 123456789101112131415161718192021222324252627282930status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; status_t err = data.errorCheck(); flags |= TF_ACCEPT_FDS; if (err == NO_ERROR) &#123; err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); &#125; if (err != NO_ERROR) &#123; if (reply) reply-&gt;setError(err); return (mLastError = err); &#125; if ((flags &amp; TF_ONE_WAY) == 0) &#123; if (reply) &#123; err = waitForResponse(reply); &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; &#125; else &#123; err = waitForResponse(NULL, NULL); &#125; return err;&#125; 这段代码应该还是比较好理解的：首先通过writeTransactionData写入数据，然后通过waitForResponse等待返回结果。TF_ONE_WAY表示此次请求是单向的，即：不用真正等待结果即可返回。 而writeTransactionData方法其实就是在组装binder_transaction_data数据： 1234567891011121314151617181920212223242526272829303132333435status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; binder_transaction_data tr; tr.target.ptr = 0; /* Don't pass uninitialized stack data to a remote process */ tr.target.handle = handle; tr.code = code; tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; const status_t err = data.errorCheck(); if (err == NO_ERROR) &#123; tr.data_size = data.ipcDataSize(); tr.data.ptr.buffer = data.ipcData(); tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t); tr.data.ptr.offsets = data.ipcObjects(); &#125; else if (statusBuffer) &#123; tr.flags |= TF_STATUS_CODE; *statusBuffer = err; tr.data_size = sizeof(status_t); tr.data.ptr.buffer = reinterpret_cast&lt;uintptr_t&gt;(statusBuffer); tr.offsets_size = 0; tr.data.ptr.offsets = 0; &#125; else &#123; return (mLastError = err); &#125; mOut.writeInt32(cmd); mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR;&#125; 对于binder_transaction_data在讲解Binder驱动的时候我们已经详细讲解过了。而这里的Parcel我们还不了解，那么接下来我们马上就来看一下这个类。 数据包装器：ParcelBinder上提供的是跨进程的服务，每个服务包含了不同的接口，每个接口的参数数量和类型都不一样。那么当客户端想要调用服务端的接口，参数是如何跨进程传递给服务端的呢？除此之外，服务端想要给客户端返回结果，结果又是如何传递回来的呢？ 这些问题的答案就是：Parcel。Parcel就像一个包装器，调用者可以以任意顺序往里面放入需要的数据，所有写入的数据就像是被打成一个整体的包，然后可以直接在Binde上传输。 Parcel提供了所有基本类型的写入和读出接口，下面是其中的一部分： 123456789...status_t writeInt32(int32_t val);status_t writeUint32(uint32_t val);......status_t readUtf8FromUtf16(std::string* str) const;status_t readUtf8FromUtf16(std::unique_ptr&lt;std::string&gt;* str) const;const char* readCString() const;... 因此对于基本类型，开发者可以直接调用接口写入和读出。而对于非基本类型，需要由开发者将其拆分成基本类型然后写入到Parcel中（读出的时候也是一样）。 Parcel会将所有写入的数据进行打包，Parcel本身可以作为一个整体在进程间传递。接收方在收到Parcel之后，只要按写入同样的顺序读出即可。 这个过程，和我们现实生活中寄送包裹做法是一样的：我们将需要寄送的包裹放到硬纸盒中交给快递公司。快递公司将所有的包裹进行打包，然后集中放到运输车中送到目的地，到了目的地之后然后再进行拆分。 Parcel既包含C++部分的实现，也同时提供了Java的接口，中间通过JNI衔接。Java层的接口其实仅仅是一层包装，真正的实现都是位于C++部分中。特别需要说明一下的是，Parcel类除了可以传递基本数据类型，还可以传递Binder对象： 1234status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)&#123; return flatten_binder(ProcessState::self(), val, this);&#125; 这个方法写入的是sp类型的对象，而IBinder既可能是本地Binder，也可能是远程Binder，这样我们就不可以不用关心具体细节直接进行Binder对象的传递。 这也是为什么IInterface中定义了两个asBinder的static方法，如果你不记得了，请回忆一下这两个方法： 12static sp&lt;IBinder&gt; asBinder(const IInterface*);static sp&lt;IBinder&gt; asBinder(const sp&lt;IInterface&gt;&amp;); 而对于Binder驱动，我们前面已经讲解过：Binder驱动并不是真的将对象在进程间序列化传递，而是由Binder驱动完成了对于Binder对象指针的解释和翻译，使调用者看起来就像在进程间传递对象一样。 2.4、Framework层的线程管理在讲解Binder驱动的时候，我们就讲解过驱动中对应线程的管理。这里我们再来看看，Framework层是如何与驱动层对接进行线程管理的。 ProcessState::setThreadPoolMaxThreadCount 方法中，会通过BINDER_SET_MAX_THREADS命令设置进程支持的最大线程数量： 123456789101112#define DEFAULT_MAX_BINDER_THREADS 15status_t ProcessState::setThreadPoolMaxThreadCount(size_t maxThreads) &#123; status_t result = NO_ERROR; if (ioctl(mDriverFD, BINDER_SET_MAX_THREADS, &amp;maxThreads) != -1) &#123; mMaxThreads = maxThreads; &#125; else &#123; result = -errno; ALOGE(\"Binder ioctl to set max threads failed: %s\", strerror(-result)); &#125; return result;&#125; 由此驱动便知道了该Binder服务支持的最大线程数。驱动在运行过程中，会根据需要，并在没有超过上限的情况下，通过BR_SPAWN_LOOPER命令通知进程创建线程： IPCThreadState在收到BR_SPAWN_LOOPER请求之后，便会调用ProcessState::spawnPooledThread来创建线程： 12345678status_t IPCThreadState::executeCommand(int32_t cmd)&#123; ... case BR_SPAWN_LOOPER: mProcess-&gt;spawnPooledThread(false); break; ...&#125; ProcessState::spawnPooledThread方法负责为线程设定名称并创建线程： 123456789void ProcessState::spawnPooledThread(bool isMain)&#123; if (mThreadPoolStarted) &#123; String8 name = makeBinderThreadName(); ALOGV(\"Spawning new pooled thread, name=%s\\n\", name.string()); sp&lt;Thread&gt; t = new PoolThread(isMain); t-&gt;run(name.string()); &#125;&#125; 线程在run之后，会调用threadLoop将自身添加的线程池中： 12345virtual bool threadLoop()&#123; IPCThreadState::self()-&gt;joinThreadPool(mIsMain); return false;&#125; 而IPCThreadState::joinThreadPool方法中，会根据当前线程是否是主线程发送BC_ENTER_LOOPER或者BC_REGISTER_LOOPER命令告知驱动线程已经创建完毕。整个调用流程如下图所示： （3）、Android Binder系统-Native层添加hello服务3.1、Client构造数据，发送数据给驱动首先看一下Native ServiceManager架构图 只讲数据构造过程。。 构造：[-&gt; IServiceManager.cpp ::BpServiceManager] 1234567891011virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service, bool allowIsolated) &#123; Parcel data, reply; //Parcel是数据通信包 //写入头信息\"android.os.IServiceManager\" data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor()); data.writeString16(name); // name为 \"hello\" data.writeStrongBinder(service); // HelloService对象，把一个binder实体“打扁”并写入parcel data.writeInt32(allowIsolated ? 1 : 0); // allowIsolated= false //remote()指向的是BpBinder对象 status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply); return err == NO_ERROR ? reply.readExceptionCode() : err;&#125; 服务注册过程：向ServiceManager注册服务hello Service，服务名为”hello”；请大家注意上面data.writeStrongBinder()一句，它专门负责把一个binder实体“打扁”并写入parcel。其代码如下： 3.2.1、* writeStrongBinder()[-&gt; parcel.cpp] 1234status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)&#123; return flatten_binder(ProcessState::self(), val, this);&#125; 3.2.2、flatten_binder()[-&gt; parcel.cpp] 12345678910111213141516171819202122232425status_t flatten_binder(const sp&lt;ProcessState&gt;&amp; /*proc*/, const sp&lt;IBinder&gt;&amp; binder, Parcel* out)&#123; flat_binder_object obj; obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS; if (binder != NULL) &#123; IBinder *local = binder-&gt;localBinder(); //本地Binder不为空 if (!local) &#123; BpBinder *proxy = binder-&gt;remoteBinder(); const int32_t handle = proxy ? proxy-&gt;handle() : 0; obj.type = BINDER_TYPE_HANDLE; obj.binder = 0; obj.handle = handle; obj.cookie = 0; &#125; else &#123; //进入该分支 obj.type = BINDER_TYPE_BINDER; obj.binder = reinterpret_cast&lt;uintptr_t&gt;(local-&gt;getWeakRefs()); obj.cookie = reinterpret_cast&lt;uintptr_t&gt;(local); &#125; &#125; else &#123; ... &#125; return finish_flatten_binder(binder, obj, out);&#125; 将Binder对象扁平化，转换成flat_binder_object对象。看到了吗？“打扁”的意思就是把binder对象整理成flat_binder_object变量，如果打扁的是binder实体，那么flat_binder_object用cookie域记录binder实体的指针，即BBinder指针，而如果打扁的是binder代理，那么flat_binder_object用handle域记录的binder代理的句柄值。 总结：Parcel的数据区域分两个部分：mData和mObjects，所有的数据不管是基础数据类型还是对象实体，全都追加到mData里，mObjects是一个偏移量数组，记录所有存放在mData中的flat_binder_object实体的偏移量。 3.2.3、finish_flatten_binder()将flat_binder_object写入out。12345inline static status_t finish_flatten_binder( const sp&lt;IBinder&gt;&amp; , const flat_binder_object&amp; flat, Parcel* out)&#123; return out-&gt;writeObject(flat, false);&#125; 然后flatten_binder()调用了一个关键的finish_flatten_binder()函数。这个函数内部会记录下刚刚被扁平化的flat_binder_object在parcel中的位置。说得更详细点儿就是，parcel对象内部会有一个buffer，记录着parcel中所有扁平化的数据，有些扁平数据是普通数据，而另一些扁平数据则记录着binder对象。所以parcel中会构造另一个mObjects数组，专门记录那些binder扁平数据所在的位置，示意图如下： 一旦到了向驱动层传递数据的时候，IPCThreadState::writeTransactionData()会先把Parcel数据整理成一个binder_transaction_data数据 1234567891011121314151617181920212223242526272829303132333435status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; binder_transaction_data tr; tr.target.ptr = 0; /* Don't pass uninitialized stack data to a remote process */ tr.target.handle = handle; tr.code = code; tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; const status_t err = data.errorCheck(); if (err == NO_ERROR) &#123; tr.data_size = data.ipcDataSize(); tr.data.ptr.buffer = data.ipcData(); tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t); tr.data.ptr.offsets = data.ipcObjects(); &#125; else if (statusBuffer) &#123; tr.flags |= TF_STATUS_CODE; *statusBuffer = err; tr.data_size = sizeof(status_t); tr.data.ptr.buffer = reinterpret_cast&lt;uintptr_t&gt;(statusBuffer); tr.offsets_size = 0; tr.data.ptr.offsets = 0; &#125; else &#123; return (mLastError = err); &#125; mOut.writeInt32(cmd); mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR;&#125; 3.2.4 、waitForResponse()1234567891011121314151617181920212223status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; int32_t cmd; int32_t err; while (1) &#123; if ((err=talkWithDriver()) &lt; NO_ERROR) break;//目的就是把上面打包的mOut数据给kernel,接着看taklWithDriver(); cmd = mIn.readInt32(); &#125; switch (cmd) &#123; case BR_REPLY: ...... goto finish; default: err = executeCommand(cmd); break; &#125; &#125;finish: ..... return err;&#125; 该函数是与serviceManager通信的主要函数，首先会调用talkWithDriver()方法，将之前的打包在mOut中的数据打包成struct binder_write_read 对象，并通过ioctrl发送给kernel。 3.2.5、 IPCThreadState::talkWithDriver12345678910111213141516171819202122232425262728status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; binder_write_read bwr; const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; //doReceive参数，默认是为true,上面我们看到没有传参数，那么doReceive = 1； bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); //将mOut数据指针存放到这里,这就是我们上面打包的数据。 // This is what we'll read. if (doReceive &amp;&amp; needRead) &#123; bwr.read_size = mIn.dataCapacity(); //注意这里数据的大小，在我们new IPCThreadState对象时，已经初始化为256. bwr.read_buffer = (uintptr_t)mIn.data(); //mIn数据指针，放到这里 &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; //...... bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err; do &#123; if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) //这里通过ioctl将数据写给kernel ..... &#125; while (err == -EINTR); return err;&#125; 该函数的作用就是将之前打包的数据通过系统调用ioctl发送给kernel，最终发送给kernel的数据是struct binder_write_read对象。该对象已经被打包了3次，它们的包含关系如下所示。 3.2.6、Client获取服务、处理回复数据过程内核会唤醒Client进程处理回复消息。 12345678910111213141516171819202122232425262728status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; int32_t cmd; int32_t err; while (1) &#123; if ((err=talkWithDriver()) &lt; NO_ERROR) break; ... cmd = mIn.readInt32(); switch (cmd) &#123; case BR_REPLY: &#123; binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); if (reply) &#123; if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123; //当reply对象回收时，则会调用freeBuffer来回收内存 reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer, this); &#125; ... &#125; ... return err;&#125; 3.2.7、Parcel::ipcSetDataReference12345678910111213141516171819202122232425262728void Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize, const binder_size_t* objects, size_t objectsCount, release_func relFunc, void* relCookie)&#123; binder_size_t minOffset = 0; freeDataNoInit(); mError = NO_ERROR; mData = const_cast&lt;uint8_t*&gt;(data); //这是有4个字节的buffer。且存放的数据是0 mDataSize = mDataCapacity = dataSize; //之前申请的大小就是4个字节。 //ALOGI(\"setDataReference Setting data size of %p to %lu (pid=%d)\", this, mDataSize, getpid()); mDataPos = 0; ALOGV(\"setDataReference Setting data pos of %p to %zu\", this, mDataPos); mObjects = const_cast&lt;binder_size_t*&gt;(objects); //binder对象其实地址 mObjectsSize = mObjectsCapacity = objectsCount; //binder对象的个数。 mNextObjectHint = 0; mOwner = relFunc; //释放内存的函数，后面我们就不进行了。 mOwnerCookie = relCookie; for (size_t i = 0; i &lt; mObjectsSize; i++) &#123; binder_size_t offset = mObjects[i]; if (offset &lt; minOffset) &#123; ALOGE(\"%s: bad object offset %\"PRIu64\" &lt; %\"PRIu64\"\\n\", __func__, (uint64_t)offset, (uint64_t)minOffset); mObjectsSize = 0; break; &#125; minOffset = offset + sizeof(flat_binder_object); &#125; scanForFds();&#125; 上面做的工作只是将事务数据分别安放到当前Parcel对象的相应位置。其中scanForFds（）是为了查找返回来的数据中是否有binder对象，这个在获取代理对象时有用。 3.2.8、readStrongBinder()[-&gt; Parcel.java] readStrongBinder的过程基本是writeStrongBinder逆过程。 1234567static jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr) &#123; Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr); if (parcel != NULL) &#123; return javaObjectForIBinder(env, parcel-&gt;readStrongBinder()); &#125; return NULL;&#125; javaObjectForIBinder 将native层BpBinder对象转换为Java层BinderProxy对象。 3.2.9、readStrongBinder(C++)[-&gt; Parcel.cpp] 123456sp&lt;IBinder&gt; Parcel::readStrongBinder() const&#123; sp&lt;IBinder&gt; val; unflatten_binder(ProcessState::self(), *this, &amp;val); return val;&#125; 3.2.10、unflatten_binder()[-&gt; Parcel.cpp] 12345678910111213141516status_t unflatten_binder(const sp&lt;ProcessState&gt;&amp; proc, const Parcel&amp; in, sp&lt;IBinder&gt;* out) &#123; const flat_binder_object* flat = in.readObject(false); if (flat) &#123; switch (flat-&gt;type) &#123; case BINDER_TYPE_BINDER: *out = reinterpret_cast&lt;IBinder*&gt;(flat-&gt;cookie); return finish_unflatten_binder(NULL, *flat, in); case BINDER_TYPE_HANDLE: *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle); //创建BpBinder对象 return finish_unflatten_binder( static_cast&lt;BpBinder*&gt;(out-&gt;get()), *flat, in); &#125; &#125; return BAD_TYPE;&#125; 说明：readObject()的作用是从Parcel中读取出它所保存的flat_binder_object类型的对象。该对象的类型是BINDER_TYPE_HANDLE，因此会指向BINDER_TYPE_HANDLE对应的switch分支。(01) 这里的proc是ProcessState对象，执行proc-&gt;getStrongProxyForHandle()会将句柄(MediaPlayerService的Binder引用描述)保存到ProcessState的链表中，然后再创建并返回该句柄的BpBinder对象(即Binder的代理)。在Android Binder机制(四) defaultServiceManager()的实现中有getStrongProxyForHandle()的详细说明，下面只给出getStrongProxyForHandle()代码。(02) finish_unflatten_binder()中只有return NO_ERROR。 3.2.11、getStrongProxyForHandle()[-&gt; ProcessState.cpp] 123456789101112131415161718192021222324sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; AutoMutex _l(mLock); //查找handle对应的资源项 handle_entry* e = lookupHandleLocked(handle); if (e != NULL) &#123; IBinder* b = e-&gt;binder; if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123; ... //当handle值所对应的IBinder不存在或弱引用无效时，则创建BpBinder对象 b = new BpBinder(handle); e-&gt;binder = b; if (b) e-&gt;refs = b-&gt;getWeakRefs(); result = b; &#125; else &#123; result.force_set(b); e-&gt;refs-&gt;decWeak(this); &#125; &#125; return result;&#125; 经过该方法，最终创建了指向Binder服务端的BpBinder代理对象。 （4）、Android Binder系统-Native层获取hello服务经过前面的分析，知道流程基本类似，这里不再继续分析获取hello服务 五、Android Binder系统-Framwork-Java层（1）、Android Binder系统Java层主要结构Android应用程序使用Java语言开发，Binder框架自然也少不了在Java层提供接口。 前文中我们看到，Binder机制在C++层已经有了完整的实现。因此Java层完全不用重复实现，而是通过JNI衔接了C++层以复用其实现。 下图描述了Binder Framework Java层到C++层的衔接关系。 这里对图中Java层和JNI层的几个类做一下说明( 关于C++层的讲解请看这里 )： 这里的IInterface，IBinder和C++层的两个类是同名的。这个同名并不是巧合：它们不仅仅同名，它们所起的作用，以及其中包含的接口都是几乎一样的，区别仅仅在于一个是C++层，一个是Java层而已。 除了IInterface，IBinder之外，这里Binder与BinderProxy类也是与C++的类对应的，下面列出了Java层和C++层类的对应关系： 这里的IInterface，IBinder和C++层的两个类是同名的。这个同名并不是巧合：它们不仅仅同名，它们所起的作用，以及其中包含的接口都是几乎一样的，区别仅仅在于一个是C++层，一个是Java层而已。 除了IInterface，IBinder之外，这里Binder与BinderProxy类也是与C++的类对应的，下面列出了Java层和C++层类的对应关系： （2）、JNI的衔接JNI全称是Java Native Interface，这个是由Java虚拟机提供的机制。这个机制使得native代码可以和Java代码互相通讯。简单来说就是：我们可以在C/C++端调用Java代码，也可以在Java端调用C/C++代码。 关于JNI的详细说明，可以参见Oracle的官方文档：Java Native Interface ，这里不多说明。 实际上，在Android中很多的服务或者机制都是在C/C++层实现的，想要将这些实现复用到Java层，就必须通过JNI进行衔接。AOSP源码中，/frameworks/base/core/jni/ 目录下的源码就是专门用来对接Framework层的JNI实现的。 看一下Binder.java的实现就会发现，这里面有不少的方法都是用native关键字修饰的，并且没有方法实现体，这些方法其实都是在C++中android_util_Binder.cpp实现的：那么，那么，C++是如何调用Java的呢？最关键的，libbinder中的BBinder::onTransact是如何能够调用到Java中的Binder::onTransact的呢？ 这段逻辑就是android_util_Binder.cpp中JavaBBinder::onTransact中处理的了。JavaBBinder是BBinder子类，其类结构如下：libbinder中的BBinder::onTransact是如何能够调用到Java中的Binder::onTransact的呢？JavaBBinder::onTransact关键代码如下： 123456789101112virtual status_t onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0)&#123; JNIEnv* env = javavm_to_jnienv(mVM); IPCThreadState* thread_state = IPCThreadState::self(); const int32_t strict_policy_before = thread_state-&gt;getStrictModePolicy(); jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags); ...&#125; 请注意这段代码中的这一行： 12jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags); 这一行代码其实是在调用mObject上offset为mExecTransact的方法。这里的几个参数说明如下： mObject 指向了Java端的Binder对象gBinderOffsets.mExecTransact 指向了Binder类的execTransact方法data 调用execTransact方法的参数code, data, reply, flags都是传递给调用方法execTransact的参数而JNIEnv.CallBooleanMethod这个方法是由虚拟机实现的。即：虚拟机会提供native方法来调用一个Java Object上的方法（关于Android上的Java虚拟机，今后我们会专门讲解）。 这样，就在C++层的JavaBBinder::onTransact中调用了Java层Binder::execTransact方法。而在Binder::execTransact方法中，又调用了自身的onTransact方法，由此保证整个过程串联了起来： 123456789101112131415161718192021222324252627282930313233343536private boolean execTransact(int code, long dataObj, long replyObj, int flags) &#123; Parcel data = Parcel.obtain(dataObj); Parcel reply = Parcel.obtain(replyObj); boolean res; try &#123; res = onTransact(code, data, reply, flags); &#125; catch (RemoteException|RuntimeException e) &#123; if (LOG_RUNTIME_EXCEPTION) &#123; Log.w(TAG, \"Caught a RuntimeException from the binder stub implementation.\", e); &#125; if ((flags &amp; FLAG_ONEWAY) != 0) &#123; if (e instanceof RemoteException) &#123; Log.w(TAG, \"Binder call failed.\", e); &#125; else &#123; Log.w(TAG, \"Caught a RuntimeException from the binder stub implementation.\", e); &#125; &#125; else &#123; reply.setDataPosition(0); reply.writeException(e); &#125; res = true; &#125; catch (OutOfMemoryError e) &#123; RuntimeException re = new RuntimeException(\"Out of memory\", e); reply.setDataPosition(0); reply.writeException(re); res = true; &#125; checkParcel(this, code, reply, \"Unreasonably large binder reply buffer\"); reply.recycle(); data.recycle(); StrictMode.clearGatheredViolations(); return res;&#125; （3）、Java层的ServiceManager有Java端的Binder服务，自然也少不了Java端的ServiceManager。我们先看一下Java端的ServiceManager的结构： 通过这个类图我们看到，Java层的ServiceManager和C++层的接口是一样的。 通过这个类图我们看到，Java层的ServiceManager和C++层的接口是一样的。 然后我们再选取addService方法看一下实现： 1234567891011121314151617public static void addService(String name, IBinder service, boolean allowIsolated) &#123; try &#123; getIServiceManager().addService(name, service, allowIsolated); &#125; catch (RemoteException e) &#123; Log.e(TAG, \"error in addService\", e); &#125;&#125; private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject()); return sServiceManager;&#125; 很显然，这段代码中，最关键就是下面这个调用： 1ServiceManagerNative.asInterface(BinderInternal.getContextObject()); 然后我们需要再看一下BinderInternal.getContextObject()和ServiceManagerNative.asInterface两个方法。 BinderInternal.getContextObject()是一个JNI方法，其实现代码在android_util_Binder.cpp中： 12345static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)&#123; sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL); return javaObjectForIBinder(env, b);&#125; 而ServiceManagerNative.asInterface的实现和其他的Binder服务是一样的套路： 12345678910111213static public IServiceManager asInterface(IBinder obj)&#123; if (obj == null) &#123; return null; &#125; IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ServiceManagerProxy(obj);&#125; 先通过queryLocalInterface查看能不能获得本地Binder，如果无法获取，则创建并返回ServiceManagerProxy对象。 而ServiceManagerProxy自然也是和其他Binder Proxy一样的实现套路： 123456789101112public void addService(String name, IBinder service, boolean allowIsolated) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeString(name); data.writeStrongBinder(service); data.writeInt(allowIsolated ? 1 : 0); mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0); reply.recycle(); data.recycle();&#125; 接下来的调用流程前面已经分析过了，在此就不再分析了。 六、Android Binder系统-AIDL作为Binder机制的最后一个部分内容，我们来讲解一下开发者经常使用的AIDL机制是怎么回事。 AIDL全称是Android Interface Definition Language，它是Android SDK提供的一种机制。借助这个机制，应用可以提供跨进程的服务供其他应用使用。AIDL的详细说明可以参见官方开发文档：https://developer.android.com/guide/components/aidl.html 。 这里，我们就以官方文档上的例子看来一下AIDL与Binder框架的关系。 开发一个基于AIDL的Service需要三个步骤： 定义一个.aidl文件实现接口暴露接口给客户端使用aidl文件使用Java语言的语法来定义，每个.aidl文件只能包含一个interface，并且要包含interface的所有方法声明。 默认情况下，AIDL支持的数据类型包括： 基本数据类型（即int，long，char，boolean等）StringCharSequenceList（List的元素类型必须是AIDL支持的）Map（Map中的元素必须是AIDL支持的）对于AIDL中的接口，可以包含0个或多个参数，可以返回void或一个值。所有非基本类型的参数必须包含一个描述是数据流向的标签，可能的取值是：in，out或者inout。 下面是一个aidl文件的示例： 12345678910111213141516// IRemoteService.aidlpackage com.example.android;// Declare any non-default types here with import statements/** Example service interface */interface IRemoteService &#123; /** Request the process ID of this service, to do evil things with it. */ int getPid(); /** Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 这个文件中包含了两个接口 ： getPid 一个无参的接口，返回值类型为intbasicTypes，包含了几个基本类型作为参数的接口，无返回值对于包含.aidl文件的工程，Android IDE（以前是Eclipse，现在是Android Studio）在编译项目的时候，会为aidl文件生成对应的Java文件。 针对上面这个aidl文件生成的java文件中包含的结构如下图所示： 在这个生成的Java文件中，包括了： 一个名称为IRemoteService的interface，该interface继承自android.os.IInterface并且包含了我们在aidl文件中声明的接口方法IRemoteService中包含了一个名称为Stub的静态内部类，这个类是一个抽象类，它继承自android.os.Binder并且实现了IRemoteService接口。这个类中包含了一个onTransact方法Stub内部又包含了一个名称为Proxy的静态内部类，Proxy类同样实现了IRemoteService接口仔细看一下Stub类和Proxy两个中包含的方法，是不是觉得很熟悉？是的，这里和前面介绍的服务实现是一样的模式。这里我们列一下各层类的对应关系： C++层 Java层 AIDL BpXXX XXXProxy IXXX.Stub.Proxy BnXXX XXXNative IXXX.Stub 为了整个结构的完整性，最后我们还是来看一下生成的Stub和Proxy类中的实现逻辑。 Stub是提供给开发者实现业务的父类，而Proxy的实现了对外提供的接口。Stub和Proxy两个类都有一个asBinder的方法。 Stub类中的asBinder实现就是返回自身对象： 1234Overridepublic android.os.IBinder asBinder() &#123; return this;&#125; 而Proxy中asBinder的实现是返回构造函数中获取的mRemote对象，相关代码如下： 12345678910private android.os.IBinder mRemote;Proxy(android.os.IBinder remote) &#123; mRemote = remote;&#125;Overridepublic android.os.IBinder asBinder() &#123; return mRemote;&#125; 而这里的mRemote对象其实就是远程服务在当前进程的标识。 上文我们说了，Stub类是用来提供给开发者实现业务逻辑的父类，开发者者继承自Stub然后完成自己的业务逻辑实现，例如这样： 123456789private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getPid()&#123; return Process.myPid(); &#125; public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) &#123; // Does something &#125;&#125;; 而这个Proxy类，就是用来给调用者使用的对外接口。我们可以看一下Proxy中的接口到底是如何实现的： Proxy中getPid方法实现如下所示： 12345678910111213141516Overridepublic int getPid() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getPid, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result;&#125; 这里就是通过Parcel对象以及transact调用对应远程服务的接口。而在Stub类中，生成的onTransact方法对应的处理了这里的请求： 123456789101112131415161718192021222324252627282930313233343536Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getPid: &#123; data.enforceInterface(DESCRIPTOR); int _result = this.getPid(); reply.writeNoException(); reply.writeInt(_result); return true; &#125; case TRANSACTION_basicTypes: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); long _arg1; _arg1 = data.readLong(); boolean _arg2; _arg2 = (0 != data.readInt()); float _arg3; _arg3 = data.readFloat(); double _arg4; _arg4 = data.readDouble(); java.lang.String _arg5; _arg5 = data.readString(); this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags);&#125; onTransact()所要做的就是： 根据code区分请求的是哪个接口通过data来获取请求的参数调用由子类实现的抽象方法有了前文的讲解，对于这部分内容应当不难理解了。 到这里，我们终于讲解完Binder了。 完整框架： 七、参考文档(特别感谢各位前辈的分析和图示)：Binder源码分析深入分析Android Binder Binder系列 - Gityuan博客 | 袁辉辉博客 理解Android Binder机制 - Qiangbo.space博客Android Binder机制(1) ~ (12) - Wangkuiwu.github.ioBinder机制-关于Binder的文章 - 泡在网上的日子红茶一杯话Binder - 悠然红茶Binder框架解析Android Binder详解图文详解 Android Binder跨进程通信机制 原理理解Android Binder机制(1/3)：驱动篇-qiangbo.space理解Android Binder机制(2/3)：C++层-qiangbo.space理解Android Binder机制(3/3)：Java层-qiangbo.spaceAndroid Binder 分析–系列-light3moon Android学习笔记-Binder | Palance’s Blogandroid系统 -Binder - armwind的专栏 - CSDN博客Bettarwang的专栏 -Android Binder机制深入剖析Android系统 - binder - CSDN博客","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Android 输入子系统 - Input System 分析","slug":"Android-7-1-2-Android-N-Android-输入子系统-Input-System","date":"2017-11-30T16:00:00.000Z","updated":"2018-03-23T07:16:44.000Z","comments":true,"path":"2017/12/01/Android-7-1-2-Android-N-Android-输入子系统-Input-System/","link":"","permalink":"http://zhoujinjian.cc/2017/12/01/Android-7-1-2-Android-N-Android-输入子系统-Input-System/","excerpt":"Android 输入子系统概述:● 当时输入设备（如触摸屏，键盘等）可用时，Linux Kernel会在/dev/input/下创建名为event0~eventN的设备节点; 当输入设备不可用时，会将相应的设备节点删除。● 当用户操作输入设备时，Linux Kernel会收到相应的硬件中断，然后会将中断加工成原始输入事件（raw input event），并写入到设备节点中。而后在用户空间就可以通过read()函数读取事件数据了。● Android输入系统会监控/dev/input/下的所有设备节点，当某个结点有数据可读时，将数据读出并进行一系列处理，然后在当前系统中的所有窗口（Window）中寻找合适的接收者，并把事件派发给它。● 具体来说，Linux Kernel将raw input event写入到设备节点后，InputReader会通过EventHub将原始事件读取出来并翻译加工为Android输入事件，而后把它交给InputDispatcher。InputDispatcher根据WMS（WindowManagerService）提供的窗口信息将事件传递给合适的窗口，若窗口为壁纸/SurfaceView等，则到了终点；否则会由该Window的ViewRoot继续分发到合适的View。","text":"Android 输入子系统概述:● 当时输入设备（如触摸屏，键盘等）可用时，Linux Kernel会在/dev/input/下创建名为event0~eventN的设备节点; 当输入设备不可用时，会将相应的设备节点删除。● 当用户操作输入设备时，Linux Kernel会收到相应的硬件中断，然后会将中断加工成原始输入事件（raw input event），并写入到设备节点中。而后在用户空间就可以通过read()函数读取事件数据了。● Android输入系统会监控/dev/input/下的所有设备节点，当某个结点有数据可读时，将数据读出并进行一系列处理，然后在当前系统中的所有窗口（Window）中寻找合适的接收者，并把事件派发给它。● 具体来说，Linux Kernel将raw input event写入到设备节点后，InputReader会通过EventHub将原始事件读取出来并翻译加工为Android输入事件，而后把它交给InputDispatcher。InputDispatcher根据WMS（WindowManagerService）提供的窗口信息将事件传递给合适的窗口，若窗口为壁纸/SurfaceView等，则到了终点；否则会由该Window的ViewRoot继续分发到合适的View。 本章涉及的源代码文件名及位置： frameworks/base/services/java/com/android/server/● SystemServer.java frameworks/base/services/java/com/android/server/input/● InputManagerService.java frameworks/base/services/java/com/android/server/wm/● WindowManagerService.java● WindowState.java● InputMonitor.java frameworks/base/core/java/android/view/● View.java● ViewGroup.java● InputEventReceiver.java● ViewRootImpl.java● IWindowSession.aidl● InputChannel.java frameworks/base/core/java/android/app/● Activity.java frameworks/base/services/jni/● android_view_InputChannel.cpp● android_view_InputEventReceiver.cpp● com_android_server_input_InputManagerService.cpp frameworks/native/services/inputflinger/● InputManager.cpp● EventHub.h● EventHub.cpp● InputReader.h● InputReader.cpp● InputListener.h● InputListener.cpp● InputDispatcher.h● InputDispatcher.cpp frameworks/native/libs/input/● InputTransport.cpp /frameworks/native/include/input/● InputTransport.h 博客原图链接一、Input系统必备Linux知识注：必备知识可稍后遇到实际使用的地方再做详细了解。 （一）、必备的Linux知识 inotify和epoll1、INotify介绍与使用INotify是一个Linux内核所提供的一种文件系统变化通知机制。它可以为应用程序监控文件系统的变化，如文件的新建、删除、读写等。INotify机制有两个基本对象，分别为inotify对象与watch对象，都使用文件描述符表示。inotify对象对应了一个队列，应用程序可以向inotify对象添加多个监听。当被监听的事件发生时，可以通过read()函数从inotify对象中将事件信息读取出来。Inotify对象可以通过以下方式创建：1int inotifyFd = inotify_init(); 而watch对象则用来描述文件系统的变化事件的监听。它是一个二元组，包括监听目标和事件掩码两个元素。监听目标是文件系统的一个路径，可以是文件也可以是文件夹。而事件掩码则表示了需要需要监听的事件类型，掩码中的每一位代表一种事件。可以监听的事件种类很多，其中就包括文件的创建(IN_CREATE)与删除(IN_DELETE)。读者可以参阅相关资料以了解其他可监听的事件种类。以下代码即可将一个用于监听输入设备节点的创建与删除的watch对象添加到inotify对象中：1int wd = inotify_add_watch (inotifyFd, “/dev/input”,IN_CREATE | IN_DELETE); 完成上述watch对象的添加后，当/dev/input/下的设备节点发生创建与删除操作时，都会将相应的事件信息写入到inotifyFd所描述的inotify对象中，此时可以通过read()函数从inotifyFd描述符中将事件信息读取出来。事件信息使用结构体inotify_event进行描述： 1234567struct inotify_event &#123; __s32 wd; /* 事件对应的Watch对象的描述符 */ __u32 mask; /* 事件类型，例如文件被删除，此处值为IN_DELETE */ __u32 cookie; __u32 len; /* name字段的长度 */ char name[0]; /* 可变长的字段，用于存储产生此事件的文件路径*/ &#125;; 当没有监听事件发生时，可以通过如下方式将一个或多个未读取的事件信息读取出来：1size_t len = read (inotifyFd, events_buf,BUF_LEN); 其中events_buf是inotify_event的数组指针，能够读取的事件数量由取决于数组的长度。成功读取事件信息后，便可根据inotify_event结构体的字段判断事件类型以及产生事件的文件路径了。 总结一下INotify机制的使用过程： · 通过inotify_init()创建一个inotify对象。 · 通过inotify_add_watch将一个或多个监听添加到inotify对象中。 · 通过read()函数从inotify对象中读取监听事件。当没有新事件发生时，inotify对象中无任何可读数据。 通过INotify机制避免了轮询文件系统的麻烦，但是还有一个问题，INotify机制并不是通过回调的方式通知事件，而需要使用者主动从inotify对象中进行事件读取。那么何时才是读取的最佳时机呢？这就需要借助Linux的另一个优秀的机制Epoll了。 使用inotify监听目录实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/inotify.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;//参考: frameworks\\native\\services\\inputflinger\\EventHub.cpp//Usage: inotify &lt;dir&gt;int read_process_inotify_fd(int fd)&#123;int res;char event_buf[512];int event_size;int event_pos = 0;struct inotify_event *event;/* read */ res = read(fd, event_buf, sizeof(event_buf));if(res &lt; (int)sizeof(*event)) &#123; if(errno == EINTR) return 0; printf(\"could not get event, %s\\n\", strerror(errno)); return -1;&#125;//读到的数据是1个或多个inotify_event,它们的长度不一样,逐个处理while(res &gt;= (int)sizeof(*event)) &#123; event = (struct inotify_event *)(event_buf + event_pos); //printf(\"%d: %08x \\\"%s\\\"\\n\", event-&gt;wd, event-&gt;mask, event-&gt;len ? event-&gt;name : \"\"); if(event-&gt;len) &#123; if(event-&gt;mask &amp; IN_CREATE) &#123; printf(\"create file: %s\\n\", event-&gt;name); &#125; else &#123; printf(\"delete file: %s\\n\", event-&gt;name); &#125; &#125; event_size = sizeof(*event) + event-&gt;len; res -= event_size; event_pos += event_size;&#125;return 0;&#125;int main(int argc, char **argv)&#123;int mINotifyFd;int result;if (argc != 2)&#123; printf(\"Usage: %s &lt;dir&gt;\\n\", argv[0]); return -1;&#125;/* inotify_init */mINotifyFd = inotify_init();/* add watch */result = inotify_add_watch(mINotifyFd, argv[1], IN_DELETE | IN_CREATE);/* read */while (1)&#123; read_process_inotify_fd(mINotifyFd);&#125;return 0;&#125; 编译与验证：gcc -o inotify inotify.c //GCC编译mkdir tmp //创建tmp文件夹./inotify tmp &amp; //后台监测tmp文件夹 echo &gt; tmp/1 //tmp文件夹新建文件1echo &gt; tmp/2 //tmp文件夹新建文件2rm tmp/1 tmp/2 //移除tmp文件1/2 测试结果可以看到，inotify 成功的监测了tmp文件夹。 2、Epoll介绍与使用无论是从设备节点中获取原始输入事件还是从inotify对象中读取文件系统事件，都面临一个问题，就是这些事件都是偶发的。也就是说，大部分情况下设备节点、inotify对象这些文件描述符中都是无数据可读的，同时又希望有事件到来时可以尽快地对事件作出反应。为解决这个问题，我们不希望不断地轮询这些描述符，也不希望为每个描述符创建一个单独的线程进行阻塞时的读取，因为这都将会导致资源的极大浪费。 此时最佳的办法是使用Epoll机制。Epoll可以使用一次等待监听多个描述符的可读/可写状态。等待返回时携带了可读的描述符或自定义的数据，使用者可以据此读取所需的数据后可以再次进入等待。因此不需要为每个描述符创建独立的线程进行阻塞读取，避免了资源浪费的同时又可以获得较快的响应速度。 Epoll机制的接口只有三个函数，十分简单。 · epoll_create(int max_fds)：创建一个epoll对象的描述符，之后对epoll的操作均使用这个描述符完成。max_fds参数表示了此epoll对象可以监听的描述符的最大数量。 · epoll_ctl (int epfd, int op,int fd, struct epoll_event *event)：用于管理注册事件的函数。这个函数可以增加/删除/修改事件的注册。 · int epoll_wait(int epfd, structepoll_event * events, int maxevents, int timeout)：用于等待事件的到来。当此函数返回时，events数组参数中将会包含产生事件的文件描述符。 接下来以监控若干描述符可读事件为例介绍一下epoll的用法。 （1） 创建epoll对象 首先通过epoll_create()函数创建一个epoll对象： Int epfd = epoll_create(MAX_FDS) （2） 填充epoll_event结构体 接着为每一个需监控的描述符填充epoll_event结构体，以描述监控事件，并通过epoll_ctl()函数将此描述符与epoll_event结构体注册进epoll对象。epoll_event结构体的定义如下: 12345struct epoll_event &#123;__uint32_tevents; /* 事件掩码，指明了需要监听的事件种类*/ epoll_data_t data; /* 使用者自定义的数据，当此事件发生时该数据将原封不动地返回给使用者 */ &#125;; epoll_data_t联合体的定义如下，当然，同一时间使用者只能使用一个字段： 123456typedef union epoll_data &#123;void*ptr;int fd;__uint32_t u32;__uint64_t u64;&#125; epoll_data_t; epoll_event结构中的events字段是一个事件掩码，用以指明需要监听的事件种类，同INotify一样，掩码的每一位代表了一种事件。常用的事件有EPOLLIN（可读），EPOLLOUT（可写），EPOLLERR（描述符发生错误），EPOLLHUP（描述符被挂起）等。更多支持的事件读者可参考相关资料。 data字段是一个联合体，它让使用者可以将一些自定义数据加入到事件通知中，当此事件发生时，用户设置的data字段将会返回给使用者。在实际使用中常设置epoll_event.data.fd为需要监听的文件描述符，事件发生时便可以根据epoll_event.data.fd得知引发事件的描述符。当然也可以设置epoll_event.data.fd为其他便于识别的数据。 填充epoll_event的方法如下： 1234567structepoll_event eventItem;memset(&amp;eventItem, 0, sizeof(eventItem));eventItem.events = EPOLLIN | EPOLLERR | EPOLLHUP; // 监听描述符可读以及出错的事件eventItem.data.fd= listeningFd; // 填写自定义数据为需要监听的描述符 接下来就可以使用epoll_ctl()将事件注册进epoll对象了。epoll_ctl()的参数有四个： · epfd是由epoll_create()函数所创建的epoll对象的描述符。 · op表示了何种操作，包括EPOLL_CTL_ADD/DEL/MOD三种，分别表示增加/删除/修改注册事件。 · fd表示了需要监听的描述符。 · event参数是描述了监听事件的详细信息的epoll_event结构体。 注册方法如下： 123// 将事件监听添加到epoll对象中去result =epoll_ctl(epfd, EPOLL_CTL_ADD, listeningFd, &amp;eventItem); 重复这个步骤可以将多个文件描述符的多种事件监听注册到epoll对象中。完成了监听的注册之后，便可以通过epoll_wait()函数等待事件的到来了。 （3） 使用epoll_wait()函数等待事件 epoll_wait()函数将会使调用者陷入等待状态，直到其注册的事件之一发生之后才会返回，并且携带了刚刚发生的事件的详细信息。其签名如下： int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); · epfd是由epoll_create()函数所创建的epoll对象描述符。 · events是一个epoll_event的数组，此函数返回时，事件的信息将被填充至此。 · maxevents表示此次调用最多可以获取多少个事件，当然，events参数必须能够足够容纳这么多事件。 · timeout表示等待超时的事件。 epoll_wait()函数返回值表示获取了多少个事件。 （4） 处理事件 epoll_wait返回后，便可以根据events数组中所保存的所有epoll_event结构体的events字段与data字段识别事件的类型与来源。 Epoll的使用步骤总结如下： · 通过epoll_create()创建一个epoll对象。 · 为需要监听的描述符填充epoll_events结构体，并使用epoll_ctl()注册到epoll对象中。 · 使用epoll_wait()等待事件的发生。 · 根据epoll_wait()返回的epoll_events结构体数组判断事件的类型与来源并进行处理。 · 继续使用epoll_wait()等待新事件的发生。 使用inotify监听目录实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;sys/epoll.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#if 0typedef union epoll_data &#123;void *ptr; int fd; uint32_t u32; uint64_t u64; &#125; epoll_data_t;#endif#define DATA_MAX_LEN 500/* usage: epoll &lt;file1&gt; [file2] [file3] ... */int add_to_epoll(int fd, int epollFd)&#123;int result;struct epoll_event eventItem;memset(&amp;eventItem, 0, sizeof(eventItem));eventItem.events = EPOLLIN;eventItem.data.fd = fd;result = epoll_ctl(epollFd, EPOLL_CTL_ADD, fd, &amp;eventItem);return result;&#125;void rm_from_epoll(int fd, int epollFd)&#123;epoll_ctl(epollFd, EPOLL_CTL_DEL, fd, NULL);&#125;int main(int argc, char **argv)&#123;int mEpollFd;int i;char buf[DATA_MAX_LEN];// Maximum number of signalled FDs to handle at a time.static const int EPOLL_MAX_EVENTS = 16;// The array of pending epoll events and the index of the next event to be handled.struct epoll_event mPendingEventItems[EPOLL_MAX_EVENTS];if (argc &lt; 2)&#123; printf(\"Usage: %s &lt;file1&gt; [file2] [file3] ...\\n\", argv[0]); return -1;&#125;/* epoll_create */mEpollFd = epoll_create(8);// for each file:* open it// add it to epoll: epoll_ctl(...EPOLL_CTL_ADD...)for (i = 1; i &lt; argc; i++) &#123; //int tmpFd = open(argv[i], O_RDONLY|O_NONBLOCK); int tmpFd = open(argv[i], O_RDWR); add_to_epoll(tmpFd, mEpollFd);&#125;/* epoll_wait */while (1)&#123; int pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, -1); for (i = 0; i &lt; pollResult; i++) &#123; printf(\"Reason: 0x%x\\n\", mPendingEventItems[i].events); int len = read(mPendingEventItems[i].data.fd, buf, DATA_MAX_LEN); buf[len] = '\\0'; printf(\"get data: %s\\n\", buf); //sleep(3); &#125;&#125;return 0;&#125; epoll , fifo :o-rdwr-on-named-pipes-with-poll 使用fifo是, 我们的epoll程序是readerecho aa &gt; tmp/1 是writera.如果reader以 O_RDONLY|O_NONBLOCK打开FIFO文件,当writer写入数据时, epoll_wait会立刻返回;当writer关闭FIFO之后, reader再次调用epoll_wait, 它也会立刻返回(原因是EPPLLHUP, 描述符被挂断)b.如果reader以 O_RDWR打开FIFO文件当writer写入数据时, epoll_wait会立刻返回;当writer关闭FIFO之后, reader再次调用epoll_wait, 它并不会立刻返回, 而是继续等待有数据 编译与验证：gcc -o epoll epoll.c //GCC编译mkdir tmp //创建tmp文件夹mkfifo tmp/1 tmp/2 tmp/3 //创建文件1、2、3./epoll tmp/1 tmp/2 tmp/3 &amp; //epoll后台监测文件1、2、3echo aaa &gt; tmp/1 //写人aaa到1echo bbb &gt; tmp/2 //写入bbb到2 测试结果可以看到，epoll成功的监测了文件内容的改变。 3、INotify与Epoll的小结INotify与Epoll这两套由Linux提供的事件监听机制以最小的开销解决了文件系统变化以及文件描述符可读可写状态变化的监听问题。它们是Reader子系统运行的基石，了解了这两个机制的使用方法之后便为对Reader子系统的分析学习铺平了道路。参考：https://github.com/weidongshan/APP_0006_inotify_epollinotify_epoll.c, 用它来监测tmp/目录: 有文件被创建/删除, 有文件可读出数据a. 当在tmp/下创建文件时, 会立刻监测到，并且使用epoll监测该文件b. 当文件有数据时，读出数据c. 当tmp/下文件被删除时，会立刻监测到，并且把它从epoll中移除不再监测 inotify_epoll.c编译与验证： gcc -o inotify_epoll inotify_epoll.cmkdir tmp./inotify_epoll tmp/ &amp;mkfifo tmp/1 tmp/2 tmp/3echo aaa &gt; tmp/1echo bbb &gt; tmp/2rm tmp/3 由实例可知，使用inotify 和 epoll 结合就可以监测文件增加和移除 ，还能监测文件内容的改变。 用途简介[稍后进行input system详细分析]：/dev/input 下有多个event文件,对应多个输入设备，如:/dev/input/event0, /dev/input/mouse0, /dev/input/misc使用inotify 和 epoll 就可以监听输入设备的变化、如Android新连接一个鼠标可检测到改变。同时可监听是否有输入事件。 Lnux IO模式及 select、poll、epoll详解 （二）、必备Linux知识_双向通信(scoketpair)1、进程和APP通信· 创建进程· 读取、分发 · 进程发送输入事件给APP · 进程读取APP回应的事件· 输入系统涉及双向的进程间通信 2、回顾Binder系统· Server– 单向发出请求· Client – 单向回复请求· 每次请求只可以单方发出 3、引入Socketpair原因：如果创建两组进程（Client，Server）进行双向通信，实现十分复杂引入Socketpair：Socketpair();两次，获得两个fd，在内核获得缓冲区，一个作为sendbuf区一个作为receivebuf区APP通过fd1将数据写入fd1的sendbuf区中，通过内核当中的socket机制就会写到fd2中receivebuf区，同理fd2也是如此socketpair缺点：只适用于线程间、父子进程通信解决方法：通过Binder机制通信可以访问任意进程，就解决了sockpair缺点 4、socketpair具体使用创建一个线程–pthread_create();创建socketpair–socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets);线程处理函数–往socket[1]写入数据，读取socket[0]读取数据主函数–从socket[1]读取数据，往socket[0]写入数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;#define SOCKET_BUFFER_SIZE (32768U)#define MAX 512/* 参考:frameworks/native/libs/input/InputTransport.cpp */ /* 线程执行函数 */ int *function_thread(void *arg)&#123;int thread1_fd = (int)arg;int cnt=0;int len;char buf[MAX];while(1)&#123; /* 向 main线程发出: Hello, main thread */ len = sprintf(buf,\"Hello , main thread , cnt = %d\",cnt++); write(thread1_fd,buf,len); /* 读取数据(main线程发回的数据) */ len = read(thread1_fd,buf,MAX); buf[len] = '\\0'; printf(\"thread1 read : %s\\n\",buf); sleep(5);&#125;close(thread1_fd);return NULL;&#125;int main(int argc,char *argv[])&#123;pthread_t threadID;int sockets[2];int bufferSize = SOCKET_BUFFER_SIZE;socketpair(AF_UNIX,SOCK_SEQPACKET,0,sockets); //创建socketpair//初始化setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize));setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize));setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize));setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize));pthread_create(threadID,NULL,function_thread,(void *)sockets[1]); //创建线程int mainThread_fd = sockets[0];int cnt=0;int len;char buf[MAX];while(1)&#123; /* 读数据: 线程1发出的数据 */ len = read(mainThread_fd,buf,MAX); buf[len] = '\\0'; printf(\"main thread read : %s\\n\",buf); /* main thread向thread1 发出: Hello, thread1 */ len = sprintf(buf,\"Hello , thread1 , cnt = %d\",cnt++); write(mainThread_fd,buf,len); &#125;close(mainThread_fd);return 0;&#125; 使用方法：gcc socketpair.c -o socketpair -pthread 注：出现少量警告，可以忽略./socketpair可以看到main线程 和 thread1双向通信。 main 和 thread1属于两个线程： 父子进程通信：利用socketpair创建一对无名管道，然后通过sendmsg由服务器进程发送文件的fd给客户端进程，客户端进程通过recvmsg接收服务器进程发来的fdsocketpair实现父子进程通信图示： （三）、必备Linux知识_实现任意进程间双向通信(scoketpair+binder)代码实例，由于代码较多，请往GitHub上查看。实现任意进程间双向通信(scoketpair+binder) 由第二节最后可知socketpair可实现父子进程通信，图中父进程和子进程可双向通信，假如此时通过binder通信将文件句柄Fd[1]传给另外一个独立进程，我们知道Linux一切皆文件，那个独立进程就可以对Fd[1]读写了，也就是说父进程 就可以和 那个独立进程双向通信了，具体实现请研究上面的代码。 测试： 可以看到两个没有任何关系的进程使用socketpair实现了双向通信。 用途简介[稍后进行input system详细分析]：InputManagerService获取事件后需要发送给App，假如App进程关掉了，需要告知IMS，就不需要接受事件了。可以看到需要进程间相互通信，这就是scoketpair+binder实际作用。 二、输入系统的总体架构（一）、输入子系统分层解析输入子系统的系统架构如下图所示： Android输入系统系统综述：Linux内核会在/dev/input/下创建对应的名为event0~n或其他名称的设备节点。而当输入设备不可用时，则会将对应的节点删除。在用户空间可以通过ioctl的方式从这些设备节点中获取其对应的输入设备的类型、厂商、描述等信息。 当用户操作输入设备时，Linux内核接收到相应的硬件中断，然后将中断加工成原始的输入事件数据并写入其对应的设备节点中，在用户空间可以通过read()函数将事件数据读出。 Android输入系统的工作原理概括来说，就是监控/dev/input/下的所有设备节点，当某个节点有数据可读时，将数据读出并进行一系列的翻译加工，然后在所有的窗口中寻找合适的事件接收者，并派发给它。 1、输入子系统分层解析● Hardware层硬件层主要就是按键、触摸屏、Sensor等各种输入设备。 ● Kernel层 Kernel 层对Input相关处理只做简单的介绍。Kernel 层主要分为三层，如下： Input 设备驱动层: 采集输入设备的数据信息，通过 Input Core 的 API 上报数据。 Input Core（核心层）：为事件处理层和设备驱动层提供接口API。Event Handler（事件处理层）：通过核心层的API获取输入事件上报的数据，定义API与应用层交互。 Event Handler：Event Handler 层以通用的 evdev.c 为例来解析，上层和 Kernel 层的交互在此文件完成。 ● Framework 层Android系统中Framework 层负责管理输入事件的主要是InputManagerService（IMS）。它主要的任务就是从设备中读事件数据，然后将输入事件发送到焦点窗口中去，另外还需要让系统有机会来处理一些系统按键。显然，要完成这个工作，IMS需要与其它模块打交道，其中最主要的就是WMS和ViewRootImpl。主要的几个模块示意如下： ● App层 WindowManagerService(WMS)是窗口管理服务，核心维护了一个有序的窗口堆栈。PhoneWindowManager(PWM)里有关于手机策略的实现，和输入相关的主要是对系统按键的处理。InputManagerService是输入管理服务，主要干活的是Native层的InputManager。InputManager中的InputReader负责使用EventHub从Input driver中拿事件，然后让InputMapper解析。接着传给InputDispatcher，InputDispatcher负责一方面将事件通过InputManager，InputMonitor一路传给PhoneWindowManager来做系统输入事件的处理，另一方面将这些事件传给焦点及监视窗口。NativeInputManager实现InputReaderPolicyInterface和InputDispatcherPolicyInterface接口，在Native层的InputManager和Java层的IMS间起到一个胶水层的作用。InputMonitor实现了WindowManagerCallbacks接口，起到了IMS到WMS的连接作用。App这边，ViewRootImpl相当于App端一个顶层View的Controller。这个顶层View在WMS中对应一个窗口，用WindowState描述。WindowState中有InputWindowHandle代表一个接收输入事件的窗口句柄。InputDispatcher中的mFocusedWindowHandle指示了焦点窗口的句柄。InputDispatcher管理了一坨连接（一个连接对应一个注册到WMS的窗口），通过这些个连接InputDispatcher可以直接将输入事件发往App端的焦点窗口。输入事件从Driver开始的处理过程大致如下： 事件发往App端后，就进入事件分发阶段，这里简单提下，不做详细分析。 附： Kernel 层生成三个路径及相关设备文件： 123456789101112131415161718192021222324252627282930313233# /sys/class/input/event0 event11 event4 event7 input0 input11 input4 input7event1 event2 event5 event8 input1 input2 input5 input8event10 event3 event6 event9 input10 input3 input6 input9# /dev/input event0 event10 event2 event4 event6 event8event1 event11 event3 event5 event7 event9# /proc/bus/input devices handlers# cat devices 查看总线上的已经注册上的输入设备I: Bus=0019 Vendor=0000 Product=0000 Version=0000N: Name=\"ACCDET\"P: Phys=S: Sysfs=/devices/virtual/input/input0U: Uniq=H: Handlers=gpufreq_ib event0B: PROP=0B: EV=3B: KEY=40 0 0 0 0 0 0 1000000000 c000001800000 0...I: Bus=0019 Vendor=0000 Product=0000 Version=0001N: Name=\"fingerprint_key\"P: Phys=S: Sysfs=/devices/virtual/input/input2U: Uniq=H: Handlers=gpufreq_ib event2B: PROP=0B: EV=3B: KEY=2000100000000000 180001f 8000000000000000...cat handlers // 查看注册的handlerN: Number=0 Name=gpufreq_ibN: Number=1 Name=evdev Minor=64 2、getevent与sendevent工具Android系统提供了getevent与sendevent两个工具供开发者从设备节点中直接读取输入事件或写入输入事件。 getevent监听输入设备节点的内容，当输入事件被写入到节点中时，getevent会将其读出并打印在屏幕上。由于getevent不会对事件数据做任何加工，因此其输出的内容是由内核提供的最原始的事件。其用法如下： 1adb shell getevent [-选项] [device_path] 其中device_path是可选参数，用以指明需要监听的设备节点路径。如果省略此参数，则监听所有设备节点的事件。 打开模拟器，执行adb shell getevent –t（-t参数表示打印事件的时间戳），并按一下电源键（不要松手），可以得到以下一条输出，输出的部分数值会因机型的不同而有所差异，但格式一致： 1[1262.443489] /dev/input/event0: 0001 0074 00000001 松开电源键时，又会产生以下一条输出： 1[1262.557130] /dev/input/event0: 0001 0074 00000000 这两条输出便是按下和抬起电源键时由内核生成的原始事件。注意其输出是十六进制的。每条数据有五项信息：产生事件时的时间戳（[ 1262.443489]），产生事件的设备节点（/dev/input/event0），事件类型（0001），事件代码（0074）以及事件的值（00000001）。其中时间戳、类型、代码、值便是原始事件的四项基本元素。除时间戳外，其他三项元素的实际意义依照设备类型及厂商的不同而有所区别。在本例中，类型0x01表示此事件为一条按键事件，代码0x74表示电源键的扫描码，值0x01表示按下，0x00则表示抬起。这两条原始数据被输入系统包装成两个KeyEvent对象，作为两个按键事件派发给Framework中感兴趣的模块或应用程序。 注意一条原始事件所包含的信息量是比较有限的。而在Android API中所使用的某些输入事件，如触摸屏点击/滑动，包含了很多的信息，如XY坐标，触摸点索引等，其实是输入系统整合了多个原始事件后的结果。这个过程将在5.2.4节中详细探讨。 为了对原始事件有一个感性的认识，读者可以在运行getevent的过程中尝试一下其他的输入操作，观察一下每种输入所对应的设备节点及四项元素的取值。 输入设备的节点不仅在用户空间可读，而且是可写的，因此可以将将原始事件写入到节点中，从而实现模拟用户输入的功能。sendevent工具的作用正是如此。其用法如下： 1sendevent &lt;节点路径&gt; &lt;类型&gt;&lt;代码&gt; &lt;值&gt; 可以看出，sendevent的输入参数与getevent的输出是对应的，只不过sendevent的参数为十进制。电源键的代码0x74的十进制为116，因此可以通过快速执行如下两条命令实现点击电源键的效果： 123adb shell sendevent /dev/input/event0 1 116 1 #按下电源键adb shell sendevent /dev/input/event0 1 116 0 #抬起电源键 执行完这两条命令后，可以看到设备进入了休眠或被唤醒，与按下实际的电源键的效果一模一样。另外，执行这两条命令的时间间隔便是用户按住电源键所保持的时间，所以如果执行第一条命令后迟迟不执行第二条，则会产生长按电源键的效果——关机对话框出现了。很有趣不是么？输入设备节点在用户空间可读可写的特性为自动化测试提供了一条高效的途径。[1] 现在，读者对输入设备节点以及原始事件有了直观的认识，接下来看一下Android输入系统的基本原理。 3、Input driver模拟驱动代码实例：Input driver模拟驱动-作者韦东山 123456789101112131415161718192021222324252627282930313233343536373839404142/* 参考drivers\\input\\keyboard\\gpio_keys.c */#include &lt;linux/module.h&gt;#include &lt;linux/version.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/input.h&gt;static struct input_dev *input_emulator_dev;static int input_emulator_init(void)&#123;int i;/* 1. 分配一个input_dev结构体 */input_emulator_dev = input_allocate_device();;/* 2. 设置 *//* 2.1 能产生哪类事件 */set_bit(EV_KEY, input_emulator_dev-&gt;evbit);set_bit(EV_REP, input_emulator_dev-&gt;evbit);/* 2.2 能产生所有的按键 */for (i = 0; i &lt; BITS_TO_LONGS(KEY_CNT); i++) input_emulator_dev-&gt;keybit[i] = ~0UL;/* 2.3 为android构造一些设备信息 */input_emulator_dev-&gt;name = \"InputEmulatorFrom100ask.net\";input_emulator_dev-&gt;id.bustype = 1;input_emulator_dev-&gt;id.vendor = 0x1234;input_emulator_dev-&gt;id.product = 0x5678;input_emulator_dev-&gt;id.version = 1;/* 3. 注册 */input_register_device(input_emulator_dev);return 0;&#125;static void input_emulator_exit(void)&#123;input_unregister_device(input_emulator_dev);input_free_device(input_emulator_dev);&#125;module_init(input_emulator_init);module_exit(input_emulator_exit);MODULE_LICENSE(\"GPL\"); 测试:insmod InputEmulator.ko sendevent /dev/input/event5 1 2 1 // 1 2 1 : EV_KEY, KEY_1, downsendevent /dev/input/event5 1 2 0 // 1 2 0 : EV_KEY, KEY_1, upsendevent /dev/input/event5 0 0 0 // sync sendevent /dev/input/event5 1 3 1 // 1 3 1 : EV_KEY, KEY_2, downsendevent /dev/input/event5 1 3 0 // 1 3 0 : EV_KEY, KEY_1, upsendevent /dev/input/event5 0 0 0 // sync通过sendevent 最后会成功输入字符1、2。 三、Android Input系统（一）、Android Input 系统关键类介绍上一节讲述了输入事件的源头是位于/dev/input/下的设备节点，而输入系统的终点是由WMS管理的某个窗口。最初的输入事件为内核生成的原始事件，而最终交付给窗口的则是KeyEvent或MotionEvent对象。因此Android输入系统的主要工作是读取设备节点中的原始事件，将其加工封装，然后派发给一个特定的窗口以及窗口中的控件。这个过程由InputManagerService（以下简称IMS）系统服务为核心的多个参与者共同完成。 输入系统的总体流程和参与者如图3-1所示。 上图描述了输入事件的处理流程以及输入系统中最基本的参与者。它们是： · Linux内核，接受输入设备的中断，并将原始事件的数据写入到设备节点中。 · 设备节点，作为内核与IMS的桥梁，它将原始事件的数据暴露给用户空间，以便IMS可以从中读取事件。 · InputManagerService，一个Android系统服务，它分为Java层和Native层两部分。Java层负责与WMS的通信。而Native层则是InputReader和InputDispatcher两个输入系统关键组件的运行容器。 · EventHub，直接访问所有的设备节点。并且正如其名字所描述的，它通过一个名为getEvents()的函数将所有输入系统相关的待处理的底层事件返回给使用者。这些事件包括原始输入事件、设备节点的增删等。 · InputReader，I是IMS中的关键组件之一。它运行于一个独立的线程中，负责管理输入设备的列表与配置，以及进行输入事件的加工处理。它通过其线程循环不断地通过getEvents()函数从EventHub中将事件取出并进行处理。对于设备节点的增删事件，它会更新输入设备列表于配置。对于原始输入事件，InputReader对其进行翻译、组装、封装为包含了更多信息、更具可读性的输入事件，然后交给InputDispatcher进行派发。 · InputReaderPolicy，它为InputReader的事件加工处理提供一些策略配置，例如键盘布局信息等。 · InputDispatcher，是IMS中的另一个关键组件。它也运行于一个独立的线程中。InputDispatcher中保管了来自WMS的所有窗口的信息，其收到来自InputReader的输入事件后，会在其保管的窗口中寻找合适的窗口，并将事件派发给此窗口。 · InputDispatcherPolicy，它为InputDispatcher的派发过程提供策略控制。例如截取某些特定的输入事件用作特殊用途，或者阻止将某些事件派发给目标窗口。一个典型的例子就是HOME键被InputDispatcherPolicy截取到PhoneWindowManager中进行处理，并阻止窗口收到HOME键按下的事件。 · WMS，虽说不是输入系统中的一员，但是它却对InputDispatcher的正常工作起到了至关重要的作用。当新建窗口时，WMS为新窗口和IMS创建了事件传递所用的通道。另外，WMS还将所有窗口的信息，包括窗口的可点击区域，焦点窗口等信息，实时地更新到IMS的InputDispatcher中，使得InputDispatcher可以正确地将事件派发到指定的窗口。 · ViewRootImpl，对于某些窗口，如壁纸窗口、SurfaceView的窗口来说，窗口即是输入事件派发的终点。而对于其他的如Activity、对话框等使用了Android控件系统的窗口来说，输入事件的终点是控件（View）。ViewRootImpl将窗口所接收到的输入事件沿着控件树将事件派发给感兴趣的控件。 简单来说，内核将原始事件写入到设备节点中，InputReader不断地通过EventHub将原始事件取出来并翻译加工成Android输入事件，然后交给InputDispatcher。InputDispatcher根据WMS提供的窗口信息将事件交给合适的窗口。窗口的ViewRootImpl对象再沿着控件树将事件派发给感兴趣的控件。控件对其收到的事件作出响应，更新自己的画面、执行特定的动作。所有这些参与者以IMS为核心，构建了Android庞大而复杂的输入体系。 接下来详细讨论除Linux内核以外的其他参与者的工作原理。 （二）、IMS的创建与启动IMS分为Java层与Native层两个部分，其启动过程是从Java部分的初始化开始，进而完成Native部分的初始化。IMS在SystemServer.startOtherServices()方法中启动的。IMS的诞生分为两个阶段： · 创建新的IMS对象。 · 调用IMS对象的start()函数完成启动。 我们先看下整个启动过程的序列图，然后根据序列图来一步步分析。 Step 1、 SystemServer.startOtherServices()12345678910111213141516171819202122232425262728 [-&gt;frameworks/base/services/java/com/android/server/SystemServer.java] private void startOtherServices() &#123; ...... try &#123; ...... // ① 新建IMS对象。 traceBeginAndSlog(\"StartInputManagerService\"); inputManager = new InputManagerService(context); Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); traceBeginAndSlog(\"StartWindowManagerService\"); wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore); //将WindowManagerService加入到ServiceManager中 ServiceManager.addService(Context.WINDOW_SERVICE, wm); //将InputManagerService加入到ServiceManager中 ServiceManager.addService(Context.INPUT_SERVICE, inputManager); Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); mActivityManagerService.setWindowManager(wm); // 设置向WMS发起回调的callback对象 inputManager.setWindowManagerCallbacks(wm.getInputMonitor()); // ② 正式启动IMS inputManager.start(); &#125;&#125; 在SystemServer中先构造了一个InputManagerService对象和一个WindowManagerService对象，然后将InputManagerService对象传给WindowManagerService对象，WindowManagerService中初始化了一个InputMonitor对象，调用InputManagerService.setWindowManagerCallbacks函数将InputMonitor传进去，后面native层回调时会调用到该InputMonitor对象。 Step 2、 InputManagerService()1234567891011 [-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java] public InputManagerService(Context context) &#123; this.mContext = context; //注意这里拿了DisplayThread的Handler，意味着IMS中的消息队列处理都是在单独的DisplayThread中进行的。 //它是系统中共享的单例前台线程，主要用作输入输出的处理用。这样可以使用户体验敏感的处理少受其它工作的影响，减少延时。 this.mHandler = new InputManagerHandler(DisplayThread.get().getLooper()); //调用nativeInit来执行C++层的初始化操作 mPtr = nativeInit(this, mContext, mHandler.getLooper().getQueue()); LocalServices.addService(InputManagerInternal.class, new LocalService());&#125; Step 3、 InputManagerService.nativeInit()1234567891011121314[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]static jlong nativeInit(JNIEnv* env, jclass /* clazz */, jobject serviceObj, jobject contextObj, jobject messageQueueObj) &#123;sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);...... // 新建了一个NativeInputManager对象，NativeInputManager，此对象将是Native层组件与 //Java层IMS进行通信的桥梁NativeInputManager* im = new NativeInputManager(contextObj, serviceObj, messageQueue-&gt;getLooper());im-&gt;incStrong(0);// 返回了NativeInputManager对象的指针给Java层的IMS，IMS将其保存在mPtr成员变量中return reinterpret_cast&lt;jlong&gt;(im);&#125; 这个函数主要作用是创建一个NativeInputManager实例，并将其作为返回值保存在InputManagerService.java中的mPtr字段中。 Step 4、NativeInputManager()1234567891011[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]NativeInputManager::NativeInputManager(jobject contextObj, jobject serviceObj, const sp&lt;Looper&gt;&amp; looper) : mLooper(looper), mInteractive(true) &#123;// 出现重点了， NativeInputManager创建了EventHub//构造一个EventHub对象,最原始的输入事件都是通过它收集并且粗加工然后给到InputReader对象sp&lt;EventHub&gt; eventHub = new EventHub();// 接着创建了Native层的InputManagermInputManager = new InputManager(eventHub, this, this);&#125; NativeInputManager构造函数中创建了一个EventHub实例（稍后会详细介绍），并且将这个实例作为参数来创建一个InputManager对象，这个对象会做一些初始化的操作。 Step 5、InputManager()12345678910[-&gt;frameworks/native/services/inputflinger/InputManager.cpp]InputManager::InputManager( const sp&lt;EventHubInterface&gt;&amp; eventHub, const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy, const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;mDispatcher = new InputDispatcher(dispatcherPolicy); mReader = new InputReader(eventHub, readerPolicy, mDispatcher);initialize();&#125; 这里创建了InputDispatcher对象用于分发按键给当前focus的窗口的，同时创建了一个InputReader用于从EventHub中读取事件。 Step 6、InputManager.initialize()12345678[-&gt;frameworks/native/services/inputflinger/InputManager.cpp]void InputManager::initialize() &#123; // 创建供InputReader运行的线程InputReaderThreadmReaderThread = new InputReaderThread(mReader); // 创建供InputDispatcher运行的线程InputDispatcherThreadmDispatcherThread = new InputDispatcherThread(mDispatcher);&#125; 这里创建了一个InputReaderThread和InputDispatcherThread对象，前面构造函数中创建的InputReader实际上是通过InputReaderThread来读取事件，而InputDispatcher实际通过InputDispatcherThread来分发事件 图3-1： InputManager的构造函数也比较简洁，它创建了四个对象，分别为IMS的核心参与者InputReader与InputDispatcher，以及它们所在的线程InputReaderThread与InputDispatcherThread。注意InputManager的构造函数的参数readerPolicy与dispatcherPolicy，它们都是NativeInputManager。 至此，IMS的创建完成了。在这个过程中，输入系统的重要参与者均完成创建，并得到了如图3-1所描述的一套体系。 依次初始化NativeInputManager，EventHub，InputManager, InputDispatcher，InputReader，InputReaderThread, InputDispatcherThread。NativeInputManager可看作IMS和InputManager的中间层，将IMS的请求转化为对InputManager及其内部对象的操作，同时将InputManager中模块的请求通过JNI调回IMS。InputManager是输入控制中心，它有两个关键线程InputReaderThread和InputDispatcherThread，它们的主要功能部分分别在InputReader和InputDispacher。前者用于从设备中读取事件，后者将事件分发给目标窗口。EventHub是输入设备的控制中心，它直接与input driver打交道。负责处理输入设备的增减，查询，输入事件的处理并向上层提供getEvents()接口接收事件。在它的构造函数中，主要做三件事（结合之前Linux必备知识）： 创建epoll对象，之后就可以把各输入设备的fd挂在上面多路等待输入事件。 建立用于唤醒的pipe，把读端挂到epoll上，以后如果有设备参数的变化需要处理，而getEvents()又阻塞在设备上，就可以调用wake()在pipe的写端写入，就可以让线程从等待中返回。 利用inotify机制监听/dev/input目录下的变更，如有则意味着设备的变化，需要处理。因为事件的处理是流水线，需要InputReader先读事件，然后InputDispatcher才能进一步处理和分发。因此InputDispatcher需要监听InputReader。这里使用了Listener模式，InputDispacher作为InputReader构造函数的第三个参数，它实现InputListenerInterface接口。到了InputReader的构造函数中，将之包装成QueuedInputListener。QueuedInputListener中的成员变量mArgsQueue是一个缓冲队列，只有在flush()时，才会一次性通知InputDispatcher。QueuedInputListener应用了Command模式，它通过包装InputDispatcher(实现InputListenerInterface接口)，将事件的处理请求封装成NotifyArgs，使其有了缓冲执行的功能。 IMS的成员关系 （三）、IMS启动IMS启动主要是将前面创建的InputReaderThread和InputDispatcherThread启动起来 Step 1、InputManagerService.start()1234567[-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java]public void start() &#123; Slog.i(TAG, \"Starting input manager\"); nativeStart(mPtr); ...&#125; 该函数主要调用了nativeStart进入native层启动 Step 2. InputManagerService.nativeStart()1234567[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]static void nativeStart(JNIEnv* env, jclass /* clazz */, jlong ptr) &#123;NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr);status_t result = im-&gt;getInputManager()-&gt;start();&#125; 进入native层InputManager的start函数 Step 3、InputManager.start()1234567[-&gt;frameworks/native/services/inputflinger/InputManager.cpp]status_t InputManager::start() &#123;status_t result = mDispatcherThread-&gt;run(\"InputDispatcher\", PRIORITY_URGENT_DISPLAY);result = mReaderThread-&gt;run(\"InputReader\", PRIORITY_URGENT_DISPLAY);return OK; &#125; 这个函数实际启动了一个InputReaderThread和InputDispatcherThread来从读取和分发键盘消息，调用它们的run方法后，就会进入threadLoop函数中，只要threadLoop函数返回true，该函数就会循环执行。 InputReaderThread不断调用InputReader的pollOnce()-&gt;getEvents()函数来得到事件，这些事件可以是输入事件，也可以是由inotify监测到设备增减变更所触发的事件，稍后会详细介绍。 Step 4、InputReaderThread.threadLoop()123456[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]bool InputReaderThread::threadLoop() &#123;mReader-&gt;loopOnce();return true;&#125; 这里调用前面创建的InputReaderThread对象的loopOnce进行一次线程循环 Step5、InputReaderThread.loopOnce()123456789101112131415161718192021[-&gt;frameworks/native/services/inputflinger/InputReader.cpp] void InputReader::loopOnce() &#123;....../* ① 通过EventHub抽取事件列表。读取的结果存储在参数mEventBuffer中，返回值表示事件的个数 当EventHub中无事件可以抽取时，此函数的调用将会阻塞直到事件到来或者超时 */size_tcount = mEventHub-&gt;getEvents(timeoutMillis,mEventBuffer, EVENT_BUFFER_SIZE);&#123; AutoMutex _l(mLock); ...... if(count) &#123; // ② 如果有抽得事件，则调用processEventsLocked()函数对事件进行加工处理 processEventsLocked(mEventBuffer, count); &#125; ......&#125;....../* ③ 发布事件。 processEventsLocked()函数在对事件进行加工处理之后，便将处理后的事件存储在 mQueuedListener中。在循环的最后，通过调用flush()函数将所有事件交付给InputDispatcher */ mQueuedListener-&gt;flush(); &#125; InputReader的一次线程循环的工作思路比较清晰，一共三步： · 首先从EventHub中抽取未处理的事件列表。这些事件分为两类，一类是从设备节点中读取的原始输入事件，另一类则是输入设备可用性变化事件，简称为设备事件。 · 通过processEventsLocked()对事件进行处理。对于设备事件，此函数对根据设备的可用性加载或移除设备对应的配置信息。对于原始输入事件，则在进行转译、封装与加工后将结果暂存到mQueuedListener中。 · 所有事件处理完毕后，调用mQueuedListener.flush()将所有暂存的输入事件一次性地交付给InputDispatcher。 这便是InputReader的总体工作流程。而我们接下来将详细讨论这三步的实现。 Step 6、InputDispatcherThread.threadLoop()InputDisptacher的主要任务是把收到的输入事件发送到PhoneWIndowManager或App端的焦点窗口上，稍后详细介绍。 123456[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]bool InputDispatcherThread::threadLoop() &#123;mDispatcher-&gt;dispatchOnce();return true;&#125; 这里调用前面创建的InputDispatcher对象的dispatchOnce函数进行一次按键分发 Step 7、InputDispatcher.dispatchOnce()12345678910111213141516171819[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::dispatchOnce() &#123;nsecs_t nextWakeupTime = LONG_LONG_MAX;&#123; // acquire lock AutoMutex _l(mLock); mDispatcherIsAliveCondition.broadcast(); if (!haveCommandsLocked()) &#123; dispatchOnceInnerLocked(&amp;nextWakeupTime); &#125; if (runCommandsLockedInterruptible()) &#123; nextWakeupTime = LONG_LONG_MIN; &#125;&#125; // release lock// Wait for callback or timeout or wake. (make sure we round up, not down)nsecs_t currentTime = now();int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);mLooper-&gt;pollOnce(timeoutMillis);&#125; 上述函数主要是调用dispatchOnceInnerLocked来进行一次按键分发，当没有按键消息时会走到mLooper-&gt;pollOnce(timeoutMillis)；这个函数会进入睡眠状态，当有按键消息发生时该函数会返回，然后走到dispatchOnceInnerLocked函数。这里mLooper-&gt;pollOnce为何会睡眠涉及到Android的Handler机制[☺再总结☺]。 小结：完成IMS的创建之后，InputManagerService.start()函数以启动IMS。InputManager的创建过程分别为InputReader与InputDispatcher创建了承载它们运行的线程，然而并未将这两个线程启动，因此IMS的各员大将仍处于待命状态。此时start()函数的功能就是启动这两个线程，使得InputReader于InputDispatcher开始工作。 当两个线程启动后，InputReader在其线程循环中不断地从EventHub中抽取原始输入事件，进行加工处理后将加工所得的事件放入InputDispatcher的派发发队列中。InputDispatcher则在其线程循环中将派发队列中的事件取出，查找合适的窗口，将事件写入到窗口的事件接收管道中。窗口事件接收线程的Looper从管道中将事件取出，交由事件处理函数进行事件响应。整个过程共有三个线程首尾相接，像三台水泵似的一层层地将事件交付给事件处理函数。如下图所示。 InputManagerService.start()函数的作用，就像为Reader线程、Dispatcher线程这两台水泵按下开关，而Looper这台水泵在窗口创建时便已经处于运行状态了。自此，输入系统动力十足地开始运转，设备节点中的输入事件将被源源不断地抽取给事件处理者。 四、深入理解EventHubInputReaderThread继承自C++的Thread类，Thread类封装了pthread线程工具，提供了与Java层Thread类相似的API。C++的Thread类提供了一个名为threadLoop()的纯虚函数，当线程开始运行后，将会在内建的线程循环中不断地调用threadLoop()，直到此函数返回false，则退出线程循环，从而结束线程。InputReaderThread启动后，其线程循环将不断地执行InputReader.loopOnce()函数。因此这个loopOnce()函数作为线程循环的循环体包含了InputReader的所有工作。前面一小节 Step5. InputReaderThread.loopOnce() 已经说到InputReaderThread一次线程循环。接下来详细说明EventHub。 · 首先从EventHub中抽取未处理的事件列表。这些事件分为两类，一类是从设备节点中读取的原始输入事件，另一类则是输入设备可用性变化事件，简称为设备事件。 123456789 [-&gt;frameworks/native/services/inputflinger/InputReader.cpp] void InputReader::loopOnce() &#123;....../* ① 通过EventHub抽取事件列表。读取的结果存储在参数mEventBuffer中，返回值表示事件的个数 当EventHub中无事件可以抽取时，此函数的调用将会阻塞直到事件到来或者超时 */size_tcount = mEventHub-&gt;getEvents(timeoutMillis,mEventBuffer, EVENT_BUFFER_SIZE);......&#125; 首先贴一张EventHub-&gt;getEvents()工作时序图，跟着时序图一步步介绍。 （1）、深入理解EventHub1、设备节点监听的建立123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263frameworks/native/services/inputflinger/EventHub.cppEventHub::EventHub(void) : mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(1), mControllerNumbers(), mOpeningDevices(0), mClosingDevices(0), mNeedToSendFinishedDeviceScan(false), mNeedToReopenDevices(false), mNeedToScanDevices(true), mPendingEventCount(0), mPendingEventIndex(0), mPendingINotify(false) &#123;acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);// ① 首先使用epoll_create()函数创建一个epoll对象。EPOLL_SIZE_HINT指定最大监听个数为8//这个epoll对象将用来监听设备节点是否有数据可读（有无事件） mEpollFd = epoll_create(EPOLL_SIZE_HINT);LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, \"Could not create epoll instance. errno=%d\", errno);// ② 创建一个inotify对象。这个inotify对象将被用来监听设备节点的增删事件mINotifyFd = inotify_init(); //将存储设备节点的路径/dev/input作为监听对象添加到inotify对象中。当此文件夹下的设备节点 //发生创建与删除事件时，都可以通过mINotifyFd读取事件的详细信息 //static const char *DEVICE_PATH = \"/dev/input\";int result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);LOG_ALWAYS_FATAL_IF(result &lt; 0, \"Could not register INotify for %s. errno=%d\", DEVICE_PATH, errno); //③ 接下来将mINotifyFd作为epoll的一个监控对象。当inotify事件到来时，epoll_wait()将//立刻返回，EventHub便可从mINotifyFd中读取设备节点的增删信息，并作相应处理struct epoll_event eventItem;memset(&amp;eventItem, 0, sizeof(eventItem));eventItem.events = EPOLLIN;// 监听mINotifyFd可读eventItem.data.u32 = EPOLL_ID_INOTIFY; // 注意这里并没有使用fd字段，而使用了自定义的值EPOLL_ID_INOTIFYresult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);// 将对mINotifyFd的监听注册到epoll对象中LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add INotify to epoll instance. errno=%d\", errno);//在构造函数剩余的代码中，EventHub创建了一个名为wakeFds的匿名管道，并将管道读取端的描述符//的可读事件注册到epoll对象中。因为InputReader在执行getEvents()时会因无事件而导致其线程//阻塞在epoll_wait()的调用里，然而有时希望能够立刻唤醒InputReader线程使其处理一些请求。此//时只需向wakeFds管道的写入端写入任意数据，此时读取端有数据可读，使得epoll_wait()得以返回//从而达到唤醒InputReader线程的目的int wakeFds[2];result = pipe(wakeFds);LOG_ALWAYS_FATAL_IF(result != 0, \"Could not create wake pipe. errno=%d\", errno);mWakeReadPipeFd = wakeFds[0];mWakeWritePipeFd = wakeFds[1];result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);LOG_ALWAYS_FATAL_IF(result != 0, \"Could not make wake read pipe non-blocking. errno=%d\", errno);result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);LOG_ALWAYS_FATAL_IF(result != 0, \"Could not make wake write pipe non-blocking. errno=%d\", errno);eventItem.data.u32 = EPOLL_ID_WAKE;result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake read pipe to epoll instance. errno=%d\", errno);int major, minor;getLinuxRelease(&amp;major, &amp;minor);// EPOLLWAKEUP was introduced in kernel 3.5mUsingEpollWakeup = major &gt; 3 || (major == 3 &amp;&amp; minor &gt;= 5);&#125; EventHub的构造函数初识化了Epoll对象和INotify对象，分别监听原始输入事件与设备节点增删事件。同时将INotify对象的可读性事件也注册到Epoll中，因此EventHub可以像处理原始输入事件一样监听设备节点增删事件了。 构造函数同时也揭示了EventHub的监听工作分为设备节点和原始输入事件两个方面，接下来将深入探讨这两方面的内容。 2、getEvents()函数的工作方式正如前文所述，InputReaderThread的线程循环为Reader子系统提供了运转的动力，EventHub的工作也是由它驱动的。InputReader::loopOnce()函数调用EventHub::getEvents()函数获取事件列表，所以这个getEvents()是EventHub运行的动力所在，几乎包含了EventHub的所有工作内容，因此首先要将getEvents()函数的工作方式搞清楚。getEvents()函数的签名如下：1size_t EventHub::getEvents(int timeoutMillis,RawEvent* buffer, size_t bufferSize) 此函数将尽可能多地读取设备增删事件与原始输入事件，将它们封装为RawEvent结构体，并放入buffer中供InputReader进行处理。RawEvent结构体的定义如下：[EventHub.h–&gt;RawEvent] 12345678struct RawEvent &#123; nsecs_t when; /* 发生事件时的时间戳 */ int32_t deviceId; //产生事件的设备Id，它是由EventHub自行分配的，InputReader //以根据它从EventHub中获取此设备的详细信息 int32_t type; /* 事件的类型 */ int32_t code; /* 事件代码 */ int32_t value; /* 事件值 */ &#125;; 可以看出，RawEvent结构体与getevent工具的输出十分一致，包含了原始输入事件的四个基本元素，因此用RawEvent结构体表示原始输入事件是非常直观的。RawEvent同时也用来表示设备增删事件，为此，EventHub定义了三个特殊的事件类型DEVICE_ADD、DEVICE_REMOVED以及FINISHED_DEVICE_SCAN，用以与原始输入事件进行区别。 由于getEvents()函数较为复杂，为了给后续分析铺平道路，本节不讨论其细节，先通过伪代码理解此函数的结构与工作方式，在后续深入分析时思路才会比较清晰。 getEvents()函数的本质就是读取并处理Epoll事件与INotify事件 参考以下代码： [EventHub.cpp–&gt;EventHub::getEvents()] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263size_t EventHub::getEvents(int timeoutMillis,RawEvent* buffer, size_t bufferSize) &#123;// event指针指向了在buffer下一个可用于存储事件的RawEvent结构体。每存储一个事件，// event指针都回向后偏移一个元素 */RawEvent* event = buffer; // capacity记录了buffer中剩余的元素数量。当capacity为0时，表示buffer已满，此时需要停// 继续处理新事件，并将已处理的事件返回给调用者size_tcapacity = bufferSize;// 接下来的循环是getEvents()函数的主体。在这个循环中，会先将可用事件放入到buffer中并返回。// 如果没有可用事件，则进入epoll_wait()等待事件的到来，epoll_wait()返回后会重新循环将可用// 将新事件放入bufferfor (;;)&#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); /* ① 首先进行与设备相关的工作。某些情况下，如EventHub创建后第一次执行getEvents()函数 */ /* 时，需要扫描/dev/input文件夹下的所有设备节点并将这些设备打开。另外，当设备节点的发生增 */ /* 动作生时，会将设备事件存入到buffer中 */ ...... /* ② 处理未被InputReader取走的输入事件与设备事件。epoll_wait()所取出的epoll_event */ /* 存储在mPendingEventItems中，mPendingEventCount指定了mPendingEventItems数组 */ /* 所存储的事件个数。而mPendingEventIndex指定尚未处理的epoll_event的索引 */ while (mPendingEventIndex &lt; mPendingEventCount) &#123; const struct epoll_event&amp; eventItem = mPendingEventItems[mPendingEventIndex++]; /* 在这里分析每一个epoll_event，如果是表示设备节点可读，则读取原始事件并放置到buffer */ /* 中。如果是表示mINotifyFd可读，则设置mPendingINotify为true，当InputReader */ /* 将现有的输入事件都取出后读取mINotifyFd中的事件，并进行相应的设备加载与卸载操作。 */ /* 另外，如果此epoll_event表示wakeFds的读取端有数据可读，则设置awake标志为true， */ /* 无论此次getEvents()调用有无取到事件，都不会再次进行epoll_wait()进行事件等待 */ ...... &#125; // ③ 如果mINotifyFd有数据可读，说明设备节点发生了增删操作 if(mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123; /* 读取mINotifyFd中的事件，同时对输入设备进行相应的加载与卸载操作。这个操作必须当 */ /* InputReader将现有输入事件读取并处理完毕后才能进行，因为现有的输入事件可能来自需要 */ /* 被卸载的输入设备，InputReader处理这些事件依赖于对应的设备信息 */ ...... deviceChanged= true; &#125; // 设备节点增删操作发生时，则重新执行循环体，以便将设备变化的事件放入buffer中 if(deviceChanged) &#123; continue; &#125; // 如果此次getEvents()调用成功获取了一些事件，或者要求唤醒InputReader，则退出循环并 // 结束getEvents()的调用，使InputReader可以立刻对事件进行处理 if(event != buffer || awoken) &#123; break; &#125; /* ④ 如果此次getEvents()调用没能获取事件，说明mPendingEventItems中没有事件可用， */ /* 于是执行epoll_wait()函数等待新的事件到来，将结果存储到mPendingEventItems里，并重 */ /* 置mPendingEventIndex为0 */ mPendingEventIndex = 0; ...... intpollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS,timeoutMillis); ...... mPendingEventCount= size_t(pollResult); // 从epoll_wait()中得到新的事件后，重新循环，对新事件进行处理&#125;// 返回本次getEvents()调用所读取的事件数量returnevent - buffer;&#125; getEvents()函数使用Epoll的核心是mPendingEventItems数组，它是一个事件池。getEvents()函数会优先从这个事件池获取epoll事件进行处理，并将读取相应的原始输入事件返回给调用者。当因为事件池枯竭而导致调用者无法获得任何事件时，会调用epoll_wait()函数等待新事件的到来，将事件池重新注满，然后再重新处理事件池中的Epoll事件。从这个意义来说，getEvents()函数的调用过程，就是消费epoll_wait()所产生的Epoll事件的过程。因此可以将从epoll_wait()的调用开始，到将Epoll事件消费完毕的过程称为EventHub的一个监听周期。依据每次epoll_wait()产生的Epoll事件的数量以及设备节点中原始输入事件的数量，一个监听周期包含一次或多次getEvents()调用。周期中的第一次调用会因为事件池枯竭而直接进入epoll_wait()，而周期中的最后一次调用一定会将最后的事件取走。 注意getEvents()采用事件池机制的根本原因是buffer的容量限制。由于一次epoll_wait()可能返回多个设备节点的可读事件，每个设备节点又有可能读取多条原始输入事件，一段时间内原始输入事件的数量可能大于buffer的容量。因此需要一个事件池以缓存因buffer容量不够而无法处理的epoll事件，以便在下次调用时可以将这些事件优先处理。这是缓冲区操作的一个常用技巧。 当有INotify事件可以从mINotifyFd中读取时，会产生一个epoll事件，EventHub便得知设备节点发生了增删操作。在getEvents()将事件池中的所有事件处理完毕后，便会从mINotifyFd中读取INotify事件，进行输入设备的加载/卸载操作，然后生成对应的RawEvent结构体并返回给调用者。 通过上述分析可以看到，getEvents()包含了原始输入事件读取、输入设备加载/卸载等操作。这几乎是EventHub的全部工作了。如果没有geEvents()的调用，EventHub将对输入事件、设备节点增删事件置若罔闻，因此可以将一次getEvents()调用理解为一次心跳，EventHub的核心功能都会在这次心跳中完成。 getEvents()的代码还揭示了另外一个信息：在一个监听周期内的设备增删事件与Epoll事件的优先级。设备事件的生成逻辑位于Epoll事件的处理之前，因此getEvents()将优先生成设备增删事件，完成所有设备增删事件的生成之前不会处理Epoll事件，也就是不会生成原始输入事件。 接下来我们将从设备管理与原始输入事件处理两个方面深入探讨EventHub。 3、输入设备管理因为输入设备是输入事件的来源，并且决定了输入事件的含义，因此首先讨论EventHub的输入设备管理机制。 输入设备是一个可以为接收用户操作的硬件，内核会为每一个输入设备在/dev/input/下创建一个设备节点，而当输入设备不可用时（例如被拔出），将其设备节点删除。这个设备节点包含了输入设备的所有信息，包括名称、厂商、设备类型，设备的功能等。除了设备节点，某些输入设备还包含一些自定义配置，这些配置以键值对的形式存储在某个文件中。这些信息决定了Reader子系统如何加工原始输入事件。EventHub负责在设备节点可用时加载并维护这些信息，并在设备节点被删除时将其移除。 EventHub通过一个定义在其内部的名为Device的私有结构体来描述一个输入设备。其定义如下： [EventHub.h–&gt;EventHub::Device] 123456789101112131415161718192021222324252627struct Device &#123;Device* next; /* Device结构体实际上是一个单链表 */int fd; /* fd表示此设备的设备节点的描述符，可以从此描述符中读取原始输入事件 */const int32_t id; /* id在输入系统中唯一标识这个设备，由EventHub在加载设备时进行分配 */const String8 path; /* path存储了设备节点在文件系统中的路径 */const InputDeviceIdentifier identifier; /* 厂商信息，存储了设备的供应商、型号等信息 这些信息从设备节点中获得 */uint32_t classes; /* classes表示了设备的类别，键盘设备，触控设备等。一个设备可以同时属于 多个设备类别。类别决定了InputReader如何加工其原始输入事件 *//* 接下来是一系列的事件位掩码，它们详细地描述了设备能够产生的事件类型。设备能够产生的事件类型 决定了此设备所属的类型*/uint8_t keyBitmask[(KEY_MAX + 1) / 8];....../* 配置信息。以键值对的形式存储在一个文件中，其路径取决于identfier字段中的厂商信息，这些 配置信息将会影响InputReader对此设备的事件的加工行为 */String8 configurationFile;PropertyMap* configuration;/* 键盘映射表。对于键盘类型的设备，这些键盘映射表将原始事件中的键盘扫描码转换为Android定义的 的按键值。这个映射表也是从一个文件中加载的，文件路径取决于dentifier字段中的厂商信息 */ VirtualKeyMap* virtualKeyMap;KeyMap keyMap; sp&lt;KeyCharacterMap&gt; overlayKeyMap; sp&lt;KeyCharacterMap&gt; combinedKeyMap;// 力反馈相关的信息。有些设备如高级的游戏手柄支持力反馈功能，目前暂不考虑bool ffEffectPlaying;int16_t ffEffectId;&#125;; Device结构体所存储的信息主要包括以下几个方面： · 设备节点信息：保存了输入设备节点的文件描述符、文件路径等。 · 厂商信息：包括供应商、设备型号、名称等信息，这些信息决定了加载配置文件与键盘映射表的路径。 · 设备特性信息：包括设备的类别，可以上报的事件种类等。这些特性信息直接影响了InputReader对其所产生的事件的加工处理方式。 · 设备的配置信息：包括键盘映射表及其他自定义的信息，从特定位置的配置文件中读取。 另外，Device结构体还存储了力反馈所需的一些数据。在本节中暂不讨论。 EventHub用一个名为mDevices的字典保存当前处于打开状态的设备节点的Device结构体。字典的键为设备Id。 （1）、输入设备的加载EventHub在创建后在第一次调用getEvents()函数时完成对系统中现有输入设备的加载。 再看一下getEvents()函数中相关内容的实现： [EventHub.cpp–&gt;EventHub::getEvents()] 1234567891011121314151617size_t EventHub::getEvents(int timeoutMillis,RawEvent* buffer, size_t bufferSize) &#123;for (;;)&#123; // 处理输入设备卸载操作 ...... /* 在EventHub的构造函数中，mNeedToScanDevices被设置为true，因此创建后第一次调用 getEvents()函数会执行scanDevicesLocked()，加载所有输入设备 */ if(mNeedToScanDevices) &#123; mNeedToScanDevices = false; /*scanDevicesLocked()将会把/dev/input下所有可用的输入设备打开并存储到Device 结构体中 */ scanDevicesLocked(); mNeedToSendFinishedDeviceScan = true; &#125; ......&#125;returnevent – buffer;&#125; 加载所有输入设备由scanDevicesLocked()函数完成。看一下其实现： [EventHub.cpp–&gt;EventHub::scanDevicesLocked()] 12345678910void EventHub::scanDevicesLocked() &#123;// 调用scanDirLocked()函数遍历/dev/input文件夹下的所有设备节点并打开status_tres = scanDirLocked(DEVICE_PATH);......// 错误处理// 打开一个名为VIRTUAL_KEYBOARD的输入设备。这个设备时刻是打开着的。它是一个虚拟的输入设 备，没有对应的输入节点。读者先记住有这么一个输入设备存在于输入系统中 */if(mDevices.indexOfKey(VIRTUAL_KEYBOARD_ID) &lt; 0) &#123; createVirtualKeyboardLocked();&#125;&#125; scanDirLocked()遍历指定文件夹下的所有设备节点，分别对其执行openDeviceLocked()完成设备的打开操作。在这个函数中将为设备节点创建并加载Device结构体。参考其代码： [EventHub.cpp–&gt;EventHub::openDeviceLocked()] 12345678910111213141516171819202122232425262728293031status_t EventHub::openDeviceLocked(const char*devicePath) &#123;// 打开设备节点的文件描述符，用于获取设备信息以及读取原始输入事件int fd =open(devicePath, O_RDWR | O_CLOEXEC);// 接下来的代码通过ioctl()函数从设备节点中获取输入设备的厂商信息InputDeviceIdentifier identifier;......// 分配一个设备Id并创建Device结构体int32_tdeviceId = mNextDeviceId++;Device*device = new Device(fd, deviceId, String8(devicePath), identifier);// 为此设备加载配置信息。 loadConfigurationLocked(device); // ① 通过ioctl函数获取设备的事件位掩码。事件位掩码指定了输入设备可以产生何种类型的输入事件 ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(device-&gt;keyBitmask)),device-&gt;keyBitmask);...... ioctl(fd, EVIOCGPROP(sizeof(device-&gt;propBitmask)),device-&gt;propBitmask); // 接下来的一大段内容是根据事件位掩码为设备分配类别，即设置classes字段。、...... /* ② 将设备节点的描述符的可读事件注册到Epoll中。当此设备的输入事件到来时，Epoll会在 getEvents()函数的调用中产生一条epoll事件 */ structepoll_event eventItem; memset(&amp;eventItem, 0, sizeof(eventItem)); eventItem.events = EPOLLIN; eventItem.data.u32 = deviceId; /* 注意，epoll_event的自定义信息是设备的Id if(epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp;eventItem)) &#123; ...... &#125; ...... // ③ 调用addDeviceLocked()将Device添加到mDevices字典中 addDeviceLocked(device); return0; &#125; openDeviceLocked()函数打开指定路径的设备节点，为其创建并填充Device结构体，然后将设备节点的可读事件注册到Epoll中，最后将新建的Device结构体添加到mDevices字典中以供检索之需。整个过程比较清晰，但仍有以下几点需要注意： · openDeviceLocked()函数从设备节点中获取了设备可能上报的事件类型，并据此为设备分配了类别。整个分配过程非常繁琐，由于它和InputReader的事件加工过程关系紧密，因此这部分内容将在5.2.4节再做详细讨论。 · 向Epoll注册设备节点的可读事件时，epoll_event的自定义数据被设置为设备的Id而不是fd。 · addDeviceLocked()将新建的Device对象添加到mDevices字典中的同时也会将其添加到一个名为mOpeningDevices的链表中。这个链表保存了刚刚被加载，但尚未通过getEvents()函数向InputReader发送DEVICE_ADD事件的设备。 完成输入设备的加载之后，通过getEvents()函数便可以读取到此设备所产生的输入事件了。除了在getEvents()函数中使用scanDevicesLockd()一次性加载所有输入设备，当INotify事件告知有新的输入设备节点被创建时，也会通过opendDeviceLocked()将设备加载，稍后再做讨论。 （2）、输入设备的卸载输入设备的卸载由closeDeviceLocked()函数完成。由于此函数的工作内容与openDeviceLocked()函数正好相反，就不列出其代码了。设备的卸载过程为： · 从Epoll中注销对描述符的监听。 · 关闭设备节点的描述符。 · 从mDevices字典中删除对应的Device对象。 · 将Device对象添加到mClosingDevices链表中，与mOpeningDevices类似，这个链表保存了刚刚被卸载，但尚未通过getEvents()函数向InputReader发送DEVICE_REMOVED事件的设备。 同加载设备一样，在getEvents()函数中有根据需要卸载所有输入设备的操作（比如当EventHub要求重新加载所有设备时，会先将所有设备卸载）。并且当INotify事件告知有设备节点删除时也会调用closeDeviceLocked()将设备卸载。 （3）、设备增删事件在分析设备的加载与卸载时发现，新加载的设备与新卸载的设备会被分别放入mOpeningDevices与mClosingDevices链表之中。这两个链表将是在getEvents()函数中向InputReader发送设备增删事件的依据。 参考getEvents()函数的相关代码，以设备卸载事件为例看一下设备增删事件是如何产生的： [EventHub.cpp–&gt;EventHub::getEvents()] 1234567891011121314151617181920212223242526size_t EventHub::getEvents(int timeoutMillis,RawEvent* buffer, size_t bufferSize) &#123;for (;;)&#123; // 遍历mClosingDevices链表，为每一个已卸载的设备生成DEVICE_REMOVED事件 while (mClosingDevices) &#123; Device* device = mClosingDevices; mClosingDevices = device-&gt;next; /* 分析getEvents()函数的工作方式时介绍过，event指针指向buffer中下一个可用于填充 事件的RawEvent对象 */ event-&gt;when = now; // 设置产生事件的事件戳 event-&gt;deviceId = device-&gt;id ==mBuiltInKeyboardId ? BUILT_IN_KEYBOARD_ID : device-&gt;id; event-&gt;type = DEVICE_REMOVED; // 设置事件的类型为DEVICE_REMOVED event += 1; // 将event指针移动到下一个可用于填充事件的RawEvent对象 delete device; // 生成DEVICE_REMOVED事件之后，被卸载的Device对象就不再需要了 mNeedToSendFinishedDeviceScan = true; // 随后发送FINISHED_DEVICE_SCAN事件 /* 当buffer已满则停止继续生成事件，将已生成的事件返回给调用者。尚未生成的事件 将在下次getEvents()调用时生成并返回给调用者 */ if (--capacity == 0) &#123; break; &#125; &#125; // 接下来进行DEVICE_ADDED事件的生成，此过程与 DEVICE_REMOVED事件的生成一致 ......&#125;returnevent – buffer;&#125; 可以看到，在一次getEvents()调用中会尝试为所有尚未发送增删事件的输入设备生成对应的事件返回给调用者。表示设备增删事件的RawEvent对象包含三个信息：产生事件的事件戳、产生事件的设备Id，以及事件类型（DEVICE_ADDED或DEVICE_REMOVED）。 当生成设备增删事件时，会设置mNeedToSendFinishedDeviceSan为true，这个动作的意思是完成所有DEVICE_ADDED/REMOVED事件的生成之后，需要向getEvents()的调用者发送一个FINISHED_DEVICE_SCAN事件，表示设备增删事件的上报结束。这个事件仅包括时间戳与事件类型两个信息。 经过以上分析可知，EventHub可以产生的设备增删事件一共有三种，而且这三种事件拥有固定的优先级，DEVICE_REMOVED事件的优先级最高，DEVICE_ADDED事件次之，FINISHED_DEVICE_SCAN事件最低。而且，getEvents()完成当前高优先级事件的生成之前，不会进行低优先级事件的生成。因此，当发生设备的加载与卸载时，EventHub所生成的完整的设备增删事件序列如图5-5所示，其中R表示DEVICE_REMOVED，A表示DEVICE_ADDED，F表示FINISHED_DEVICE_SCAN。 图：设备增删事件的完整序列 由于参数buffer的容量限制，这个事件序列可能需要通过多次getEvents()调用才能完整地返回给调用者。另外，根据5.2.2节的讨论，设备增删事件相对于Epoll事件拥有较高的优先级，因此从R1事件开始生成到F事件生成之前，getEvents()不会处理Epoll事件，也就是说不会生成原始输入事件。 总结一下设备增删事件的生成原理： · 当发生设备增删时，addDeviceLocked()函数与closeDeviceLocked()函数会将相应的设备放入mOpeningDevices和mClosingDevices链表中。 · getEvents()函数会根据mOpeningDevices和mClosingDevices两个链表生成对应DEVICE_ADDED和DEVICE_REMOVED事件，其中后者的生成拥有高优先级。 · DEVICE_ADDED和DEVICE_REMOVED事件都生成完毕后，getEvents()会生成FINISHED_DEVICE_SCAN事件，标志设备增删事件序列的结束。 （4）、通过INotify动态地加载与卸载设备通过前文的介绍知道了openDeviceLocked()和closeDeviceLocked()可以加载与卸载输入设备。接下来分析EventHub如何通过INotify进行设备的动态加载与卸载。在EventHub的构造函数中创建了一个名为mINotifyFd的INotify对象的描述符，用以监控/dev/input下设备节点的增删。之后将mINotifyFd的可读事件加入到Epoll中。于是可以确定动态加载与卸载设备的工作方式为：首先筛选epoll_wait()函数所取得的Epoll事件，如果Epoll事件表示了mINotifyFd可读，便从mINotifyFd中读取设备节点的增删事件，然后通过执行openDeviceLocked()或closeDeviceLocked()进行设备的加载与卸载。 看一下getEvents()中与INotify相关的代码： [EventHub.cpp–&gt;EventHub::getEvents()] 12345678910111213141516171819202122232425262728293031size_t EventHub::getEvents(int timeoutMillis,RawEvent* buffer, size_t bufferSize) &#123;for (;;)&#123; ...... // 设备增删事件处理 while(mPendingEventIndex &lt; mPendingEventCount) &#123; const struct epoll_event&amp; eventItem = mPendingEventItems[mPendingEventIndex++]; /* ① 通过Epoll事件的data字段确定此事件表示了mINotifyFd可读 注意EPOLL_ID_INOTIFY在EventHub的构造函数中作为data字段向 Epoll注册mINotifyFd的可读事件 */ if (eventItem.data.u32 == EPOLL_ID_INOTIFY) &#123; if (eventItem.events &amp; EPOLLIN) &#123; mPendingINotify = true; // 标记INotify事件待处理 &#125; else &#123; ...... &#125; continue; // 继续处理下一条Epoll事件 &#125; ...... // 其他Epoll事件的处理 &#125; // 如果INotify事件待处理 if(mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123; mPendingINotify = false; /* ② 调用readNotifyLocked()函数读取并处理存储在mINotifyFd中的INotify事件 这个函数将完成设备的加载与卸载 */ readNotifyLocked(); deviceChanged = true; &#125; //③ 如果处理了INotify事件，则返回到循环开始处，生成设备增删事件 if(deviceChanged) &#123; continue; &#125;&#125;&#125; getEvents()函数中与INotify相关的代码共有三处： · 识别表示mINotifyFd可读的Epoll事件，并通过设置mPendingINotify为true以标记有INotify事件待处理。getEvents()并没有立刻处理INotify事件，因为此时进行设备的加载与卸载是不安全的。其他Epoll事件可能包含了来自即将被卸载的设备的输入事件，因此需要将所有Epoll事件都处理完毕后再进行加载与卸载操作。 · 当epoll_wait()所返回的Epoll事件都处理完毕后，调用readNotifyLocked()函数读取mINotifyFd中的事件，并进行设备的加载与卸载操作。 · 完成设备的动态加载与卸载后，需要返回到循环最开始处，以便设备增删事件处理代码生成设备的增删事件。 其中第一部分与第三部分比较容易理解。接下来看一下readNotifyLocked()是如何工作的。 [EventHub.cpp–&gt;EventHub::readNotifyLocked()] 123456789101112131415161718status_t EventHub::readNotifyLocked() &#123; ...... // 从mINotifyFd中读取INotify事件列表 res =read(mINotifyFd, event_buf, sizeof(event_buf)); ...... // 逐个处理列表中的事件 while(res &gt;= (int)sizeof(*event)) &#123; strcpy(filename, event-&gt;name); // 从事件中获取设备节点路径 if(event-&gt;mask &amp; IN_CREATE) &#123; openDeviceLocked(devname); // 如果事件类型为IN_CREATE，则加载对应设备 &#125;else &#123; closeDeviceByPathLocked(devname); // 否则卸载对应设备 &#125; ......// 移动到列表中的下一个事件 &#125; return0; &#125; （5）、EventHub设备管理总结至此，EventHub的设备管理相关的知识便讨论完毕了。在这里进行一下总结： · EventHub通过Device结构体描述输入设备的各种信息。 · EventHub在getEvents()函数中进行设备的加载与卸载操作。设备的加载与卸载分为按需加载或卸载以及通过INotify动态加载或卸载特定设备两种方式。 · getEvents()函数进行了设备的加载与卸载操作后，会生成DEVICE_ADDED、DEVICE_REMOVED以及FINISHED_DEVICE_SCAN三种设备增删事件，并且设备增删事件拥有高于Epoll事件的优先级。4．原始输入事件的监听与读取本节将讨论EventHub另一个核心的功能，监听与读取原始输入事件。 回忆一下输入设备的加载过程，当设备加载时，openDeviceLocked()会打开设备节点的文件描述符，并将其可读事件注册进Epoll中。于是当设备的原始输入事件到来时，getEvents()函数将会获得一条Epoll事件，然后根据此Epoll事件读取文件描述符中的原始输入事件，将其填充到RawEvents结构体并放入buffer中被调用者取走。openDeviceLocked()注册了设备节点的EPOLLIN和EPOLLHUP两个事件，分别表示可读与被挂起（不可用），因此getEvents()需要分别处理这两种事件。 看一下getEvents()函数中的相关代码： [EventHub.cpp–&gt;EventHub::getEvents()] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253size_t EventHub::getEvents(int timeoutMillis,RawEvent* buffer, size_t bufferSize) &#123;for (;;)&#123; ...... // 设备增删事件处理 while(mPendingEventIndex &lt; mPendingEventCount) &#123; const struct epoll_event&amp; eventItem = mPendingEventItems[mPendingEventIndex++]; ...... // INotify与wakeFd的Epoll事件处理 /* ① 通过Epoll的data.u32字段获取设备Id，进而获取对应的Device对象。如果无法找到 对应的Device对象，说明此Epoll事件并不表示原始输入事件的到来，忽略之 */ ssize_t deviceIndex = mDevices.indexOfKey(eventItem.data.u32); Device* device = mDevices.valueAt(deviceIndex); ...... if (eventItem.events &amp; EPOLLIN) &#123; /* ② 如果Epoll事件为EPOLLIN，表示设备节点有原始输入事件可读。此时可以从描述符 中读取。读取结果作为input_event结构体并存储在readBuffer中，注意事件的个数 受到capacity的限制*/ int32_t readSize = read(device-&gt;fd, readBuffer, sizeof(structinput_event) * capacity); if (......) &#123; ......// 一些错误处理 &#125; else &#123; size_t count = size_t(readSize) / sizeof(struct input_event); /* ② 将读取到的每一个input_event结构体中的数据转换为一个RawEvent对象， 并存储在buffer参数中以返回给调用者 */ for (size_t i = 0; i &lt; count; i++) &#123; const structinput_event&amp; iev = readBuffer[i]; ...... event-&gt;when = now; event-&gt;deviceId =deviceId; event-&gt;type =iev.type; event-&gt;code =iev.code; event-&gt;value =iev.value; event += 1; // 移动到buffer的下一个可用元素 &#125; /* 接下来的一个细节需要注意，因为buffer的容量限制，可能无法完全读取设备节点 中存储的原始事件。一旦buffer满了则需要立刻返回给调用者。设备节点中剩余的 输入事件将在下次getEvents()调用时继续读取，也就是说，当前的Epoll事件 并未处理完毕。mPendingEventIndex -= 1的目的就是使下次getEvents()调用 能够继续处理这个Epoll事件 */ capacity -= count; if (capacity == 0) &#123; mPendingEventIndex -=1; break; &#125; &#125; &#125; else if (eventItem.events &amp; EPOLLHUP) &#123; deviceChanged = true; // 如果设备节点的文件描述符被挂起则卸载此设备 closeDeviceLocked(device); &#125; else &#123; ...... &#125; &#125; ...... // 读取并处理INotify事件 ......// 等待新的Epoll事件&#125;return event – buffer；&#125; getEvents()通过Epoll事件的data.u32字段在mDevices列表中查找已加载的设备，并从设备的文件描述符中读取原始输入事件列表。从文件描述符中读取的原始输入事件存储在input_event结构体中，这个结构体的四个字段存储了事件的事件戳、类型、代码与值四个元素。然后逐一将input_event的数据转存到RawEvent中并保存至buffer以返回给调用者。 注意为了叙述简单，上述代码使用了调用getEvents()的时间作为输入事件的时间戳。由于调用getEvents()函数的时机与用户操作的时间差的存在，会使得此时间戳与事件的真实时间有所偏差。从设备节点中读取的input_event中也包含了一个时间戳，这个时间戳消除了getEvents()调用所带来的时间差，因此可以获得更精确的时间控制。可以通过打开HAVE_POSIX_CLOCKS宏以使用input_event中的时间而不是将getEvents()调用的时间作为输入事件的时间戳。 需要注意的是，由于Epoll事件的处理优先级低于设备增删事件，因此当发生设备加载与卸载动作时，不会产生设备输入事件。另外还需注意，在一个监听周期中，getEvents()在将一个设备节点中的所有原始输入事件读取完毕之前，不会读取其他设备节点中的事件。 5、EventHub总结本节针对EventHub的设备管理与原始输入事件的监听读取两个核心内容介绍了EventHub的工作原理。EventHub作为直接操作设备节点的输入系统组件，隐藏了INotify与Epoll以及设备节点读取等底层操作，通过一个简单的接口getEvents()向使用者提供抽取设备事件与原始输入事件的功能。EventHub的核心功能都在getEvents()函数中完成，因此深入理解getEvents()的工作原理对于深入理解EventHub至关重要。 getEvents()函数的本质是通过epoll_wait()获取Epoll事件到事件池，并对事件池中的事件进行消费的过程。从epoll_wait()的调用开始到事件池中最后一个事件被消费完毕的过程称之为EventHub的一个监听周期。由于buffer参数的尺寸限制，一个监听周期可能包含多个getEvents()调用。周期中的第一个getEvents()调用一定会因事件池的枯竭而直接进行epoll_wait()，而周期中的最后一个getEvents()一定会将事件池中的最后一条事件消费完毕并将事件返回给调用者。前文所讨论的事件优先级都是在同一个监听周期内而言的。 在本节中出现了很多种事件，有原始输入事件、设备增删事件、Epoll事件、INotify事件等，存储事件的结构体有RawEvent、epoll_event、inotify_event、input_event等。图5-6可以帮助读者理清这些事件之间的关系。 图 5-6 EventHub的事件关联 另外，getEvents()函数返回的事件列表依照事件的优先级拥有特定的顺序。并且在一个监听周期中，同一输入设备的输入事件在列表中是相邻的。 至此，相信读者对EventHub的工作原理，以及EventHub的事件监听与读取机制有了深入的了解。接下来的内容将讨论EventHub所提供的原始输入事件如何被加工为Android输入事件，这个加工者就是Reader子系统中的另一员大将：InputReader。 五、Input Reader根据第四节的分析。输入设备扫描完成，并加入epoll中，监听事件。从前面的getEvents函数分析得知，当按键事件发生后，getEvents函数返回。这里再贴一下Input 处理时间流程图，然后按步骤详细分析。 以一次键盘按键为例，得到下面的6个事件 123456EventHub: /dev/input/event2 got: time=4383.680195, type=4, code=4, value=458792EventHub: /dev/input/event2 got: time=4383.680195, type=1, code=28, value=1EventHub: /dev/input/event2 got: time=4383.680195, type=0, code=0, value=0EventHub: /dev/input/event2 got: time=4383.760186, type=4, code=4, value=458792EventHub: /dev/input/event2 got: time=4383.760186, type=1, code=28, value=0EventHub: /dev/input/event2 got: time=4383.760186, type=0, code=0, value=0 上面的type是linux的输入系统里的事件，具体的值可以查看 查看input.h 123456789101112131415/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define EV_SYN 0x00 同步事件#define EV_KEY 0x01 按键事件#define EV_REL 0x02 相对坐标#define EV_ABS 0x03 绝对坐标/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define EV_MSC 0x04 其它#define EV_SW 0x05 #define EV_LED 0x11 LED#define EV_SND 0x12 声音/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define EV_REP 0x14 Repeat#define EV_FF 0x15 力反馈 #define EV_PWR 0x16 电源#define EV_FF_STATUS 0x17 状态 上面6个事件，只有两个type为1的事件，是我们需要处理的按键事件，一个down，一个up Step 1、 InputReader::loopOnce()返回到InputReader的loopOnce函数 1234567891011121314[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]void InputReader::loopOnce() &#123; size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE); &#123; // acquire lock AutoMutex _l(mLock); mReaderIsAliveCondition.broadcast(); //当有按键事件发生时，count将不为0，以一次按键为例，这里应该是6个事件 if (count) &#123; processEventsLocked(mEventBuffer, count); &#125; &#125; // release lock &#125; 当有按键事件发生时，count将不为0，之后会调用processEventsLocked来处理RawEvent。 Step 2、InputReader.processEventsLocked()123456789101112131415[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]void InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) &#123; for (const RawEvent* rawEvent = rawEvents; count;) &#123; int32_t type = rawEvent-&gt;type; size_t batchSize = 1; if (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123; int32_t deviceId = rawEvent-&gt;deviceId; //依次处理rawEvent processEventsForDeviceLocked(deviceId, rawEvent, batchSize); &#125; count -= batchSize; rawEvent += batchSize; &#125;&#125; 该函数调用processEventsForDeviceLocked依次处理rawEvent Step 3、InputReader.processEventsForDeviceLocked()123456789[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]void InputReader::processEventsForDeviceLocked(int32_t deviceId, const RawEvent* rawEvents, size_t count) &#123; ssize_t deviceIndex = mDevices.indexOfKey(deviceId); InputDevice* device = mDevices.valueAt(deviceIndex); //调用InputDevice的process函数 device-&gt;process(rawEvents, count);&#125; 这里根据deviceId获取到InputDevice，然后调用InputDevice的process函数 Step 4、InputDevice.process()1234567891011121314151617181920[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]void InputDevice::process(const RawEvent* rawEvents, size_t count) &#123;size_t numMappers = mMappers.size();for (const RawEvent* rawEvent = rawEvents; count--; rawEvent++) &#123; if (mDropUntilNextSync) &#123; if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123; &#125; else if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123; &#125; else &#123; for (size_t i = 0; i &lt; numMappers; i++) &#123; InputMapper* mapper = mMappers[i]; // InputMapper是做什么的呢，它是用于解析原始输入事件的。比如back, home等VirtualKey， // 传上来时是个Touch事件，这里要根据坐标转化为相应的按键事件。再比如多点触摸时，需要计算 // 每个触摸点分别属于哪条轨迹，安卓系统中每种输入设备都对应了一种Mapper,比如 // SwitchInputMapper, VibratorInputMapper,KeyBoardInputMapper mapper-&gt;process(rawEvent); &#125; &#125; &#125; &#125; 这里的mMappers成员变量保存了一系列输入设备事件处理对象，例如负责处理键盘事件的KeyboardKeyMapper对象以及负责处理触摸屏事件的TouchInputMapper对象， 它们是在InputReader类的成员函数createDeviceLocked中创建的。这里查询每一个InputMapper对象是否要对当前发生的事件进行处理。由于发生的是键盘事件，真正会对该事件进行处理的只有KeyboardKeyMapper对象。 Step 5、KeyboardInputMapper.process()123456789101112131415161718192021222324252627282930313233343536373839[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]void KeyboardInputMapper::process(const RawEvent* rawEvent) &#123; switch (rawEvent-&gt;type) &#123; case EV_KEY: &#123; int32_t scanCode = rawEvent-&gt;code; int32_t usageCode = mCurrentHidUsage; mCurrentHidUsage = 0; if (isKeyboardOrGamepadKey(scanCode)) &#123; int32_t keyCode; uint32_t flags; // 调用EventHub中的mapKey函数进行转化 // 传入参数 // scanCode：驱动程序上报的扫描码；keyCode：转化之后的Android使用的按键值 if (getEventHub()-&gt;mapKey(getDeviceId(), scanCode, usageCode, &amp;keyCode, &amp;flags)) &#123; keyCode = AKEYCODE_UNKNOWN; flags = 0; &#125; //映射成功之后，处理该按键 processKey(rawEvent-&gt;when, rawEvent-&gt;value != 0, keyCode, scanCode, flags); &#125; break; &#125; case EV_MSC: &#123; if (rawEvent-&gt;code == MSC_SCAN) &#123; mCurrentHidUsage = rawEvent-&gt;value; &#125; break; &#125; case EV_SYN: &#123; if (rawEvent-&gt;code == SYN_REPORT) &#123; mCurrentHidUsage = 0; &#125; &#125; &#125;&#125; 函数首先调用isKeyboardOrGamepadKey来判断键盘扫描码是否正确，如果正确则调用processKey来进一步处理 Step 6、KeyboardInputMapper.processKey()123456789101112131415[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]void KeyboardInputMapper::processKey(nsecs_t when, bool down, int32_t keyCode, int32_t scanCode, uint32_t policyFlags) &#123; // 根据扫描码scanCode、按键码keyCode、newMetaState、downTime按下的时间进行处理 // NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags, ...... NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags, down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP, AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, newMetaState, downTime); // 通知Listener处理，Dispatch线程会监听该事件，并处理，下次博文会具体分析 getListener()-&gt;notifyKey(&amp;args);&#125; 这个函数首先对按键作一些处理，根据扫描码scanCode、按键码keyCode、newMetaState、downTime按下的时间进行处理 最后函数会调用： 12345NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags, down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP, AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, newMetaState, downTime); getListener()-&gt;notifyKey(&amp;args); 这里getListener是InputReader初始化时传入的对象，即QueuedInputListener，则会调用QueuedInputListener的notifyKey函数 123void QueuedInputListener::notifyKey(const NotifyKeyArgs* args) &#123;mArgsQueue.push(new NotifyKeyArgs(*args));&#125; InputReader的loopOnce()的结尾会调用QueuedInputListener::flush()统一回调缓冲队列中各元素的notify()接口： 123456789void QueuedInputListener::flush() &#123;size_t count = mArgsQueue.size();for (size_t i = 0; i &lt; count; i++) &#123; NotifyArgs* args = mArgsQueue[i]; args-&gt;notify(mInnerListener); delete args;&#125;mArgsQueue.clear();&#125; 进一步调用： 123void NotifyConfigurationChangedArgs::notify(const sp&lt;InputListenerInterface&gt;&amp; listener) const &#123;listener-&gt;notifyConfigurationChanged(this);&#125; 以按键事件为例，由于InputDispatcher 实现了InputListenerInterface接口的notifyConfigurationChanged()函数，所以最后会调用到InputDispatcher的notifyKey()函数中。 Step 7、 InputDispatcher.notifyKey()12345678910111213141516171819202122232425262728293031[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::notifyKey(const NotifyKeyArgs* args) &#123;......// 构造一个KeyEvent对象KeyEvent event;event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action, flags, keyCode, args-&gt;scanCode, metaState, 0, args-&gt;downTime, args-&gt;eventTime);// 调用mPolicy的interceptKeyBeforeQueueing函数，该函数最后会调用到java层的PhoneWindowManagerService函数mPolicy-&gt;interceptKeyBeforeQueueing(&amp;event, /*byref*/ policyFlags);bool needWake;&#123; // acquire lock mLock.lock(); ...... //构造一个KeyEntry对象，调用enqueueInboundEventLocked函数将按键事件加入队列 KeyEntry* newEntry = new KeyEntry(args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, policyFlags, args-&gt;action, flags, keyCode, args-&gt;scanCode, metaState, repeatCount, args-&gt;downTime); needWake = enqueueInboundEventLocked(newEntry); mLock.unlock();&#125; // release lockif (needWake) &#123; mLooper-&gt;wake();&#125;&#125; 该函数首先调用validateKeyEvent来判断是否是有效按键事件，实际判断是否是UP/DOWN事件 然后构造一个KeyEvent对象，调用mPolicy的interceptKeyBeforeQueueing函数，该函数最后会调用到java层的PhoneWindowManagerService函数 123456KeyEvent event; event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action, flags, keyCode, args-&gt;scanCode, metaState, 0, args-&gt;downTime, args-&gt;eventTime); mPolicy-&gt;interceptKeyBeforeQueueing(&amp;event, /*byref*/ policyFlags); 之后会调用构造一个KeyEntry对象，调用enqueueInboundEventLocked函数将按键事件加入队列，如果返回true，则调用mLooper.wake函数唤醒等待的InputDispatcher，进行按键分发。 123456KeyEntry* newEntry = new KeyEntry(args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, policyFlags, args-&gt;action, flags, keyCode, args-&gt;scanCode, metaState, repeatCount, args-&gt;downTime);needWake = enqueueInboundEventLocked(newEntry); Step 8、InputDispatcher.enqueueInboundEventLocked()123456789101112131415161718192021222324252627[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]bool InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123; bool needWake = mInboundQueue.isEmpty(); mInboundQueue.enqueueAtTail(entry); traceInboundQueueLengthLocked(); switch (entry-&gt;type) &#123; case EventEntry::TYPE_KEY: &#123; // ...... KeyEntry* keyEntry = static_cast&lt;KeyEntry*&gt;(entry); if (isAppSwitchKeyEventLocked(keyEntry)) &#123; if (keyEntry-&gt;action == AKEY_EVENT_ACTION_DOWN) &#123; mAppSwitchSawKeyDown = true; &#125; else if (keyEntry-&gt;action == AKEY_EVENT_ACTION_UP) &#123; if (mAppSwitchSawKeyDown) &#123; mAppSwitchDueTime = keyEntry-&gt;eventTime + APP_SWITCH_TIMEOUT; mAppSwitchSawKeyDown = false; needWake = true; &#125; &#125; &#125; break; &#125; &#125; return needWake;&#125; 将EventEntry加入到mInboundQueue中，该函数两种情况下会返回true,一是当加入该键盘事件到mInboundQueue之前，mInboundQueue为空，这表示InputDispatc herThread线程正在睡眠等待InputReaderThread线程的唤醒，因此，它返回true表示要唤醒InputDispatccherThread线程；二是加入该键盘事件到mInboundQueue之前，mInboundQueue不为空，但是此时用户按下的是Home键等需要切换APP的按键，我们知道，在切换App时，新的App会把它的键盘消息接收通道注册到InputDispatcher中去，并且会等待InputReader的唤醒，因此，在这种情况下，也需要返回true，表示要唤醒InputDispatccherThread线程。如果不是这两种情况，那么就说明InputDispatccherThread线程现在正在处理前面的键盘事件，不需要唤醒它。 至此，InputDispatcherThread被唤醒，开始进行按键分发。 总结：InputReaderThread不断调用InputReader的pollOnce()-&gt;getEvents()函数来得到事件，这些事件可以是输入事件，也可以是由inotify监测到设备增减变更所触发的事件。第一次进入时会扫描/dev/input目录建立设备列表，存在mDevice成员变量中(EventHub中有设备列表KeyedVector mDevices；对应的，InputReader中也有设备列表KeyedVector mDevices。这里先添加到前者，然后会在InputReader::addDeviceLocked()中添加到后者。)，同时将增加的fd加到epoll的等待集合中。在接下来的epoll_wait()等待时，如果有事件就会返回，同时返回可读事件数量。在这里，从Input driver读出的事件从原始的input_event结构转为RawEvent结构，放到getEvents()的输出参数buffer中。getEvents()返回后，InputReader调用processEventsLocked()处理事件，对于设备改变，会根据实际情况调用addDeviceLocked(), removeDeviceLocked()和handleConfigurationChangedLocked()。对于其它设备中来的输入事件，会调用processEventsForDeviceLocked()进一步处理。其中会根据当时注册的InputMapper对事件进行处理，然后将事件处理请求放入缓冲队列（QueuedInputListener中的mArgsQueue）。 InputMapper是做什么的呢，它是用于解析原始输入事件的。比如back, home等VirtualKey，传上来时是个Touch事件，这里要根据坐标转化为相应的按键事件。再比如多点触摸时，需要计算每个触摸点分别属于哪条轨迹，这本质上是个二分图匹配问题，这也是在InputMapper中完成的。回到流程主线上，在InputReader的loopOnce()的结尾会调用QueuedInputListener::flush()统一回调缓冲队列中各元素的notify()接口。 以按键事件为例，最后会调用到InputDispatcher的notifyKey()函数中。这里先将参数封装成KeyEvent：然后把它作为参数调用NativeInputManager的interceptKeyBeforeQueueing()函数。顾名思义，就是在放到待处理队列前看看是不是需要系统处理的系统按键，它会通过JNI调回Java世界，最终调到PhoneWindowManager的interceptKeyBeforeQueueing()。然后，基于输入事件信息创建KeyEntry对象，调用enqueueInboundEventLocked()将之放入队列等待InputDiaptcherThread线程拿出处理。 六、Input DispatcherInputDisptacher的主要任务是把前面收到的输入事件发送到PWM及App端的焦点窗口。前面提到InputReaderThread中收到事件后会调用notifyKey()来通知InputDispatcher，也就是放在mInboundQueue中，在InputDispatcher的dispatchOnce()函数中，会从这个队列拿出处理。 其中dispatchOnceInnerLocked()会根据拿出的EventEntry类型调用相应的处理函数，以Key事件为例会调用dispatchKeyLocked() 它会找到目标窗口，然后通过之前和App间建立的连接发送事件。如果是个需要系统处理的Key事件，这里会封装成CommandEntry插入到mCommandQueue队列中，后面的runCommandLockedInterruptible()函数中会调用doInterceptKeyBeforeDispatchingLockedInterruptible()来让PWM有机会进行处理。最后dispatchOnce()调用pollOnce()从和App的连接上接收处理完成消息。那么，InputDispatcher是怎么确定要往哪个窗口中发事件呢？这里的成员变量mFocusedWindowHandle指示了焦点窗口，然后findFocusedWindowTargetsLocked()会调用一系列函数（handleTargetsNotReadyLocked(), checkInjectionPermission(), checkWindowReadyForMoreInputLocked()等）检查mFocusedWindowHandle是否能接收输入事件。如果可以，将之以InputTarget的形式加到目标窗口数组中。然后就会调用dispatchEventLocked()进行发送。那么，这个mFocusedWindowHandle是如何维护的呢？为了更好地理解，这里回头分析下窗口连接的管理及焦点窗口的管理。总体流程图： 再贴一张详细的总体流程图，然后根据步骤详细分析； Step 1、InputDispatcher.dispatchOnce()1234567891011121314151617181920212223242526[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::dispatchOnce() &#123;nsecs_t nextWakeupTime = LONG_LONG_MAX;&#123; // acquire lock AutoMutex _l(mLock); mDispatcherIsAliveCondition.broadcast(); // Run a dispatch loop if there are no pending commands. // The dispatch loop might enqueue commands to run afterwards. if (!haveCommandsLocked()) &#123; dispatchOnceInnerLocked(&amp;nextWakeupTime); &#125; // Run all pending commands if there are any. // If any commands were run then force the next poll to wake up immediately. if (runCommandsLockedInterruptible()) &#123; nextWakeupTime = LONG_LONG_MIN; &#125;&#125; // release lock// Wait for callback or timeout or wake. (make sure we round up, not down)nsecs_t currentTime = now();int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);mLooper-&gt;pollOnce(timeoutMillis);&#125; 上述函数主要是调用dispatchOnceInnerLocked来进行一次按键分发，当没有按键消息时会走到mLooper-&gt;pollOnce(timeoutMillis);这个函数会进入睡眠状态，当有按键消息发生时该函数会返回，然后走到dispatchOnceInnerLocked函数。 Step 2、InputDispatcher.dispatchOnceInnerLocked()1234567891011121314151617181920212223242526272829303132333435363738394041[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123; nsecs_t currentTime = now(); ... // Ready to start a new event. // If we don't already have a pending event, go grab one. if (! mPendingEvent) &#123; //当InputReader往队列中插入了一个读取的键盘消息后，此处的mInboundQueue就不为空 if (mInboundQueue.isEmpty()) &#123; ... &#125; else &#123; // Inbound queue has at least one entry. mPendingEvent = mInboundQueue.dequeueAtHead(); ... &#125; ... &#125; ... switch (mPendingEvent-&gt;type) &#123; ... case EventEntry::TYPE_KEY: &#123; KeyEntry* typedEntry = static_cast&lt;KeyEntry*&gt;(mPendingEvent); ... done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime); break; &#125; ... &#125; if (done) &#123; if (dropReason != DROP_REASON_NOT_DROPPED) &#123; dropInboundEventLocked(mPendingEvent, dropReason); &#125; mLastDropReason = dropReason; releasePendingEventLocked(); *nextWakeupTime = LONG_LONG_MIN; // force next poll to wake up immediately &#125;&#125; 从前文InputReader读取键盘消息过程分析 InputReader读取到一个消息后会调用KeyboardInputMapper的processKey，该函数会调用InputDispatcher的notifyKey函数，然后InputDispatcher会调用enqueueInboundEventLocked函数，将EventEntry加入到mInboundQueue中，然后调用mLooper-&gt;wake函数会唤醒InputDispatcherThread线程，InputDispatcher中把队列的第一个事件取出来，因为这里是键盘事件，所以mPendingEvent-&gt;type是EventEntry::TYPE_KEY，然后调用dispatchKeyLocked函数 惯例先贴出序列图，按步骤一步步介绍。 Step 3、InputDispatcher.dispatchKeyLocked()12345678910111213141516171819202122232425262728293031[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp ]bool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, KeyEntry* entry, DropReason* dropReason, nsecs_t* nextWakeupTime) &#123; ... // Give the policy a chance to intercept the key. if (entry-&gt;interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN) &#123; if (entry-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123; CommandEntry* commandEntry = postCommandLocked( &amp; InputDispatcher::doInterceptKeyBeforeDispatchingLockedInterruptible); if (mFocusedWindowHandle != NULL) &#123; commandEntry-&gt;inputWindowHandle = mFocusedWindowHandle; &#125; ...... &#125; else &#123; entry-&gt;interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_CONTINUE; &#125; &#125; ...... // Identify targets. Vector&lt;InputTarget&gt; inputTargets; int32_t injectionResult = findFocusedWindowTargetsLocked(currentTime, entry, inputTargets, nextWakeupTime); ...... setInjectionResultLocked(entry, injectionResult); ...... addMonitoringTargetsLocked(inputTargets); // Dispatch the key. dispatchEventLocked(currentTime, entry, inputTargets); return true;&#125; 这个函数主要做了下面三件事A. 如果按键是第一次分发，则将命令封装为CommandEntry加入队列，后续执行doInterceptKeyBeforeDispatchingLockedInterruptible，以给java层拦截按键的机会B. 找到当前激活的Window窗口，并将其加入到Vector中，Android ANR就是在findFocusedWindowTargetsLocked()检测的C. 找到需要主动监听按键的InputChannel,封装成InputTarget，加入到Vector中D. 将按键分发到上面的Vector中的InputChannel中，这里存在多个 下面先分析如果将按键分发给InputChannel 123456789101112131415[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::dispatchEventLocked(nsecs_t currentTime, EventEntry* eventEntry, const Vector&lt;InputTarget&gt;&amp; inputTargets) &#123;......for (size_t i = 0; i &lt; inputTargets.size(); i++) &#123; const InputTarget&amp; inputTarget = inputTargets.itemAt(i); ssize_t connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel); if (connectionIndex &gt;= 0) &#123; sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex); prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget); &#125; ...... &#125; &#125;&#125; Step 5、InputDispatcher.prepareDispatchCycleLocked()12345678[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget) &#123; ... // Not splitting. Enqueue dispatch entries for the event as is. enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget); &#125; 函数前面还有一些状态检查，这里默认都是通过的。最后enqueueDispatchEntriesLocked函数进行将connection分装成DispatchEntry，加入到connection-&gt;outboundQueue的队列中 Step 6. InputDispatcher::enqueueDispatchEntriesLocked()123456789101112131415161718[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::enqueueDispatchEntriesLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget) &#123; bool wasEmpty = connection-&gt;outboundQueue.isEmpty(); // Enqueue dispatch entries for the requested modes. enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT); ...... enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER); // If the outbound queue was previously empty, start the dispatch cycle going. if (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123; startDispatchCycleLocked(currentTime, connection); &#125;&#125; 这个函数首先获取以前的connection的outboundQueue是否为空，然后将该事件调用enqueueDispatchEntryLocked将事件加入到outboundQueue中，如果以前为空，现在不为空，则调用startDispatchCycleLocked开始分发，如果以前的outboundQueue不为空，说明当前的Activity正在处理前面的按键，则不需要再调用startDispatchCycleLocked，因为只要开始处理，会等到队列为空才会停止。 Step 7、InputDispatcher.startDispatchCycleLocked()12345678910111213141516171819202122232425262728293031323334353637[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection) &#123; while (connection-&gt;status == Connection::STATUS_NORMAL &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123; DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head; dispatchEntry-&gt;deliveryTime = currentTime; // Publish the event. status_t status; EventEntry* eventEntry = dispatchEntry-&gt;eventEntry; switch (eventEntry-&gt;type) &#123; case EventEntry::TYPE_KEY: &#123; KeyEntry* keyEntry = static_cast&lt;KeyEntry*&gt;(eventEntry); // Publish the key event. status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq, keyEntry-&gt;deviceId, keyEntry-&gt;source, dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags, keyEntry-&gt;keyCode, keyEntry-&gt;scanCode, keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime, keyEntry-&gt;eventTime); break; &#125; ...... &#125; ...... // Re-enqueue the event on the wait queue. connection-&gt;outboundQueue.dequeue(dispatchEntry); traceOutboundQueueLengthLocked(connection); connection-&gt;waitQueue.enqueueAtTail(dispatchEntry); traceWaitQueueLengthLocked(connection); &#125;//end of while&#125; 该函数从outboundQueue中取出需要处理的键盘事件，交给connection的inputPublisher去分发，之后将事件加入到connection的waitQueue中。分发事件是通过InputPublisher的publishKeyEvent来完成的。 Step 8、InputPublisher.publishKeyEvent123456789101112131415[-&gt;frameworks/native/libs/input/InputTransport.cpp]status_t InputPublisher::publishKeyEvent( uint32_t seq,int32_t deviceId,int32_t source, int32_t action,int32_t flags,int32_t keyCode, int32_t scanCode,int32_t metaState,int32_t repeatCount, nsecs_t downTime,nsecs_t eventTime) &#123; InputMessage msg; msg.header.type = InputMessage::TYPE_KEY; ...... msg.body.key.eventTime = eventTime; return mChannel-&gt;sendMessage(&amp;msg);&#125; 该函数主要是将各个参数封装到InputMessage中，然后交给mChannel对象去分发mChannel其实是socketpair的server端，其实就是创建的服务器InputChannel，其创建过程稍后详细分析。 Step 9、InputChannel.sendMessage()12345678910[-&gt;frameworks/native/libs/input/InputTransport.cpp]status_t InputChannel::sendMessage(const InputMessage* msg) &#123; size_t msgLength = msg-&gt;size(); ssize_t nWrite; do &#123; nWrite = ::send(mFd, msg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL); &#125; while (nWrite == -1 &amp;&amp; errno == EINTR); return OK;&#125; 该函数主要是通过send函数往socketpair的server端写入InputMessage对象，应用程序这一侧正睡眠在client端的fd上，此时client端就会收到该InputMessage，client会进行按键按键分发，应用程序这一侧的按键分发请看下一节。 七、App注册消息监听过程分析总体流程图InputDispatcher会找到目标窗口，然后通过之前和App间建立的连接发送事件。如果是个需要系统处理的Key事件，这里会封装成CommandEntry插入到mCommandQueue队列中，后面的runCommandLockedInterruptible()函数中会调用doInterceptKeyBeforeDispatchingLockedInterruptible()来让PWM有机会进行处理。最后dispatchOnce()调用pollOnce()从和App的连接上接收处理完成消息。那么，InputDispatcher是怎么确定要往哪个窗口中发事件呢？这里的成员变量mFocusedWindowHandle指示了焦点窗口，然后findFocusedWindowTargetsLocked()会调用一系列函数（handleTargetsNotReadyLocked(), checkInjectionPermission(), checkWindowReadyForMoreInputLocked()等）检查mFocusedWindowHandle是否能接收输入事件。如果可以，将之以InputTarget的形式加到目标窗口数组中。然后就会调用dispatchEventLocked()进行发送。那么，这个mFocusedWindowHandle是如何维护的呢？为了更好地理解，这里回头分析下窗口连接的管理及焦点窗口的管理。在App端，新的顶层窗口需要被注册到WMS中，这是在ViewRootImpl::setView()中做的。 Step 1、ViewRootImpl.setView()1234567891011121314151617181920212223242526272829303132333435[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; // 调用requestLayout来通知InputManagerService当前的窗口是激活的窗口 requestLayout(); if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; // 如果该窗口没有指定INPUT_FEATURE_NO_INPUT_CHANNEL属性，则创建消息接收通道InputChannel mInputChannel = new InputChannel(); &#125; try &#123; // 通过binder调用，调用server端的Session对象来跟WindowManagerService通信，该函数最后会调 // 用到WindowManagerService的addWindow函数，函数中会创建一对InputChannel(server/client)， // 这样在函数调用结束后，mInputChannel就变成了client端的对象。在 // frameworks/base/core/java/android/view/IWindowSession.aidl的 // addToDisplay函数的声明中，InputChannel指定的数据流的流向是out，因此 // WindowManagerService修改了mInputChannel,客户端就能拿到这个对象的数据了。 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; catch (Exception e) &#123; ... &#125; if (mInputChannel != null) &#123; if (mInputQueueCallback != null) &#123; mInputQueue = new InputQueue(); mInputQueueCallback.onInputQueueCreated(mInputQueue); // 初始化WindowInputEventReceiver，按键消息会从native层传到该对象的onInputEvent函数 // 中，onInputEvent函数是按键在应用端java层分发的起始端。 mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); &#125; &#125;&#125; 这个函数与注册键盘消息通道的相关主要有三个功能：一是调用requestLayout函数来通知InputManagerService，这个Activity窗口是当前被激活的窗口,同时将所有的窗口注册到InputDispatcher中二是调用mWindowSession的add成员函数来把键盘消息接收通道的server端注册端注册到CPP层的InputManagerService中，client端注册到本应用程序的消息循环Looper中，这样当InputManagerService监控到有键盘消息的时候，就会找到当前被激活的窗口，然后找到其在InputManagerService中对应的键盘消息接收通道(InputChannel)，通过这个通道在InputManagerService的server端来通知应用程序消息循环的client端，这样就把键盘消息分发给当前激活的Activity窗口了三是应用程序这一侧注册消息接收通道 Step 2、ViewRootImpl.requestLayout()12345678910[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125; &#125; 这里调用了scheduleTraversals函数来做进一步的操作，该函数调用mChoreographer来post一个Runnable到Looper中，之后Vsycn信号到来会执行mTraversalRunnable中的run方法，即调用doTraversal函数 参考文档：【Android 7.1.2(Android N) Activity-Window加载显示流程】 Step 3、ViewRootImpl.doTraversal()123456789[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); performTraversals(); &#125;&#125; 该函数主要是执行performTraversals()函数，进而调用relayoutWindow函数，在该函数中又会调用mWindowSession的relayout进入到java层的WindowManagerService的relayoutWindow函数，该函数会调用mInputMonitor.updateInputWindowsLw(true /force/);mInputMonitor是InputMonitor对象。 Step 4、InputMonitor.updateInputWindowsLw()123456789101112131415161718192021[-&gt;frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java]public void updateInputWindowsLw(boolean force) &#123;boolean addInputConsumerHandle = mService.mInputConsumer != null;// Add all windows on the default display.final int numDisplays = mService.mDisplayContents.size();for (int displayNdx = 0; displayNdx &lt; numDisplays; ++displayNdx) &#123; WindowList windows = mService.mDisplayContents.valueAt(displayNdx).getWindowList(); for (int winNdx = windows.size() - 1; winNdx &gt;= 0; --winNdx) &#123; final WindowState child = windows.get(winNdx); final InputChannel inputChannel = child.mInputChannel; final InputWindowHandle inputWindowHandle = child.mInputWindowHandle; ...... addInputWindowHandleLw(inputWindowHandle, child, flags, type, isVisible, hasFocus, hasWallpaper); &#125;&#125;// Send windows to native code.mService.mInputManager.setInputWindows(mInputWindowHandles);&#125; 这个函数将当前系统中带有InputChannel的Activity窗口都设置为InputManagerService的输入窗口，但是后面我们会看到，只有当前激活的窗口才会响应键盘消息。 Step 5、InputManagerService.setInputWindows()12345[-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java]public void setInputWindows(InputWindowHandle[] windowHandles) &#123; nativeSetInputWindows(mPtr, windowHandles);&#125; 这个函数调用了本地方法nativeSetInputWindows来进一步执行操作,mPtr是native层NativeInputManager实例，在调用InputManagerService.nativeInit函数时会在native层构造NativeInputManager对象并将其保存在mPtr中。nativeSetInputWindows会调用NativeInputManager的setInputWindows函数 Step 6、NativeInputManager.setInputWindows()12345678910111213141516171819202122232425262728293031[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]void NativeInputManager::setInputWindows(JNIEnv* env, jobjectArray windowHandleObjArray) &#123; Vector&lt;sp&lt;InputWindowHandle&gt; &gt; windowHandles; if (windowHandleObjArray) &#123; jsize length = env-&gt;GetArrayLength(windowHandleObjArray); for (jsize i = 0; i &lt; length; i++) &#123; jobject windowHandleObj = env-&gt;GetObjectArrayElement(windowHandleObjArray, i); ...... sp&lt;InputWindowHandle&gt; windowHandle = android_server_InputWindowHandle_getHandle(env, windowHandleObj); if (windowHandle != NULL) &#123; windowHandles.push(windowHandle); &#125; env-&gt;DeleteLocalRef(windowHandleObj); &#125; &#125; mInputManager-&gt;getDispatcher()-&gt;setInputWindows(windowHandles); // Do this after the dispatcher has updated the window handle state. bool newPointerGesturesEnabled = true; size_t numWindows = windowHandles.size(); for (size_t i = 0; i &lt; numWindows; i++) &#123; const sp&lt;InputWindowHandle&gt;&amp; windowHandle = windowHandles.itemAt(i); const InputWindowInfo* windowInfo = windowHandle-&gt;getInfo(); if (windowInfo &amp;&amp; windowInfo-&gt;hasFocus &amp;&amp; (windowInfo-&gt;inputFeatures &amp; InputWindowInfo::INPUT_FEATURE_DISABLE_TOUCH_PAD_GESTURES)) &#123; newPointerGesturesEnabled = false; &#125; &#125;&#125; 这个函数首先将Java层的InputWindowHandle转换成C++层的NativeInputWindowHandle，然后放在windowHandles向量中，最后将这些输入窗口设置到InputDispatcher中去。 Step 7、InputDispatcher.setInputWindows()123456789101112131415161718192021222324252627282930[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::setInputWindows(const Vector&lt;sp&lt;InputWindowHandle&gt; &gt;&amp; inputWindowHandles) &#123; &#123; // acquire lock AutoMutex _l(mLock); Vector&lt;sp&lt;InputWindowHandle&gt; &gt; oldWindowHandles = mWindowHandles; mWindowHandles = inputWindowHandles; sp&lt;InputWindowHandle&gt; newFocusedWindowHandle; bool foundHoveredWindow = false; for (size_t i = 0; i &lt; mWindowHandles.size(); i++) &#123; const sp&lt;InputWindowHandle&gt;&amp; windowHandle = mWindowHandles.itemAt(i); if (!windowHandle-&gt;updateInfo() || windowHandle-&gt;getInputChannel() == NULL) &#123; mWindowHandles.removeAt(i--); continue; &#125; if (windowHandle-&gt;getInfo()-&gt;hasFocus) &#123; newFocusedWindowHandle = windowHandle; &#125; &#125; if (mFocusedWindowHandle != newFocusedWindowHandle) &#123; mFocusedWindowHandle = newFocusedWindowHandle; &#125; &#125; // release lock // Wake up poll loop since it may need to make new input dispatching choices. mLooper-&gt;wake();&#125; 这里InputDispatcher的成员变量mFocusedWindowHandle 就代表当前激活的窗口的。这个函数遍历inputWindowHandles，获取获得焦点的窗口，并赋值给mFocusedWindowHandle 这样，InputManagerService就把当前激活的窗口保存在InputDispatcher中了，后面就可以把键盘消息分发给它来处理。 Step 8、mWindowSession.addToDisplay()123456789101112if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; mInputChannel = new InputChannel(); &#125; try &#123; res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; catch (Exception e) &#123; ... &#125; 这里会调用到WindowManagerService的addWindow接口 1234567891011121314frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.javapublic int addWindow(Session session, IWindow client, int seq,WindowManager.LayoutParams attrs, int viewVisibility, int displayId,Rect outContentInsets, Rect outStableInsets, Rect outOutsets,InputChannel outInputChannel) &#123; ...... final boolean openInputChannels = (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0); if (openInputChannels) &#123; win.openInputChannel(outInputChannel); &#125; ...... &#125; 接着会调用WindowState的 openInputChannel()方法。 123456789101112131415161718192021frameworks/base/services/core/java/com/android/server/wm/WindowState.java void openInputChannel(InputChannel outInputChannel) &#123; String name = makeInputChannelName(); InputChannel[] inputChannels = InputChannel.openInputChannelPair(name); mInputChannel = inputChannels[0]; mClientChannel = inputChannels[1]; mInputWindowHandle.inputChannel = inputChannels[0]; if (outInputChannel != null) &#123; mClientChannel.transferTo(outInputChannel); mClientChannel.dispose(); mClientChannel = null; &#125; else &#123; // If the window died visible, we setup a dummy input channel, so that taps // can still detected by input monitor channel, and we can relaunch the app. // Create dummy event receiver that simply reports all events as handled. mDeadWindowEventReceiver = new DeadWindowEventReceiver(mClientChannel); &#125; mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);&#125; 这里的outInputChannel即为前面创建的InputChannel，它不为NULL，因此，这里会通过InputChannel.openInputChannelPair函数来创建一对输入通道，其中一个位于WindowManagerService中，另外一个通过outInputChannel参数返回到应用程序中。 WindowManagerService会为每个窗口创建一个WindowState对象，然后将该InputChannel对的service端保存到WindowState中 Step 10、InputChannel.openInputChannelPair()12345[-&gt;frameworks/base/core/java/android/view/InputChannel.java]public static InputChannel[] openInputChannelPair(String name) &#123; return nativeOpenInputChannelPair(name);&#125; 调用了nativeOpenInputChannelPair函数，在native创建一个InputChannel对 Step 11、InputChannel.nativeOpenInputChannelPair()1234567891011121314[-&gt;frameworks/base/core/jni/android_view_InputChannel.cpp]static jobjectArray android_view_InputChannel_nativeOpenInputChannelPair(JNIEnv* env, jclass clazz, jstring nameObj) &#123; const char* nameChars = env-&gt;GetStringUTFChars(nameObj, NULL); String8 name(nameChars); env-&gt;ReleaseStringUTFChars(nameObj, nameChars); sp&lt;InputChannel&gt; serverChannel; sp&lt;InputChannel&gt; clientChannel; status_t result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel); ... return channelPair;&#125; nativeOpenInputChannelPair函数调用InputChannel的openInputChannelPair函数创建一对InputChannel,该对象是Native层的InputChannel,跟java层是一一对应的。 Step 12、InputChannel.openInputChannelPair()123456789101112131415161718192021222324252627282930[-&gt;frameworks/native/libs/input/InputTransport.cpp]status_t InputChannel::openInputChannelPair(const String8&amp; name, sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123; int sockets[2]; if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) &#123; status_t result = -errno; ALOGE(\"channel '%s' ~ Could not create socket pair. errno=%d\", name.string(), errno); outServerChannel.clear(); outClientChannel.clear(); return result; &#125; int bufferSize = SOCKET_BUFFER_SIZE; //设置server端和client端的接收缓冲区和发送缓冲区 setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize)); String8 serverChannelName = name; serverChannelName.append(\" (server)\"); outServerChannel = new InputChannel(serverChannelName, sockets[0]); String8 clientChannelName = name; clientChannelName.append(\" (client)\"); outClientChannel = new InputChannel(clientChannelName, sockets[1]); return OK; &#125; 这里调用了socketpair系统调用创建了一对已经连接的UNIX租socket,这里可以把这一对socket当成pipe返回的文件描述符一样使用，pipe返回的管道是单向管道，即只能从一端写入，一端读出，但是socketpair是创建的管道是全双工的，可读可写。 创建好了server端和client端socketpair通道后，在WindowState.openInputChannel()方法中，一方面它把刚才创建的Client端的输入通道通过outInputChannel参数返回到应用程序中： 1inputChannels[1].transferTo(outInputChannel); WindowSession.addToDisplay()通过Binder通信与WMS通信。IWindowSession.java为编译Android 7.1.2源码得到。在此看一下通信详细过程,可以看到outInputChannel通过_arg8.writeToParcel()写入，然后通过跨进程方式传输，App端就可以得到Client端的InputChannel 了。[-&gt;IWindowSession.java$ Stub] 12345678910111213141516 case TRANSACTION_addToDisplay:&#123;......android.view.InputChannel _arg8;_arg8 = new android.view.InputChannel();int _result = this.addToDisplay(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8);reply.writeNoException();reply.writeInt(_result);......if ((_arg8!=null)) &#123;reply.writeInt(1);_arg8.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);&#125;......return true;&#125; [-&gt;IWindowSession.java$ Proxy] 123456789101112131415//android/out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/view/IWindowSession.java@Override public int addToDisplay(android.view.IWindow window, int seq, android.view.WindowManager.LayoutParams attrs, int viewVisibility, int layerStackId, android.graphics.Rect outContentInsets, android.graphics.Rect outStableInsets, android.graphics.Rect outOutsets, android.view.InputChannel outInputChannel) throws android.os.RemoteException&#123;android.os.Parcel _data = android.os.Parcel.obtain();android.os.Parcel _reply = android.os.Parcel.obtain();......mRemote.transact(Stub.TRANSACTION_addToDisplay, _data, _reply, 0);_result = _reply.readInt();....if ((0!=_reply.readInt())) &#123;outInputChannel.readFromParcel(_reply);&#125;return _result;&#125; 另外还需要把server端的InputChannel注册到InputManagerService中： 1mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle); Step 13、InputManagerService.registerInputChannel()123456[-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java]public void registerInputChannel(InputChannel inputChannel, InputWindowHandle inputWindowHandle) &#123; nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, false); &#125; 通过调用nativeRegisterInputChannel来将InputChannel注册到native层 Step 14、InputManagerService.nativeRegisterInputChannel()123456789101112131415[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]static void nativeRegisterInputChannel(JNIEnv* env, jclass /* clazz */, jlong ptr, jobject inputChannelObj, jobject inputWindowHandleObj, jboolean monitor) &#123; NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr); sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj); sp&lt;InputWindowHandle&gt; inputWindowHandle = android_server_InputWindowHandle_getHandle(env, inputWindowHandleObj); status_t status = im-&gt;registerInputChannel( env, inputChannel, inputWindowHandle, monitor);&#125; 根据java层的InputWindowHandle获得native层的InputWindowHandle对象，根据java层的InputChannel获得native层的InputChannel对象，然后调用NativeInputManager的resgiterInputChannel，该函数又调用了InputDispatcher的registerInputChannel Step 15、InputDispatcher.registerInputChannel()1234567891011121314151617181920212223[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]status_t InputDispatcher::registerInputChannel(const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) &#123; &#123; // acquire lock AutoMutex _l(mLock); sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor); int fd = inputChannel-&gt;getFd(); mConnectionsByFd.add(fd, connection); if (monitor) &#123; mMonitoringChannels.push(inputChannel); &#125; mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this); &#125; // release lock // Wake the looper because some connections have changed. mLooper-&gt;wake(); return OK;&#125; 创建Connection，可以看到用inputChannel初始化了inputPublisher(inputChannel)，这就是之前Input dispatcher小节 Step 8. InputPublisher.publishKeyEvent()方法中的那个mChannel。 1234567// --- InputDispatcher::Connection ---InputDispatcher::Connection::Connection(const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) : status(STATUS_NORMAL), inputChannel(inputChannel), inputWindowHandle(inputWindowHandle), monitor(monitor), inputPublisher(inputChannel), inputPublisherBlocked(false) &#123; &#125; 将InputWindowHandle, InputChanel封装成Connection对象，然后fd作为key，Connection作为Value，保存在mConnectionsByFd中，如果传入的monitor是true，则需要将InputChannel放到mMonitoringChannels中,从上面的InputManagerService的registerInputChannel函数里传入的monitor是false，所以这里不加入到mMonitoringChannels。同时把fd加入到mLooper的监听中，并指定当该fd有内容可读时，Looper就会调用handleReceiveCallback函数。至此server端的InputChannel注册完成，InputDispatcher睡眠在监听的fds上，当有按键事件发生时，InputDispatcher就会往这些fd写入InputMessage对象，进而回调handleReceiveCallback函数。 至此，server端的InputChannel就注册完成了，再回到前面的WindowManagerService.addWindow上的第二步inputChannels[1].transferTo(outInputChannel);，这个是将创建的一对InputChannel的client端复制到传入的参数InputChannel上，当addWindow返回时，就回到ViewRootImpl.setView()方法中，执行应用程序这一侧的键盘消息接收通道。 1234if (mInputChannel != null) &#123; mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());&#125; WindowInputEventReceiver继承自InputEventReceiver类。 Step 16、InputEventReceiver()1234567891011[-&gt;frameworks/base/core/java/android/view/InputEventReceiver.java]public InputEventReceiver(InputChannel inputChannel, Looper looper) &#123; mInputChannel = inputChannel; mMessageQueue = looper.getQueue(); mReceiverPtr = nativeInit(new WeakReference&lt;InputEventReceiver&gt;(this), inputChannel, mMessageQueue); mCloseGuard.open(\"dispose\");&#125; 调用了nativeInit执行native层的初始化 Step 17.、InputEventReceiver.nativeInit()12345678910111213141516[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject inputChannelObj, jobject messageQueueObj) &#123; sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj); sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); sp&lt;NativeInputEventReceiver&gt; receiver = new NativeInputEventReceiver(env, receiverWeak, inputChannel, messageQueue); status_t status = receiver-&gt;initialize(); receiver-&gt;incStrong(gInputEventReceiverClassInfo.clazz); // retain a reference for the object return reinterpret_cast&lt;jlong&gt;(receiver.get());&#125; 函数创建了一个NativeInputEventReceiver对象，并调用其initialize函数 Step 18.、NativeInputEventReceiver.initialize()123456[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]status_t NativeInputEventReceiver::initialize() &#123; setFdEvents(ALOOPER_EVENT_INPUT); return OK;&#125; 调用setFdEvents函数 Step 19、NativeInputEventReceiver.setFdEvents()12345678910111213frameworks/base/core/jni/android_view_InputEventReceiver.cppvoid NativeInputEventReceiver::setFdEvents(int events) &#123; if (mFdEvents != events) &#123; mFdEvents = events; int fd = mInputConsumer.getChannel()-&gt;getFd(); if (events) &#123; mMessageQueue-&gt;getLooper()-&gt;addFd(fd, 0, events, this, NULL); &#125; else &#123; mMessageQueue-&gt;getLooper()-&gt;removeFd(fd); &#125; &#125;&#125; 这里调用传入的MessageQueue获取Looper对象，如果events是0，则表示要移除监听fd，如果events不为0，表示要监听fd，这个fd是前面WindowManagerService创建的一对InputChannel的client端，这样当Server端写入事件时，client端的looper就能被唤醒，并调用handleEvent函数（Looper::addFd函数可以指定LooperCallback对象，当fd可读时，会调用LooperCallback的handleEvent，而NativeInputEventReceiver继承自LooperCallback，所以这里会调用NativeInputEventReceiver的handleEvent函数）贴上事件处理序列图。 Step 20、NativeInputEventReceiver.handleEvent()12345678910[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]int NativeInputEventReceiver::handleEvent(int receiveFd, int events, void* data) &#123; if (events &amp; ALOOPER_EVENT_INPUT) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); status_t status = consumeEvents(env, false /*consumeBatches*/, -1, NULL); mMessageQueue-&gt;raiseAndClearException(env, \"handleReceiveCallback\"); return status == OK || status == NO_MEMORY ? 1 : 0; &#125; &#125; 该函数调用consumeEvents函数来处理接收一个按键事件 Step 21、NativeInputEventReceiver.consumeEvents()12345678910111213141516171819202122232425262728293031323334[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) &#123; ...... ScopedLocalRef&lt;jobject&gt; receiverObj(env, NULL); bool skipCallbacks = false; for (;;) &#123; uint32_t seq; InputEvent* inputEvent; // 处理接收一个按键事件 status_t status = mInputConsumer.consume(&amp;mInputEventFactory, consumeBatches, frameTime, &amp;seq, &amp;inputEvent); if (!skipCallbacks) &#123; jobject inputEventObj; switch (inputEvent-&gt;getType()) &#123; case AINPUT_EVENT_TYPE_KEY: inputEventObj = android_view_KeyEvent_fromNative(env, static_cast&lt;KeyEvent*&gt;(inputEvent)); break; &#125; if (inputEventObj) &#123; env-&gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj); env-&gt;DeleteLocalRef(inputEventObj); &#125; &#125; if (skipCallbacks) &#123; mInputConsumer.sendFinishedSignal(seq, false); &#125; &#125;&#125; 函数首先调用mInputConsumer.consume接收一个InputEvent对象,mInputConsumer在NativeInputEventReceiver构造函数中初始化 Step 22、InputConsumer.consume()12345678910111213141516171819202122232425262728293031323334353637383940414243[-&gt;frameworks/native/libs/input/InputTransport.cpp]status_t InputConsumer::consume(InputEventFactoryInterface* factory, bool consumeBatches, nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent) &#123; *outSeq = 0; *outEvent = NULL; // Fetch the next input message. // Loop until an event can be returned or no additional events are received. while (!*outEvent) &#123; if (mMsgDeferred) &#123; // mMsg contains a valid input message from the previous call to consume // that has not yet been processed. mMsgDeferred = false; &#125; else &#123; // Receive a fresh message. status_t result = mChannel-&gt;receiveMessage(&amp;mMsg); if (result) &#123; // Consume the next batched event unless batches are being held for later. if (consumeBatches || result != WOULD_BLOCK) &#123; result = consumeBatch(factory, frameTime, outSeq, outEvent); if (*outEvent) &#123; break; &#125; &#125; return result; &#125; &#125; switch (mMsg.header.type) &#123; case InputMessage::TYPE_KEY: &#123; KeyEvent* keyEvent = factory-&gt;createKeyEvent(); if (!keyEvent) return NO_MEMORY; initializeKeyEvent(keyEvent, &amp;mMsg); *outSeq = mMsg.body.key.seq; *outEvent = keyEvent; break; &#125; &#125; return OK;&#125; 函数首先调用InputChannel的receiveMessage函数接收InputMessage对象，然后根据InputMessage对象调用initializeKeyEvent来构造KeyEvent对象。拿到可KeyEvent对象后，再对到consumeEvents中调用java层的InputEventReceiver.java的dispatchInputEvent函数 12env-&gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj); Step 23、InputEventReceiver.dispatchInputEvent()12345678[-&gt;frameworks/base/core/java/android/view/InputEventReceiver.java]// Called from native code.SuppressWarnings(\"unused\")private void dispatchInputEvent(int seq, InputEvent event) &#123; mSeqMap.put(event.getSequenceNumber(), seq); onInputEvent(event);&#125; 进而调用onInputEvent函数。至此按键就开始了java层的分发(下一节详细介绍)。 回到主线，故事来没讲完。当App这端处理完输入事件调用ViewRootImpl.finishInputEvent() 12345678910 [-&gt;/frameworks/base/core/java/android/view/ViewRootImpl.java] private void finishInputEvent(QueuedInputEvent q) &#123; ...... if (q.mReceiver != null) &#123; boolean handled = (q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED_HANDLED) != 0; q.mReceiver.finishInputEvent(q.mEvent, handled); &#125;...... recycleQueuedInputEvent(q);&#125; Java层InputEventReceiver.nativeFinishInputEvent() 通过JNI 调用android_view_InputEventReceiver.finishInputEvent() 12345678[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]status_t NativeInputEventReceiver::finishInputEvent(uint32_t seq, bool handled) &#123; if (kDebugDispatchCycle) &#123; ALOGD(\"channel '%s' ~ Finished input event.\", getInputChannelName()); &#125; status_t status = mInputConsumer.sendFinishedSignal(seq, handled); &#125; 层层跳转最后会调用到InputConsumer.sendUnchainedFinishedSignal()发送一个InputMessage::TYPE_FINISHED消息。 123456789[-&gt;/frameworks/native/libs/input/InputTransport.cpp]status_t InputConsumer::sendUnchainedFinishedSignal(uint32_t seq, bool handled) &#123;InputMessage msg;msg.header.type = InputMessage::TYPE_FINISHED;msg.body.finished.seq = seq;msg.body.finished.handled = handled;return mChannel-&gt;sendMessage(&amp;msg);&#125; 在InputDispatcher.registerInputChannel()中添加了一个 handleReceiveCallback回调。 1mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this); 然后通过和IMS中InputDispacher的通信管道InputChannel发了处理完成通知。那InputDispatcher这边收到后如何处理呢？ 由前面分析 InputDispatcher会调用handleReceiveCallback()来处理TYPE_FINISHED信号。这里先是往Command队列里放一个处理事务执行doDispatchCycleFinishedLockedInterruptible()，后面在runCommandsLockedInterruptible()中会取出执行。在doDispatchCycleFinishedLockedInterruptible()函数中，会先调用afterKeyEventLockedInterruptible()。Android中可以定义一些Fallback键，即如果一个Key事件App没有处理，可以Fallback成另外默认的Key事件，这是在这里的dispatchUnhandledKey()函数中进行处理的。接着InputDispatcher会将该收到完成信号的事件项从等待队列中移除。同时由于上一个事件已被App处理完，就可以调用startDispatchCycleLocked()来进行下一轮事件的处理了。 12345678[-&gt;/frameworks/native/services/inputflinger/InputDispatcher.cpp]if (dispatchEntry == connection-&gt;findWaitQueueEntry(seq)) &#123; connection-&gt;waitQueue.dequeue(dispatchEntry); ... &#125; // Start the next dispatch cycle for this connection. startDispatchCycleLocked(now(), connection); startDispatchCycleLocked函数会检查相应连接的输出缓冲中(connection-&gt;outboundQueue)是否有事件要发送的，有的话会通过InputChannel发送出去。 总结： 8、Android Input子系统之java层按键传递Android开发中在自定义Activity以及View时经常会重写onKeyDown,onKeyUp,dispatchKeyEvent，同时View还有setOnKeyListener等，当一个按键事件发生时，这些方法将会被回调，但是到底哪个先回调，哪个后回调呢，一直不是特别清楚，只知道个大概，下面将详细讲述按键在java层的分发过程，其中重点关注按键事件在View层次中的分发 java层的按键分发从ViewRootImpl.java的WindowInputEventReceiver中的onInputEvent开始，从前面的应用程序注册消息监听过程分析和Input Dispatcher分析，InputDispatcher在处理按键事件时，会通过InputChannel::sendMessage函数将按键消息从server端写入，这里的InputChannel是当前获取焦点的窗口的InputChannel对的server端，这样应用程序端就可以收到该消息，然后调用NativeInputEventReceiver的handleEvent,最后调用到InputEventReceiver的onInputEvent函数（具体的可以看应用程序注册消息监听过程分析 的Step20-Step23） 序列图： Step 1、WindowInputEventReceiver.onInputEvent()12345678910111213[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]final class WindowInputEventReceiver extends InputEventReceiver &#123; public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) &#123; super(inputChannel, looper); &#125; @Override public void onInputEvent(InputEvent event) &#123; enqueueInputEvent(event, this, 0, true); &#125; ...&#125; 这里只列出部分代码，当一个按键按下时onInputEvent方法就会被回调，其中调用了ViewRootImpl::enqueueInputEvent(event, this, 0, true); Step 2、ViewRootImpl.enqueueInputEvent()12345678910111213[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately) &#123; // 从队列中获取一个QueuedInputEvent，这里的flags传入的是0 QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags); ... if (processImmediately) &#123; doProcessInputEvents();//这里传入的processImmediately是true，所以调用doProcessInputEvents &#125; else &#123; scheduleProcessInputEvents(); &#125;&#125; 从前面的参数可知，这里表示要立即处理，所以调用doProcessInputEvents函数. Step 3、ViewRootImpl.doProcessInputEvents()1234567891011121314151617frameworks/base/core/java/android/view/ViewRootImpl.javavoid doProcessInputEvents() &#123; // Deliver all pending input events in the queue. while (mPendingInputEventHead != null) &#123; QueuedInputEvent q = mPendingInputEventHead; mPendingInputEventHead = q.mNext; if (mPendingInputEventHead == null) &#123; mPendingInputEventTail = null; &#125; q.mNext = null; mPendingInputEventCount -= 1; ... // 分发按键事件 deliverInputEvent(q); &#125;&#125; 在deliverInputEvent函数中实际做按键的分发 Step 4、ViewRootImpl.deliverInputEvent()1234567891011121314151617181920212223[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]private void deliverInputEvent(QueuedInputEvent q) &#123; Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, \"deliverInputEvent\", q.mEvent.getSequenceNumber()); if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onInputEvent(q.mEvent, 0); &#125; InputStage stage; if (q.shouldSendToSynthesizer()) &#123; stage = mSyntheticInputStage; &#125; else &#123; //选择责任链的模式的入口，如果InputEvent需要跳过IME处理，则从mFirstPostImeInputStage（EarlyPostImeInputStage）开始,否则从mFirstInputStage(NativePreImeInputStage)开始分发 stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; &#125; if (stage != null) &#123; stage.deliver(q); &#125; else &#123; finishInputEvent(q); &#125;&#125; 这里调用了InputStage的deliver方法分发，这里的InputStage代表了输入事件的处理阶段，是一种责任链模式InputStage将输入事件的处理分成若干个阶段（Stage）, 如果当前有输入法窗口，则事件处理从 NativePreIme 开始，否则的话，从EarlyPostIme 开始。事件会依次经过每个Stage，如果该事件没有被标识为 “Finished”， 该Stage就会处理它，然后返回处理结果，Forward 或 Finish， Forward 运行下一Stage继续处理，而Finished事件将会简单的Forward到下一级，直到最后一级 Synthetic InputStage。流程图和每个阶段完成的事情如下图所示 责任链模式：责任链模式（Chain of Responsibility）的目标是使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。 按键分发：在ViewRootImpl的setView函数中会构造一个如图所示的InputStage的链，按键会从入口阶段，进入责任链，顺序处理，入口阶段根据QueuedInputEvent的状态来决定。q.shouldSendToSynthesizer() 这里一般是false，因此主要看stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; 这里的shouldSkipIme其实是一个flag在构造QueuedInputEvent时传入的，从前面的onInputEvent调用的enqueueInputEvent(event, this, 0, true);可知，这里传入的flags是第三个参数0，那这里的shouldSkipIme就是false，那么按键会从mFirstPostImeInputStage 开始分发，就是图中的NativePreImeInputStage分发。 下面只从跟本文前面提到的Activity，View的按键分发流程相关的InputStage（ViewPostImeInputStage）开始分析 Step 5、ViewPostImeInputStage.processKeyEvent()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]private int processKeyEvent(QueuedInputEvent q) &#123; final KeyEvent event = (KeyEvent)q.mEvent; ... // Deliver the key to the view hierarchy. // 调用成员变量mView的dispatchKeyEvent函数，这里mView是PhoneWindow.DecorView对象 if (mView.dispatchKeyEvent(event)) &#123; return FINISH_HANDLED; &#125; ... // 如果按键是四向键或者是TAB键，则移动焦点 // Handle automatic focus changes. if (event.getAction() == KeyEvent.ACTION_DOWN) &#123; int direction = 0; switch (event.getKeyCode()) &#123; case KeyEvent.KEYCODE_DPAD_LEFT: if (event.hasNoModifiers()) &#123; direction = View.FOCUS_LEFT; &#125; break; ...... case KeyEvent.KEYCODE_TAB: if (event.hasNoModifiers()) &#123; direction = View.FOCUS_FORWARD; &#125; else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) &#123; direction = View.FOCUS_BACKWARD; &#125; break; &#125; if (direction != 0) &#123; View focused = mView.findFocus(); if (focused != null) &#123; View v = focused.focusSearch(direction); if (v != null &amp;&amp; v != focused) &#123; ...... focused.getFocusedRect(mTempRect); if (mView instanceof ViewGroup) &#123; ((ViewGroup) mView).offsetDescendantRectToMyCoords( focused, mTempRect); ((ViewGroup) mView).offsetRectIntoDescendantCoords( v, mTempRect); &#125; if (v.requestFocus(direction, mTempRect)) &#123; playSoundEffect(SoundEffectConstants .getContantForFocusDirection(direction)); return FINISH_HANDLED; &#125; &#125; // Give the focused view a last chance to handle the dpad key. if (mView.dispatchUnhandledMove(focused, direction)) &#123; return FINISH_HANDLED; &#125; &#125; else &#123; // find the best view to give focus to in this non-touch-mode with no-focus View v = focusSearch(null, direction); if (v != null &amp;&amp; v.requestFocus(direction)) &#123; return FINISH_HANDLED; &#125; &#125; &#125; &#125; return FORWARD;&#125; 上述主要分两步：第一步是调用PhoneWindow.DecorView的dispatchKeyEvent函数，DecorView是View层次结构的根节点，按键从根节点开始根据Focuse view的path自上而下的分发。第二步是判断按键是否是四向键，或者是TAB键，如果是则需要移动焦点 Step 6、mView.dispatchKeyEvent()1234567891011121314public boolean dispatchKeyEvent(KeyEvent event) &#123; ... if (!isDestroyed()) &#123; final Callback cb = getCallback(); final boolean handled = cb != null &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchKeyEvent(event) : super.dispatchKeyEvent(event); if (handled) &#123; return true; &#125; &#125; return isDown ? PhoneWindow.this.onKeyDown(mFeatureId, event.getKeyCode(), event) : PhoneWindow.this.onKeyUp(mFeatureId, event.getKeyCode(), event);&#125; 主要的分发在下面开始，如果cb不为空并且mFeatureId小于0，则调用cb.dispatchKeyEvent开始分发，否则会调用DecorView的父类（View）的dispatchKeyEvent函数。cb是Window.Callback类型，Activity实现了Window.Callback接口，在attach函数中，会调用Window.setCallback函数将自己注册进PhoneWindow中，所以cb不为空。在PhoneWindow初始化时会调用installDecor函数生成DecorView对象，该函数中传入的mFeatureId是-1，所以mFeatureId也小于0。因此此处会调用Activity的dispatchKeyEvent函数，开始在View中分发按键。 下面来分析按键在View的层次结构中是如何分发的DecorView的按键分发 接下来来看这里先看看Activity(Callback)的dispatchKeyEvent实现： Step 7、Activity.dispatchKeyEvent()1234567891011121314151617[frameworks/base/core/java/android/app/Activity.java]public boolean dispatchKeyEvent(KeyEvent event) &#123; //调用自定义的onUserInteraction onUserInteraction(); Window win = getWindow(); //调用PhoneWindow的superDispatchKeyEvent,实际调用DecorView的superDispatchKeyEvent，从DecorView开始从顶层View往子视图传递 if (win.superDispatchKeyEvent(event)) &#123; return true; &#125; View decor = mDecor; if (decor == null) decor = win.getDecorView(); //到这里如果view层次结构没有返回true则交给KeyEvent本身的dispatch方法，Activity的onKeyDown/onKeyUp/onKeyMultiple就会被触发 return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);&#125; 接着看下PhoneWindow的superDispatchKeyEvent Step 8、PhoneWindow.superDispatchKeyEvent()12345678910111213141516171819202122&lt;!-- PhoneWindow.java --&gt;Overridepublic boolean superDispatchKeyEvent(KeyEvent event) &#123; return mDecor.superDispatchKeyEvent(event);&#125; &lt;!-- PhoneWindow.DecorView --&gt;public boolean superDispatchKeyEvent(KeyEvent event) &#123; // Give priority to closing action modes if applicable. if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123; final int action = event.getAction(); // Back cancels action modes first. if (mPrimaryActionMode != null) &#123; if (action == KeyEvent.ACTION_UP) &#123; mPrimaryActionMode.finish(); &#125; return true; &#125; &#125; //进入View的层次结构，调用ViewGroup.dispatchKeyEvent return super.dispatchKeyEvent(event);&#125; 再看ViewGroup的dispatchKeyEvent函数 Step 9、ViewGroup.dispatchKeyEvent()1234567891011121314151617181920[-&gt;frameworks/base/core/java/android/view/ViewGroup.java]public boolean dispatchKeyEvent(KeyEvent event) &#123; ... if ((mPrivateFlags &amp; (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) &#123; //如果此ViewGroup是focused并且具体的大小被设置了（有边界），则交给它处理，即调用View的实现 if (super.dispatchKeyEvent(event)) &#123; return true; &#125; &#125; else if (mFocused != null &amp;&amp; (mFocused.mPrivateFlags &amp; PFLAG_HAS_BOUNDS) == PFLAG_HAS_BOUNDS) &#123; //否则，如果此ViewGroup中有focused的child，且child有具体的大小，则交给mFocused处理 if (mFocused.dispatchKeyEvent(event)) &#123; return true; &#125; &#125; ... return false;&#125; 这里可以看出如果ViewGroup满足条件，则优先处理事件而不发给子视图去处理。 下面看下View的dispatchKeyEvent实现 Step 10、View.dispatchKeyEvent()1234567891011121314151617181920[-&gt;frameworks/base/core/java/android/view/View.java]public boolean dispatchKeyEvent(KeyEvent event) &#123; ... // Give any attached key listener a first crack at the event. //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; //调用onKeyListener，如果注册了OnKeyListener,并且View属于Enable状态，则触发 if (li != null &amp;&amp; li.mOnKeyListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnKeyListener.onKey(this, event.getKeyCode(), event)) &#123; return true; &#125; //调用KeyEvent.dispatch方法，并将view作为参数传递进去，实际会回调View的onKeyUp/onKeyDown等方法 if (event.dispatch(this, mAttachInfo != null ? mAttachInfo.mKeyDispatchState : null, this)) &#123; return true; &#125; ... return false;&#125; Step 11、View.onKeyDown/View.onKeyUp123456789101112131415161718192021222324252627282930313233343536373839404142[-&gt;frameworks/base/core/java/android/view/View.java]public boolean onKeyDown(int keyCode, KeyEvent event) &#123; boolean result = false; //处理KEYCODE_DPAD_CENTER、KEYCODE_ENTER按键 if (KeyEvent.isConfirmKey(keyCode)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == DISABLED) &#123; //disabled的view直接返回true，不再继续分发,即Activity的onKeyDown和onKeyUp无法收到KEYCODE_DPAD_CENTER、KEYCODE_ENTER事件 return true; &#125; // Long clickable items don't necessarily have to be clickable if (((mViewFlags &amp; CLICKABLE) == CLICKABLE || (mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) &amp;&amp; (event.getRepeatCount() == 0)) &#123;// clickable或者long_clickable且是第一次down事件 setPressed(true);// 标记pressed，你可能设置了View不同的background，这时候就会有所体现（比如高亮效果） checkForLongClick(0); return true; &#125; &#125; return result;&#125;public boolean onKeyUp(int keyCode, KeyEvent event) &#123; //处理KEYCODE_DPAD_CENTER、KEYCODE_ENTER按键 if (KeyEvent.isConfirmKey(keyCode)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == DISABLED) &#123; //disabled的view直接返回true，不再继续分发,即Activity的onKeyDown和onKeyUp无法收到KEYCODE_DPAD_CENTER、KEYCODE_ENTER事件 return true; &#125; if ((mViewFlags &amp; CLICKABLE) == CLICKABLE &amp;&amp; isPressed()) &#123; setPressed(false); if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); return performClick(); &#125; &#125; &#125; return false;&#125; Step 12、Activity.onKeyDown/onKeyUp12345678910111213141516171819202122232425262728[-&gt;frameworks/base/core/java/android/app/Activity.java]public boolean onKeyDown(int keyCode, KeyEvent event) &#123; //如果是back键则启动追踪 if (keyCode == KeyEvent.KEYCODE_BACK) &#123; if (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.ECLAIR) &#123; event.startTracking(); &#125; else &#123; onBackPressed(); &#125; return true; &#125; ...&#125;public boolean onKeyUp(int keyCode, KeyEvent event) &#123; if (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.ECLAIR) &#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.isTracking() &amp;&amp; !event.isCanceled()) &#123; //如果是back键并且正在追踪该Event，则调用onBackPressed onBackPressed(); return true; &#125; &#125; return false;&#125; 而Android常见Touch事件是通过dispatchPointerEvent(MotionEvent event)分发的，主要跟底层传上来的 输入事件相关，不同类型事件分别处理。具体Touch事件分发机制可参考博客：Android事件分发机制完全解析，带你从源码的角度彻底理解(上)Android事件分发机制完全解析，带你从源码的角度彻底理解(下)Android触摸屏事件派发机制详解与源码分析一(View篇)Android触摸屏事件派发机制详解与源码分析二(ViewGroup篇)Android触摸屏事件派发机制详解与源码分析三(Activity篇)Android Deeper(00) - Touch事件分发响应机制 九、总结：再贴一下Input system总体框架图： （一）、IMS初始化&amp;&amp; IMS与App建立通信： SystemServer初始化过程中，创建InputManagerService，IMS第一件事情就是初始化Native层，包括EventHub, InputReader 和 InputDispatcher IMS以及其他的System Service 初始化完成之后，应用程序就开始启动。如果一个应用程序有Activity（只有Activit能够接受用户输入），它要将自己的Window(ViewRootImpl)通过setView()注册到WindowManagerService 中 用户输入的捕捉和处理发生在不同的进程里（生产者：Input Reader 和 Input Dispatcher 在System Server 进程里，而消费者，应用程序运行在自己的进程里），因此用户输入事件（Event)的传递需要跨进程。在这里，Android使用了Socket + Binder来完成。OpenInputChannelPair 生成了两个Socket的FD， 代表一个双向通道的两端，向一端写入数据，另外一端便可以读出，反之依然，如果一端没有写入数据，另外一端去读，则陷入阻塞等待。OpenInputChannelPair() 发生在WindowManager Service.addWindow()中 通过RegisterInputChannel, WindowManagerService 将刚刚创建的一个Socket FD，封装在InputWindowHandle(代表一个WindowState) 里传给InputManagerService InputManagerService 通过JNI（NativeInputManager）最终调用到了InputDispatcher 的 RegisterInputChannel()方法，这里，一个Connection 对象被创建出来，代表与远端某个窗口(InputWindowHandle)的一条用户输入数据通道。一个Dispatcher可能有多个Connection（多个Window）同时存在。为了监听来自于Window的消息，InputDispatcher 通过AddFd 将这些个FD 加入到Looper中，这样，只要某个Window在Socket的另一端写入数据，Looper就会马上从睡眠中醒来，进行处理。 到这里，ViewRootImpl mWindowSession.addToDisplay返回，WMS 将SocketPair的另外一个FD 放在返回参数 OutputChannel 里，即返回给APP进程。 接着ViewRootImpl 创建了WindowInputEventReceiver 用于接受InputDispatchor 传过来的事件，App进程同样通过AddFd() 将读端的Socket FD 加入到Looper中，这样一旦InputDispatchor发送Event，Looper就会立即醒来处理。 （二）、Eventhub 和 Input Reader NativeInputManager的构造函数里第一件事情就是创建一个EventHub对象，EventHub构造函数里主要生成并初始化几个控制的FD mINotifyFd: 用来监控””/dev/input”目录下是否有文件生成，有的话说明有新的输入设备接入，EventHub将从epool_wait中唤醒，来打开新加入的设备 mWakeReaderFD， mWakeWriterFD： 一个Pipe的两端，当往mWakeWriteFD 写入数据的时候，等待在mWakeReaderFD的线程被唤醒，这里用来给上层应用提供唤醒等待线程，比如说，当上层应用改变输入属性需要EventHub进行相应更新时 mEpollFD，用于epoll_wait()的阻塞等待，这里通过epoll_ctrl(EPOLL_ADD_FD, fd) 可以等待多个fd的事件，包括上面提到的mINotifyFD, mWakeReaderFD, 以及输入设备的FD。 InputManagerService启动InputReader 线程，进入无限的循环，每次循环调用loopOnce(). 第一次循环，会主动扫描 “/dev/input/“ 目录，并打开下面的所有文件，通过ioctl()从底层驱动获取设备信息，并判断它的设备类型。这里处理的设备类型有：INPUT_DEVICE_CLASS_KEYBOARD， INPUT_DEVICE_CLASS_TOUCH， INPUT_DEVICE_CLASS_DPAD，INPUT_DEVICE_CLASS_JOYSTICK 等。 找到每个设备对应的键值映射文件，读取并生产一个KeyMap 对象。一般来说，设备对应的键值映射文件是 “/system/usr/keylayout/Generic.kl”. 将刚才扫描到的/dev/input 下所有文件的FD 加到epool等待队列中，调用epool_wait() 开始等待事件的发生。 某个时间发生，可能是用户按键输入，也可能是某个设备插入，亦或用户调整了设备属性，epoll_wait() 返回，将发生的Event 存放在mPendingEventItems 里。如果这是一个用户输入，系统调用Read() 从驱动读到这个按键的信息，存放在rawEvents里。 EventHub-&gt;getEvents() 返回,代表有新的input事件到来，进入InputReader的processEventLocked函数。 通过rawEvent 找到产生时间的Device，再找到这个Device对应的InputMapper对象，最终生成一个NotifyArgs对象，将其放到NotifyArgs的队列中。 调用NotifyArgs里面的Notify()方法，最终调用到InputDispatchor 对应的Notify接口（比如NotifyKey) 将接下来的处理交给InputDispatchor，EventHub 和 InputReader 工作结束，但马上又开始新的一轮等待，重复6～9的循环。 （三）、Input Dispatcher 接上节的最后一步，NotifyKey() 的实现在Input Dispatcher 内部，他首先做简单的校验，对于按键事件，只有Action 是 AKEY_EVENT_ACTION_DOWN 和 AKEY_EVENT_ACTION_UP，即按下和弹起这两个Event别接受。 Input Reader 传给Input Dispather的数据类型是 NotifyKeyArgs， 后者在这里将其转换为 KeyEvent, 然后交由 Policy 来进行第一步的解析和过滤，interceptKeyBeforeDispatching(), 对于手机产品，这个工作是在PhoneWindowManager 里完成，（不同类型的产品可以定义不同的WindowManager, 比如GoogleTV 里用到的是TVWindowManager)。KeyEvent 在这里将会被分为三类： System Key: 比如说 音量键，Power键，以及一些特殊的组合键，如用于截屏的音量+Power，等等。部分System Key 会在这里立即处理，比如说电话键，但有一些会放到后面去做处理，比如说音量键，但不管怎样，这些键不会传给应用程序，所以称为系统键。 Global Key：最终产品中可能会有一些特殊的按键，它不属于某个特定的应用，在所有应用中的行为都是一样，但也不包含在Andrioid的系统键中，比如说GoogleTV 里会有一个“TV” 按键，按它会直接呼起“TV”应用然后收看电视直播，这类按键在Android定义为Global Key. User Key：除此之外的按键就是User Key, 它最终会传递到当前的应用窗口。 此时，InputDispather 还在Looper中睡眠等待，mLooper-&gt;wake();将其唤醒，然后进入Input Dispatcher 线程。 InputDispatcher 大部分的工作在 dispatcherOnce 里完成。首先从mInBoundQueue 中读出队列头部的事件 mPendingEvent, 然后调用 pokeUserActivityLocked()。 poke的英文意思是”搓一下, 捅一下“， 这个函数的目的也就是”捅一下“PowerManagerService 提醒它”别睡眠啊，我还活着呢“，最终调用到PowerManagerService 的 updatePowerStateLocked()，防止手机进入休眠状态。需要注意的是，上述动作不会马上执行，而是存储在命令队列，mCommandQueue里，这里面的命令会在后面依次被执行。 接下来是dispatchOnceInnerLocked()-&gt;dispatchKeyLocked() 第一次进去这个函数的时候，先检查Event是否已经过处理（doInterceptKeyBeforeDispatchingLockedInterruptible), 如果没有，则生成一个命令，同样放入mCommandQueue里。 runCommandsLockedInterruptible() 依次执行mCommandQueue 里的命令，前面说过，pokeUserActivity 会调用PowerManagerService 的 updatePowerStateLocked(), 而 interceptKeyBeforeDispatching() 则最终调用到PhoneWindowManager的同名函数。我们在interceptBeforeQueuing 里面提到的一些系统按键在这个被执行，比如 HOME/MENU/SEARCH 等。 命令运行完之后，退出 dispatchOnce， 然后调用pollOnce 进入下一轮等待。但这里不会被阻塞，因为timeout值被设成了0. 第二次进入dispatchKeyLocked(), 这是Event的状态已经设为”已处理“，这时候才真正进入了发射阶段。 接下来调用 findFocusedWindowTargetLocked() 获取当前的焦点窗口，这里面会做一件非常重要的事情，就是检测目标应用是否有ANR发生，如果下诉条件满足，则说明可能发生了ANR： 目标应用不会空，而目标窗口为空。说明应用程序在启动过程中出现了问题。 目标 Activity 的状态是Pause，即不再是Focused的应用。 目标窗口还在处理上一个事件。这个我们下面会说到。 如果目标窗口处于正常状态，调用dispatchEventLocked() 进入真正的发送程序。 然后调用prepareDispatchCycleLocked() ,这里事件换了一件马甲，从EventEntry 变成 DispatchEntry, 并送人mOutBoundQueue。然后调用startDispatchCycleLocked() 开始发送。 最终的发送发生在InputChannel的sendMessage()。这里就用到了我们前面提到的SocketPair, 一旦sendMessage() 执行，目标窗口所在进程的Looper线程就会被唤醒，然后读取键值并进行处理。 乖乖，还没走完啊？是的，工作还差最后一步，Input Dispatcher给这个窗口发送下一个命令之前，必须等待该窗口的回复，如果超过5s没有收到，就会通过Input Manager Service 向Activity Manager 汇报，后者会弹出我们熟知的 “Application No Response” 窗口。所以，事件会放入mWaitQueue进行暂存。如果窗口一切正常，完成按键处理后它会调用InputConsumer的sendFinishedSignal() 往SocketPair 里写入完成信号，Input Dispatcher 从 Loop中醒来，并从Socket中读取该信号，然后从mWaitQueue 里清除该事件标志其处理完毕。 （四）、Key Processing略、请参考：图解Android - Android GUI 系统 (5) - Android的Event Input System - 漫天尘沙 - 博客园 参考文档(特别感谢)：韦东山第4期Android驱动深度开发视频源码-GitHub韦东山第4期Android驱动深度开发视频-输入系统-100ask.orgAndroid输入子系统-ChenWeiaiYanYan《深入理解Android 卷III》第五章 深入理解Android输入系统 - CSDN博客图解Android - Android GUI 系统 (5) - Android的Event Input System - 漫天尘沙 - 博客园Android 5.0(Lollipop)事件输入系统(Input System) - 世事难料，保持低调 - CSDN博客【Android】Android输入子系统 - Leo.cheng - 博客园Android(Linux) 输入子系统解析 | Andy.Lee’s BlogINPUT事件的读取和分发：INPUTREADER、INPUTDISPATCHERAndroid 触摸事件分发机制深入理解Android之Touch事件的分发","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Activity - Window 加载显示流程（AMS && WMS）分析","slug":"Android-7-1-2-Android-N-Activity-Window加载显示流程","date":"2017-10-31T16:00:00.000Z","updated":"2018-03-23T07:22:24.000Z","comments":true,"path":"2017/11/01/Android-7-1-2-Android-N-Activity-Window加载显示流程/","link":"","permalink":"http://zhoujinjian.cc/2017/11/01/Android-7-1-2-Android-N-Activity-Window加载显示流程/","excerpt":"Activity-Window加载显示流程概述：Android系统中图形系统是相当复杂的，包括WindowManager，SurfaceFlinger,Open GL,GPU等模块。 其中SurfaceFlinger作为负责绘制应用UI的核心，从名字可以看出其功能是将所有Surface合成工作。 不论使用什么渲染API, 所有的东西最终都是渲染到”surface”. surface代表BufferQueue的生产者端, 并且 由SurfaceFlinger所消费, 这便是基本的生产者-消费者模式. Android平台所创建的Window都由surface所支持, 所有可见的surface渲染到显示设备都是通过SurfaceFlinger来完成的.本文详细分析Android Window加载显示流程，并通过SurfaceFlinger渲染合成输出到屏幕的过程。","text":"Activity-Window加载显示流程概述：Android系统中图形系统是相当复杂的，包括WindowManager，SurfaceFlinger,Open GL,GPU等模块。 其中SurfaceFlinger作为负责绘制应用UI的核心，从名字可以看出其功能是将所有Surface合成工作。 不论使用什么渲染API, 所有的东西最终都是渲染到”surface”. surface代表BufferQueue的生产者端, 并且 由SurfaceFlinger所消费, 这便是基本的生产者-消费者模式. Android平台所创建的Window都由surface所支持, 所有可见的surface渲染到显示设备都是通过SurfaceFlinger来完成的.本文详细分析Android Window加载显示流程，并通过SurfaceFlinger渲染合成输出到屏幕的过程。 一、Activity启动流程概述基于Android 7.1.2的源码剖析， 分析Activity-Window加载显示流程，相关源码： frameworks/base/core/java/android/app/● Activity.java● ActivityThread.java● Instrumentation.java frameworks/base/core/jni/● android_view_DisplayEventReceiver.cpp● android_view_SurfaceControl.cpp● android_view_Surface.cpp● android_view_SurfaceSession.cpp frameworks/native/include/gui/● SurfaceComposerClient.cpp● SurfaceComposerClient.h frameworks/native/services/surfaceflinger/● SurfaceFlinger.cpp● Client.cpp frameworks/base/core/java/android/view/● WindowManagerImpl.java● ViewManager.java● WindowManagerGlobal.java● ViewRootImpl.java● Choreographer.java● IWindowSession.aidl● DisplayEventReceiver.java● SurfaceControl.java● Surface.java● SurfaceSession.java frameworks/base/core/java/com/android/internal/policy/● PhoneWindow.java frameworks/base/services/core/java/com/android/server/wm/● WindowManagerService.java● Session.java● WindowState.java● WindowStateAnimator.java● WindowSurfaceController.java 博客原图链接在前面文章（Android 7.1.2(Android N) Activity启动流程分析）中详细分析了Activity启动流程，这里回顾一下总体流程。Activity启动流程图： 启动流程： ● 点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；● system_server进程接收到请求后，向zygote进程发送创建进程的请求；● Zygote进程fork出新的子进程，即App进程；● App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；● system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；● App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；● 主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。 App正式启动后，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面， 接下来分析UI渲染流程。 二、Window加载显示流程2.1、ActivityThread.handleLaunchActivity()接着从ActivityThread的handleLaunchActivity方法：[-&gt;ActivityThread.java] 12345678910111213141516 private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason)&#123; ...... // Initialize before creating the activity WindowManagerGlobal.initialize(); //创建Activity Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; ...... //启动Activity handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); ...... &#125;&#125; 应用程序进程通过performLaunchActivity函数将即将要启动的Activity加载到当前进程空间来，同时为启动Activity做准备。[ActivityThread.java #performLaunchActivity()] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //通过Activity所在的应用程序信息及该Activity对应的CompatibilityInfo信息从PMS服务中查询当前Activity的包信息 ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; //获取当前Activity的组件信息 ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; //packageName为启动Activity的包名，targetActivity为Activity的类名 if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //通过类反射方式加载即将启动的Activity Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; ...... try &#123; //通过单例模式为应用程序进程创建Application对象 Application app = r.packageInfo.makeApplication(false, mInstrumentation); ...... if (activity != null) &#123; //为当前Activity创建上下文对象ContextImpl Context appContext = createBaseContextForActivity(r, activity); ...... //将当前启动的Activity和上下文ContextImpl、Application绑定 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); ...... //将Activity保存到ActivityClientRecord中，ActivityClientRecord为Activity在应用程序进程中的描述符 r.activity = activity; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ...... //生命周期onStart、onresume if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; //ActivityThread的成员变量mActivities保存了当前应用程序进程中的所有Activity的描述符 mActivities.put(r.token, r); ...... return activity;&#125; 在该函数中，首先通过PMS服务查找到即将启动的Activity的包名信息，然后通过类反射方式创建一个该Activity实例，同时为应用程序启动的每一个Activity创建一个LoadedApk实例对象，应用程序进程中创建的所有LoadedApk对象保存在ActivityThread的成员变量mPackages中。接着通过LoadedApk对象的makeApplication函数，使用单例模式创建Application对象，因此在android应用程序进程中有且只有一个Application实例。然后为当前启动的Activity创建一个ContextImpl上下文对象，并初始化该上下文，到此我们可以知道，启动一个Activity需要以下对象： 1) Activity对象，需要启动的Activity； 2) LoadedApk对象，每个启动的Activity都拥有属于自身的LoadedApk对象； 3) ContextImpl对象，每个启动的Activity都拥有属于自身的ContextImpl对象； 4) Application对象，应用程序进程中有且只有一个实例，和Activity是一对多的关系； 2.2、Activity对象Attach过程Activity所需要的对象都创建好了，就需要将Activity和Application对象、ContextImpl对象绑定在一起。 参数：context：Activity的上下文对象，就是前面创建的ContextImpl对象； aThread：Activity运行所在的主线程描述符ActivityThread； instr：用于监控Activity运行状态的Instrumentation对象； token：用于和AMS服务通信的IApplicationToken.Proxy代理对象； application：Activity运行所在进程的Application对象； parent：启动当前Activity的Activity； [-&gt;Activity.java] 1234567891011121314151617181920212223242526272829 final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; //将上下文对象ContextImpl保存到Activity的成员变量中 attachBaseContext(context); ...... mWindow = new PhoneWindow(this, window); ...... //记录应用程序的UI线程 mUiThread = Thread.currentThread(); //记录应用程序的ActivityThread对象 mMainThread = aThread; ...... //为Activity所在的窗口创建窗口管理器 mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config;&#125; 在该attach函数中主要做了以下几件事： 1) 根据参数初始化Activity的成员变量； 2) 为Activity创建窗口Window对象； 3) 为Window创建窗口管理器； 2.3、Activity视图对象的创建过程-Activity.setContentView() ActivityThread.performLaunchActivity()–&gt; Instrumentation.callActivityOnCreate()——&gt;Activity.performCreate()——&gt;Activity.onCreate()–&gt;Activity.performStart()——&gt;Instrumentation.callActivityOnStart()——&gt;Activity.onStart() 1234 public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; getWindow()函数得到前面创建的窗口对象PhoneWindow，通过PhoneWindow来设置Activity的视图。[-&gt;PhoneWindow.java] 1234567891011121314151617181920 public void setContentView(View view, ViewGroup.LayoutParams params) &#123; ...... //如果窗口顶级视图对象为空，则创建窗口视图对象 if (mContentParent == null) &#123; installDecor(); &#125; ...... if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; ...... &#125; else &#123;//加载布局文件，并将布局文件中的所有视图对象添加到mContentParent容器中,PhoneWindow的成员变量mContentParent的类型为ViewGroup，是窗口内容存放的地方 mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; Activity.onCreate()会调用setContentView(),整个过程主要是Activity的布局文件或View添加至窗口里，详细过程不再赘述，详细加载过程请参考： Android应用setContentView与LayoutInflater加载解析机制源码分析重点概括为： ● 创建一个DecorView的对象mDecor，该mDecor对象将作为整个应用窗口的根视图。 ● 依据Feature等style theme创建不同的窗口修饰布局文件，并且通过findViewById获取Activity布局文件该存放的地方（窗口修饰布局文件中id为content的FrameLayout）。 ● 将Activity的布局文件添加至id为content的FrameLayout内。 ● 当setContentView设置显示OK以后会回调Activity的onContentChanged方法。Activity的各种View的findViewById()方法等都可以放到该方法中，系统会帮忙回调。 2.4、ActivityThread.handleResumeActivity()回到我们刚刚的handleLaunchActivity()方法，在调用完performLaunchActivity()方法之后，其有掉用了handleResumeActivity()法。 performLaunchActivity()方法完成了两件事： 1) Activity窗口对象的创建，通过attach函数来完成； 2) Activity视图对象的创建，通过setContentView函数来完成； 这些准备工作完成后，就可以显示该Activity了，应用程序进程通过调用handleResumeActivity函数来启动Activity的显示过程。 [-&gt;ActivityThread.java] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ActivityClientRecord r = mActivities.get(token); ...... // r = performResumeActivity(token, clearHide, reason); ...... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; //获得为当前Activity创建的窗口PhoneWindow对象 r.window = r.activity.getWindow(); //获取为窗口创建的视图DecorView对象 View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); //在attach函数中就为当前Activity创建了WindowManager对象 ViewManager wm = a.getWindowManager(); //得到该视图对象的布局参数 WindowManager.LayoutParams l = r.window.getAttributes(); //将视图对象保存到Activity的成员变量mDecor中 a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; ...... if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; //将创建的视图对象DecorView添加到Activity的窗口管理器中 wm.addView(decor, l); &#125; ...... if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; if (!r.onlyLocalRequest) &#123; //onStop()...... Looper.myQueue().addIdleHandler(new Idler()); &#125; r.onlyLocalRequest = false; if (reallyResume) &#123; try &#123; ActivityManagerNative.getDefault().activityResumed(token); &#125; &#125; ...... &#125;&#125; 我们知道，在前面的performLaunchActivity函数中完成Activity的创建后，会将当前当前创建的Activity在应用程序进程端的描述符ActivityClientRecord以键值对的形式保存到ActivityThread的成员变量mActivities中：mActivities.put(r.token, r)，r.token就是Activity的身份证，即是IApplicationToken.Proxy代理对象，也用于与AMS通信。上面的函数首先通过performResumeActivity从mActivities变量中取出Activity的应用程序端描述符ActivityClientRecord，然后取出前面为Activity创建的视图对象DecorView和窗口管理器WindowManager，最后将视图对象添加到窗口管理器中。 ViewManager.addView()真正实现的的地方在WindowManagerImpl.java中。 123456public interface ViewManager&#123;public void addView(View view, ViewGroup.LayoutParams params);public void updateViewLayout(View view, ViewGroup.LayoutParams params);public void removeView(View view);&#125; [-&gt;WindowManagerImpl.java] 12345@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; ...... mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125; [-&gt;WindowManagerGlobal.java] 123456789101112131415161718 public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ...... ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; ...... root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; try &#123; root.setView(view, wparams, panelParentView); &#125; ......&#125; 2.5、ViewRootImpl()构造过程：[ViewRootImpl.java # ViewRootImpl()] 1234567891011121314151617181920 final W mWindow; final Surface mSurface = new Surface(); final ViewRootHandler mHandler = new ViewRootHandler(); ...... public ViewRootImpl(Context context, Display display) &#123; mContext = context; mWindowSession = WindowManagerGlobal.getWindowSession();//IWindowSession的代理对象，该对象用于和WMS通信。 mDisplay = display; ...... mWindow = new W(this);//创建了一个W本地Binder对象，用于WMS通知应用程序进程 ...... mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this); ...... mViewConfiguration = ViewConfiguration.get(context); mDensity = context.getResources().getDisplayMetrics().densityDpi; mNoncompatDensity = context.getResources().getDisplayMetrics().noncompatDensityDpi; mFallbackEventHandler = new PhoneFallbackEventHandler(context); mChoreographer = Choreographer.getInstance();//Choreographer对象 ......&#125; 在ViewRootImpl的构造函数中初始化了一些成员变量，ViewRootImpl创建了以下几个主要对象： (1) 通过WindowManagerGlobal.getWindowSession()得到IWindowSession的代理对象，该对象用于和WMS通信。 (2) 创建了一个W本地Binder对象，用于WMS通知应用程序进程。 (3) 采用单例模式创建了一个Choreographer对象，用于统一调度窗口绘图。 (4) 创建ViewRootHandler对象，用于处理当前视图消息。 (5) 构造一个AttachInfo对象； (6) 创建Surface对象，用于绘制当前视图，当然该Surface对象的真正创建是由WMS来完成的，只不过是WMS传递给应用程序进程的。 2.6、IWindowSession代理获取过程[-&gt;WindowManagerGlobal.java] 12345678910111213141516171819202122232425 private static IWindowSession sWindowSession; public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; //获取输入法管理器 InputMethodManager imm = InputMethodManager.getInstance(); //获取窗口管理器 IWindowManager windowManager = getWindowManagerService(); //得到IWindowSession代理对象 sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123; @Override public void onAnimatorScaleChanged(float scale) &#123; ValueAnimator.setDurationScale(scale); &#125; &#125;, imm.getClient(), imm.getInputContext()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowSession; &#125;&#125; 以上函数通过WMS的openSession函数创建应用程序与WMS之间的连接通道，即获取IWindowSession代理对象，并将该代理对象保存到ViewRootImpl的静态成员变量sWindowSession中,因此在应用程序进程中有且只有一个IWindowSession代理对象。[-&gt;WindowManagerService.java] 12345678@Overridepublic IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client, IInputContext inputContext) &#123; if (client == null) throw new IllegalArgumentException(\"null client\"); if (inputContext == null) throw new IllegalArgumentException(\"null inputContext\"); Session session = new Session(this, callback, client, inputContext); return session;&#125; 在WMS服务端构造了一个Session实例对象。ViewRootImpl 是一很重要的类，类似 ActivityThread 负责跟AmS通信一样，ViewRootImpl 的一个重要职责就是跟 WmS 通信，它通静态变量 sWindowSession（IWindowSession实例）与 WmS 进行通信。每个应用进程，仅有一个 sWindowSession 对象，它对应了 WmS 中的 Session 子类，WmS 为每一个应用进程分配一个 Session 对象。WindowState 类有一个 IWindow mClient 参数，是在构造方法中赋值的，是由 Session 调用 addWindow 传递过来了，对应了 ViewRootImpl 中的 W 类的实例。 2.7、AttachInfo构造过程12345678910 AttachInfo(IWindowSession session, IWindow window, Display display, ViewRootImpl viewRootImpl, Handler handler, Callbacks effectPlayer) &#123; mSession = session;//IWindowSession代理对象，用于与WMS通信 mWindow = window;//W对象 mWindowToken = window.asBinder();//W本地Binder对象 mDisplay = display; mViewRootImpl = viewRootImpl;//ViewRootImpl实例 mHandler = handler;//ViewRootHandler对象 mRootCallbacks = effectPlayer;&#125; 2.8、创建Choreographer对象[-&gt;Choreographer.java] 123456789101112131415 // Thread local storage for the choreographer.private static final ThreadLocal&lt;Choreographer&gt; sThreadInstance = new ThreadLocal&lt;Choreographer&gt;() &#123; @Override protected Choreographer initialValue() &#123; Looper looper = Looper.myLooper(); if (looper == null) &#123; throw new IllegalStateException(\"The current thread must have a looper!\"); &#125; return new Choreographer(looper); &#125;&#125;;public static Choreographer getInstance() &#123; return sThreadInstance.get();&#125; 为调用线程创建一个Choreographer实例，调用线程必须具备消息循环功能，因为ViewRootImpl对象的构造是在应用程序进程的UI主线程中执行的，因此创建的Choreographer对象将使用UI线程消息队列。[-&gt;Choreographer.java] 12345678910111213141516 private Choreographer(Looper looper) &#123; mLooper = looper; //创建消息处理Handler mHandler = new FrameHandler(looper); //如果系统使用了Vsync机制，则注册一个FrameDisplayEventReceiver接收器 mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper) : null; mLastFrameTimeNanos = Long.MIN_VALUE; //屏幕刷新周期 mFrameIntervalNanos = (long)(1000000000 / getRefreshRate()); //创建回调数组 mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1]; //初始化数组 for (int i = 0; i &lt;= CALLBACK_LAST; i++) &#123; mCallbackQueues[i] = new CallbackQueue(); &#125;&#125; FrameDisplayEventReceiver详细过程以后再Android 7.1.2(Android N) Choreographer机制实现过程分析。 2.9、视图View添加过程窗口管理器WindowManagerImpl为当前添加的窗口创建好各种对象后，调用ViewRootImpl的setView函数向WMS服务添加一个窗口对象。[-&gt;ViewRootImpl.java] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; ////将DecorView保存到ViewRootImpl的成员变量mView中 mView = view; ...... mSoftInputMode = attrs.softInputMode; mWindowAttributesChanged = true; mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED; //同时将DecorView保存到mAttachInfo中 mAttachInfo.mRootView = view; mAttachInfo.mScalingRequired = mTranslator != null; mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale; if (panelParentView != null) &#123; mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken(); &#125; mAdded = true; int res; /* = WindowManagerImpl.ADD_OKAY; */ //1）在添加窗口前进行UI布局 requestLayout(); if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; mInputChannel = new InputChannel(); &#125; mForceDecorViewVisibility = (mWindowAttributes.privateFlags &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != 0; try &#123; mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); //2)将窗口添加到WMS服务中，mWindow为W本地Binder对象，通过Binder传输到WMS服务端后，变为IWindow代理对象 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; ...... //3)建立窗口消息通道 if (mInputChannel != null) &#123; if (mInputQueueCallback != null) &#123; mInputQueue = new InputQueue(); mInputQueueCallback.onInputQueueCreated(mInputQueue); &#125; mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); &#125; ...... &#125; &#125;&#125; 通过前面的分析可以知道，用户自定义的UI作为一个子View被添加到DecorView中，然后将顶级视图DecorView添加到应用程序进程的窗口管理器中，窗口管理器首先为当前添加的View创建一个ViewRootImpl对象、一个布局参数对象ViewGroup.LayoutParams，然后将这三个对象分别保存到当前应用程序进程的窗口管理器WindowManagerImpl中，最后通过ViewRootImpl对象将当前视图对象注册到WMS服务中。 ViewRootImpl的setView函数向WMS服务添加一个窗口对象过程： (1) requestLayout()在应用程序进程中进行窗口UI布局； (2) WindowSession.addToDisplay()向WMS服务注册一个窗口对象； (3) 注册应用程序进程端的消息接收通道； (1)、requestLayout()在应用程序进程中进行窗口UI布局；2.10、窗口UI布局过程requestLayout函数调用里面使用了Hanlder的一个小手段，那就是利用postSyncBarrier添加了一个Barrier（挡板），这个挡板的作用是阻塞普通的同步消息的执行，在挡板被撤销之前，只会执行异步消息，而requestLayout先添加了一个挡板Barrier，之后自己插入了一个异步任务mTraversalRunnable，其主要作用就是保证mTraversalRunnable在所有同步Message之前被执行，保证View绘制的最高优先级。具体实现如下： 123456789101112131415161718192021@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125;&#125; void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125; 2.10.1、添加回调过程[-&gt;Choreographer.java] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void postCallback(int callbackType, Runnable action, Object token) &#123; postCallbackDelayed(callbackType, action, token, 0);&#125;public void postCallbackDelayed(int callbackType, Runnable action, Object token, long delayMillis) &#123; ...... postCallbackDelayedInternal(callbackType, action, token, delayMillis);&#125;private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; ...... synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; //将要执行的回调封装成CallbackRecord对象，保存到mCallbackQueues数组中 mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125; private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; if (USE_VSYNC) &#123; if (isRunningOnLooperThreadLocked()) &#123; scheduleVsyncLocked(); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; final long nextFrameTime = Math.max( mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now); Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125; 消息处理： 12345678910111213141516171819202122232425 private final class FrameHandler extends Handler &#123; public FrameHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_DO_SCHEDULE_VSYNC: doScheduleVsync(); break; &#125; &#125;&#125; void doScheduleVsync() &#123; synchronized (mLock) &#123; if (mFrameScheduled) &#123; scheduleVsyncLocked(); &#125; &#125;&#125;private void scheduleVsyncLocked() &#123; //申请Vsync信号 mDisplayEventReceiver.scheduleVsync(); &#125; 在该函数中考虑了两种情况，一种是系统没有使用Vsync机制，在这种情况下，首先根据屏幕刷新频率计算下一次刷新时间，通过异步消息方式延时执行doFrame()函数实现屏幕刷新。如果系统使用了Vsync机制，并且当前线程具备消息循环，则直接请求Vsync信号，否则就通过主线程来请求Vsync信号。 2.10.2、Vsync请求过程我们知道在Choreographer构造函数中，构造了一个FrameDisplayEventReceiver对象，用于请求并接收Vsync信号，Vsync信号请求过程如下： 1234private void scheduleVsyncLocked() &#123; //申请Vsync信号 mDisplayEventReceiver.scheduleVsync(); &#125; [-&gt;DisplayEventReceiver.java] 12345678public void scheduleVsync() &#123; if (mReceiverPtr == 0) &#123; Log.w(TAG, \"Attempted to schedule a vertical sync pulse but the display event \" + \"receiver has already been disposed.\"); &#125; else &#123; nativeScheduleVsync(mReceiverPtr); &#125;&#125; [-&gt;android_view_DisplayEventReceiver.cpp ] 12345678910static void nativeScheduleVsync(JNIEnv* env, jclass clazz, jlong receiverPtr) &#123;sp&lt;NativeDisplayEventReceiver&gt; receiver = reinterpret_cast&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);status_t status = receiver-&gt;scheduleVsync();if (status) &#123; String8 message; message.appendFormat(\"Failed to schedule next vertical sync pulse. status=%d\", status); jniThrowRuntimeException(env, message.string());&#125;&#125; VSync请求过程又转交给了DisplayEventReceiver：[-&gt;DisplayEventReceiver.cpp] 1234567status_t DisplayEventReceiver::requestNextVsync() &#123;if (mEventConnection != NULL) &#123; mEventConnection-&gt;requestNextVsync(); return NO_ERROR;&#125;return NO_INIT;&#125; 这里又通过IDisplayEventConnection接口来请求Vsync信号，IDisplayEventConnection实现了Binder通信框架，可以跨进程调用，因为Vsync信号请求进程和Vsync产生进程有可能不在同一个进程空间，因此这里就借助IDisplayEventConnection接口来实现。下面通过图来梳理Vsync请求的调用流程： 需要说明的是/Vsync/之间的代码此时其实还未执行，call requestNextVsync()来告诉系统我要在下一个VSYNC需要被trigger. 继续ViewRootImpl的setView函数中的WindowSession.addToDisplay()。 (2) 、mWindowSession.addToDisplay()向WMS服务注册一个窗口对象；[Session.java] 1234567@Overridepublic int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outStableInsets, outOutsets, outInputChannel);&#125; [WindowManagerService.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; ...... boolean reportNewConfig = false; WindowState attachedWindow = null; long origId; final int callingUid = Binder.getCallingUid(); final int type = attrs.type; synchronized(mWindowMap) &#123; ...... final DisplayContent displayContent = getDisplayContentLocked(displayId); ...... boolean addToken = false; WindowToken token = mTokenMap.get(attrs.token); AppWindowToken atoken = null; boolean addToastWindowRequiresToken = false; ...... WindowState win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); return WindowManagerGlobal.ADD_APP_EXITING; &#125; ...... mPolicy.adjustWindowParamsLw(win.mAttrs); win.setShowToOwnerOnlyLocked(mPolicy.checkShowToOwnerOnly(attrs)); res = mPolicy.prepareAddWindowLw(win, attrs); ...... final boolean openInputChannels = (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0); if (openInputChannels) &#123; win.openInputChannel(outInputChannel); &#125; ...... if (addToken) &#123; mTokenMap.put(attrs.token, token); &#125; win.attach(); mWindowMap.put(client.asBinder(), win); ...... &#125; boolean imMayMove = true; if (type == TYPE_INPUT_METHOD) &#123; win.mGivenInsetsPending = true; mInputMethodWindow = win; addInputMethodWindowToListLocked(win); imMayMove = false; &#125; else if (type == TYPE_INPUT_METHOD_DIALOG) &#123; mInputMethodDialogs.add(win); addWindowToListInOrderLocked(win, true); moveInputMethodDialogsLocked(findDesiredInputMethodWindowIndexLocked(true)); imMayMove = false; &#125; else &#123; addWindowToListInOrderLocked(win, true); if (type == TYPE_WALLPAPER) &#123; mWallpaperControllerLocked.clearLastWallpaperTimeoutTime(); displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; &#125; else if ((attrs.flags&amp;FLAG_SHOW_WALLPAPER) != 0) &#123; displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; &#125; else if (mWallpaperControllerLocked.isBelowWallpaperTarget(win)) &#123; displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; &#125; &#125; ...... mInputMonitor.setUpdateInputWindowsNeededLw(); boolean focusChanged = false; if (win.canReceiveKeys()) &#123; focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS, false /*updateInputWindows*/); if (focusChanged) &#123; imMayMove = false; &#125; &#125; ...... mLayersController.assignLayersLocked(displayContent.getWindowList()); // Don't do layout here, the window must call // relayout to be displayed, so we'll do it there. if (focusChanged) &#123; mInputMonitor.setInputFocusLw(mCurrentFocus, false /*updateInputWindows*/); &#125; mInputMonitor.updateInputWindowsLw(false /*force*/); ...... &#125; if (reportNewConfig) &#123; sendNewConfiguration(); &#125; return res;&#125; 我们知道当应用程序进程添加一个DecorView到窗口管理器时，会为当前添加的窗口创建ViewRootImpl对象，同时构造了一个W本地Binder对象，无论是窗口视图对象DecorView还是ViewRootImpl对象，都只是存在于应用程序进程中，在添加窗口过程中仅仅将该窗口的W对象传递给WMS服务，经过Binder传输后，到达WMS服务端进程后变为IWindow.Proxy代理对象，因此该函数的参数client的类型为IWindow.Proxy。参数attrs的类型为WindowManager.LayoutParams，在应用程序进程启动Activity时，handleResumeActivity()函数通过WindowManager.LayoutParams l = r.window.getAttributes();来得到应用程序窗口布局参数，由于WindowManager.LayoutParams实现了Parcelable接口，因此WindowManager.LayoutParams对象可以跨进程传输，WMS服务的addWindow函数中的attrs参数就是应用程序进程发送过来的窗口布局参数。在WindowManagerImpl的addView函数中为窗口布局参数设置了相应的token，如果是应用程序窗口，则布局参数的token设为W本地Binder对象。如果不是应用程序窗口，同时当前窗口没有父窗口，则设置token为当前窗口的IApplicationToken.Proxy代理对象，否则设置为父窗口的IApplicationToken.Proxy代理对象，由于应用程序和WMS分属于两个不同的进程空间，因此经过Binder传输后，布局参数的令牌attrs.token就转变为IWindow.Proxy或者Token。以上函数首先根据布局参数的token等信息构造一个WindowToken对象，然后在构造一个WindowState对象，并将添加的窗口信息记录到mTokenMap和mWindowMap哈希表中。 在WMS服务端创建了所需对象后，接着调用了WindowState的attach()来进一步完成窗口添加。[WindowState.java] 123456void attach() &#123; if (WindowManagerService.localLOGV) Slog.v( TAG, \"Attaching \" + this + \" token=\" + mToken + \", list=\" + mToken.windows); mSession.windowAddedLocked();&#125; [Session.java] 1234567891011121314 void windowAddedLocked() &#123; if (mSurfaceSession == null) &#123; if (WindowManagerService.localLOGV) Slog.v( TAG_WM, \"First window added to \" + this + \", creating SurfaceSession\"); mSurfaceSession = new SurfaceSession(); if (SHOW_TRANSACTIONS) Slog.i( TAG_WM, \" NEW SURFACE SESSION \" + mSurfaceSession); mService.mSessions.add(this); if (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123; mService.dispatchNewAnimatorScaleLocked(this); &#125; &#125; mNumWindow++;&#125; SurfaceSession建立过程SurfaceSession对象承担了应用程序与SurfaceFlinger之间的通信过程，每一个需要与SurfaceFlinger进程交互的应用程序端都需要创建一个SurfaceSession对象。 客户端请求[SurfaceSession.java] 123public SurfaceSession() &#123; mNativeClient = nativeCreate();&#125; Java层的SurfaceSession对象构造过程会通过JNI在native层创建一个SurfaceComposerClient对象。 [android_view_SurfaceSession.cpp] 12345static jlong nativeCreate(JNIEnv* env, jclass clazz) &#123;SurfaceComposerClient* client = new SurfaceComposerClient();client-&gt;incStrong((void*)nativeCreate);return reinterpret_cast&lt;jlong&gt;(client);&#125; Java层的SurfaceSession对象与C++层的SurfaceComposerClient对象之间是一对一关系。[SurfaceComposerClient.cpp] 12345678910111213SurfaceComposerClient::SurfaceComposerClient(): mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;void SurfaceComposerClient::onFirstRef() &#123;//得到SurfaceFlinger的代理对象BpSurfaceComposer sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService());if (sm != 0) &#123; sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection(); if (conn != 0) &#123; mClient = conn; mStatus = NO_ERROR; &#125;&#125;&#125; SurfaceComposerClient继承于RefBase类，当第一次被强引用时，onFirstRef函数被回调，在该函数中SurfaceComposerClient会请求SurfaceFlinger为当前应用程序创建一个Client对象，专门接收该应用程序的请求，在SurfaceFlinger端创建好Client本地Binder对象后，将该Binder代理对象返回给应用程序端，并保存在SurfaceComposerClient的成员变量mClient中。 服务端处理在SurfaceFlinger服务端为应用程序创建交互的Client对象[SurfaceFlinger.cpp] 12345678910sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()&#123;sp&lt;ISurfaceComposerClient&gt; bclient;sp&lt;Client&gt; client(new Client(this));status_t err = client-&gt;initCheck();if (err == NO_ERROR) &#123; bclient = client;&#125;return bclient;&#125; /**Vsync**/ Vsync信号处理以上是请求过程，FrameDisplayEventReceiver对象用于请求并接收Vsync信号，当Vsync信号到来时，系统会自动调用其onVsync()函数，后面会回调到FrameDisplayEventReceiver.run方法（Why “同步分割栏”？再分析），再回调函数中执行doFrame()实现屏幕刷新。当VSYNC信号到达时，Choreographer doFrame()函数被调用[-&gt;Choreographer.java] 1234567891011121314151617181920212223242526272829303132333435363738void doFrame(long frameTimeNanos, int frame) &#123; final long startNanos; ...... long intendedFrameTimeNanos = frameTimeNanos; //保存起始时间 startNanos = System.nanoTime(); //由于Vsync事件处理采用的是异步方式，因此这里计算消息发送与函数调用开始之间所花费的时间 final long jitterNanos = startNanos - frameTimeNanos; //计算函数调用期间所错过的帧数 if (jitterNanos &gt;= mFrameIntervalNanos) &#123; final long skippedFrames = jitterNanos / mFrameIntervalNanos; if (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123; Log.i(TAG, \"Skipped \" + skippedFrames + \" frames! \" + \"The application may be doing too much work on its main thread.\"); &#125; final long lastFrameOffset = jitterNanos % mFrameIntervalNanos; frameTimeNanos = startNanos - lastFrameOffset; &#125; //如果frameTimeNanos小于一个屏幕刷新周期，则重新请求VSync信号 if (frameTimeNanos &lt; mLastFrameTimeNanos) &#123; scheduleVsyncLocked(); return; &#125; mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos); mFrameScheduled = false; mLastFrameTimeNanos = frameTimeNanos; &#125; try &#123; //分别回调CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL、CALLBACK_COMMIT事件 doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); &#125;&#125; Choreographer类中分别定义了CallbackRecord、CallbackQueue内部类，CallbackQueue是一个按时间先后顺序保存CallbackRecord的单向循环链表。在Choreographer中定义了三个CallbackQueue队列，用数组mCallbackQueues表示，用于分别保存CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL这三种类型的Callback，当调用Choreographer类的postCallback()函数时，就是往指定类型的CallbackQueue队列中通过addCallbackLocked()函数添加一个CallbackRecord项：首先构造一个CallbackRecord对象，然后按时间先后顺序插入到CallbackQueue链表中。从代码注释中，我们可以知道CALLBACK_INPUT是指输入回调，该回调优先级最高，首先得到执行，而CALLBACK_TRAVERSAL是指处理布局和绘图的回调，只有在所有异步消息都执行完后才得到执行，CALLBACK_ANIMATION是指动画回调，比CALLBACK_TRAVERSAL优先执行，从doFrame()函数中的doCallbacks调用就能印证这点。当Vsync事件到来时，顺序执行CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL 和CALLBACK_COMMIT 对应CallbackQueue队列中注册的回调。[-&gt;Choreographer.java] 12345678910111213141516171819202122232425262728293031323334353637 void doCallbacks(int callbackType, long frameTimeNanos) &#123; CallbackRecord callbacks; synchronized (mLock) &#123; final long now = System.nanoTime(); //从指定类型的CallbackQueue队列中查找执行时间到的CallbackRecord callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked( now / TimeUtils.NANOS_PER_MS); ...... if (callbackType == Choreographer.CALLBACK_COMMIT) &#123; final long jitterNanos = now - frameTimeNanos; if (jitterNanos &gt;= 2 * mFrameIntervalNanos) &#123; final long lastFrameOffset = jitterNanos % mFrameIntervalNanos + mFrameIntervalNanos; mDebugPrintNextFrameTimeDelta = true; &#125; frameTimeNanos = now - lastFrameOffset; mLastFrameTimeNanos = frameTimeNanos; &#125; &#125; &#125; try &#123; for (CallbackRecord c = callbacks; c != null; c = c.next) &#123; //由于CallbackQueues是按时间先后顺序排序的，因此遍历执行所有时间到的CallbackRecord c.run(frameTimeNanos); &#125; &#125; finally &#123; synchronized (mLock) &#123; mCallbacksRunning = false; do &#123; final CallbackRecord next = callbacks.next; recycleCallbackLocked(callbacks); callbacks = next; &#125; while (callbacks != null); &#125; &#125;&#125; 我们知道Choreographer对外提供了两个接口函数用于注册指定的Callback，postCallback()用于注册Runnable对象，而postFrameCallback()函数用于注册FrameCallback对象，无论注册的是Runnable对象还是FrameCallback对象，在CallbackRecord对象中统一装箱为Object类型。在执行其回调函数时，就需要区别这两种对象类型，如果注册的是Runnable对象，则调用其run()函数，如果注册的是FrameCallback对象，则调用它的doFrame()函数。 2.11、视图View添加过程 关于Choreographer的postCallback()用法在前面进行了详细的介绍，当Vsync事件到来时，mTraversalRunnable对象的run()函数将被调用。 mTraversalRunnable对象的类型为TraversalRunnable，该类实现了Runnable接口，在其run()函数中调用了doTraversal()函数来完成窗口布局。[-&gt;ViewRootImpl.java] 123456789101112131415161718192021222324 final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable();void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing(\"ViewAncestor\"); &#125; performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125;&#125; performTraversals函数相当复杂，其主要实现以下几个重要步骤： 1.执行窗口测量； 2.执行窗口注册； 3.执行窗口布局； 4.执行窗口绘图； [-&gt;ViewRootImpl.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143 private void performTraversals() &#123; ...... final View host = mView; mIsInTraversal = true; mWillDrawSoon = true; boolean windowSizeMayChange = false; boolean newSurface = false; boolean surfaceChanged = false; WindowManager.LayoutParams lp = mWindowAttributes; int desiredWindowWidth; int desiredWindowHeight; final int viewVisibility = getHostVisibility(); final boolean viewVisibilityChanged = !mFirst &amp;&amp; (mViewVisibility != viewVisibility || mNewSurfaceNeeded); final boolean viewUserVisibilityChanged = !mFirst &amp;&amp; ((mViewVisibility == View.VISIBLE) != (viewVisibility == View.VISIBLE)); WindowManager.LayoutParams params = null; if (mWindowAttributesChanged) &#123; mWindowAttributesChanged = false; surfaceChanged = true; params = lp; &#125; ...... /****************执行窗口测量******************/ boolean layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw); if (layoutRequested) &#123; windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight); &#125; ...... /****************向WMS服务添加窗口******************/ if (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != null || mForceNextWindowRelayout) &#123; ...... try &#123; ...... relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); ...... &#125; catch (RemoteException e) &#123; &#125; ...... if (!mStopped || mReportNextDraw) &#123; ...... // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ...... &#125; &#125; &#125; else &#123; ...... &#125; /****************执行窗口布局******************/ final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw); boolean triggerGlobalLayoutListener = didLayout || mAttachInfo.mRecomputeGlobalAttributes; if (didLayout) &#123; performLayout(lp, mWidth, mHeight); ...... &#125; /****************查找窗口焦点******************/ if (mFirst) &#123; ...... if (mView != null) &#123; if (!mView.hasFocus()) &#123; mView.requestFocus(View.FOCUS_FORWARD); &#125; else &#123;&#125; &#125; &#125; final boolean changedVisibility = (viewVisibilityChanged || mFirst) &amp;&amp; isViewVisible; final boolean hasWindowFocus = mAttachInfo.mHasWindowFocus &amp;&amp; isViewVisible; final boolean regainedFocus = hasWindowFocus &amp;&amp; mLostWindowFocus; if (regainedFocus) &#123; mLostWindowFocus = false; &#125; else if (!hasWindowFocus &amp;&amp; mHadWindowFocus) &#123; mLostWindowFocus = true; &#125; if (changedVisibility || regainedFocus) &#123; // Toasts are presented as notifications - don't present them as windows as well boolean isToast = (mWindowAttributes == null) ? false : (mWindowAttributes.type == WindowManager.LayoutParams.TYPE_TOAST); if (!isToast) &#123; host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED); &#125; &#125; mFirst = false; mWillDrawSoon = false; mNewSurfaceNeeded = false; mActivityRelaunched = false; mViewVisibility = viewVisibility; mHadWindowFocus = hasWindowFocus; if (hasWindowFocus &amp;&amp; !isInLocalFocusMode()) &#123; final boolean imTarget = WindowManager.LayoutParams .mayUseInputMethod(mWindowAttributes.flags); if (imTarget != mLastWasImTarget) &#123; mLastWasImTarget = imTarget; InputMethodManager imm = InputMethodManager.peekInstance(); if (imm != null &amp;&amp; imTarget) &#123; imm.onPreWindowFocus(mView, hasWindowFocus); imm.onPostWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags); &#125; &#125; &#125; // Remember if we must report the next draw. if ((relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) &#123; mReportNextDraw = true; &#125; /****************执行窗口绘制******************/ boolean cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible; if (!cancelDraw &amp;&amp; !newSurface) &#123; if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).startChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; performDraw(); &#125; else &#123; if (isViewVisible) &#123; // Try again scheduleTraversals(); &#125; else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).endChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; &#125; mIsInTraversal = false;&#125; 1、执行窗口测量performMeasure()[-&gt;ViewRootImpl.java] 12345678 private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 2、执行窗口注册relayoutWindow；[-&gt;ViewRootImpl.java] 12345678910111213141516 private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending) throws RemoteException &#123; ...... int relayoutResult = mWindowSession.relayout( mWindow, mSeq, params, (int) (mView.getMeasuredWidth() * appScale + 0.5f), (int) (mView.getMeasuredHeight() * appScale + 0.5f), viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0, mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets, mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration, mSurface); ...... return relayoutResult;&#125; 这里通过前面获取的IWindowSession代理对象请求WMS服务执行窗口布局，mSurface是ViewRootImpl的成员变量[-&gt;ViewRootImpl.java] 1final Surface mSurface = new Surface(); [-&gt;Surface.java] 123456/** * Create an empty surface, which will later be filled in by readFromParcel(). * @hide */public Surface() &#123;&#125; 该Surface构造函数仅仅创建了一个空Surface对象，并没有对该Surface进程native层的初始化，到此我们知道应用程序进程为每个窗口对象都创建了一个Surface对象。并且将该Surface通过跨进程方式传输给WMS服务进程，我们知道，在Android系统中，如果一个对象需要在不同进程间传输，必须实现Parcelable接口，Surface类正好实现了Parcelable接口。ViewRootImpl通过IWindowSession接口请求WMS的完整过程如下： [-&gt;IWindowSession.java$ Proxy] 123456789101112131415161718192021/** This file is auto-generated. DO NOT MODIFY* * Original file: frameworks/base/core/java/android/view/IWindowSession.aidl*/@Override public int relayout(android.view.IWindow window, int seq, android.view.WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, android.graphics.Rect outFrame, android.graphics.Rect outOverscanInsets, android.graphics.Rect outContentInsets, android.graphics.Rect outVisibleInsets, android.graphics.Rect outStableInsets, android.graphics.Rect outOutsets, android.graphics.Rect outBackdropFrame, android.content.res.Configuration outConfig, android.view.Surface outSurface) throws android.os.RemoteException &#123;android.os.Parcel _data = android.os.Parcel.obtain();android.os.Parcel _reply = android.os.Parcel.obtain();int _result;try &#123; ...... mRemote.transact(Stub.TRANSACTION_relayout, _data, _reply, 0); ...... if ((0 != _reply.readInt())) &#123; outSurface.readFromParcel(_reply); &#125;&#125; finally &#123; ......&#125;return _result;&#125; 从该函数的实现可以看出，应用程序进程中创建的Surface对象并没有传递到WMS服务进程，只是读取WMS服务进程返回来的Surface。那么WMS服务进程是如何响应应用程序进程布局请求的呢？ [-&gt;IWindowSession.java$ Stub] 1234567891011121314151617181920@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException&#123;switch (code)&#123;case TRANSACTION_relayout: &#123; ...... android.view.Surface _arg15; _arg15 = new android.view.Surface(); int _result = this.relayout(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13, _arg14, _arg15); reply.writeNoException(); reply.writeInt(_result); ...... if ((_arg15!=null)) &#123; reply.writeInt(1); _arg15.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; return true; &#125;&#125; 该函数可以看出，WMS服务在响应应用程序进程请求添加窗口时，首先在当前进程空间创建一个Surface对象，然后调用Session的relayout()函数进一步完成窗口添加过程，最后将WMS服务中创建的Surface返回给应用程序进程。 到目前为止，在应用程序进程和WMS服务进程分别创建了一个Surface对象，但是他们调用的都是Surface的无参构造函数，在该构造函数中并未真正初始化native层的Surface，那native层的Surface是在那里创建的呢？ [-&gt;Session.java] 1234567891011 public int relayout(IWindow window, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewFlags, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame, Configuration outConfig, Surface outSurface) &#123; int res = mService.relayoutWindow(this, window, seq, attrs, requestedWidth, requestedHeight, viewFlags, flags, outFrame, outOverscanInsets, outContentInsets, outVisibleInsets, outStableInsets, outsets, outBackdropFrame, outConfig, outSurface); return res;&#125; [-&gt;WindowManagerService.java] 1234567891011121314151617181920212223242526 public int relayoutWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame, Configuration outConfig, Surface outSurface) &#123; int result = 0; ...... if (viewVisibility == View.VISIBLE &amp;&amp; (win.mAppToken == null || !win.mAppToken.clientHidden)) &#123; result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges, oldVisibility); try &#123; result = createSurfaceControl(outSurface, result, win, winAnimator); &#125; catch (Exception e) &#123; ...... return 0; &#125; ...... &#125; else &#123; ...... &#125; ...... return result;&#125; [-&gt;WindowManagerService.java] 12345678910111213 private int createSurfaceControl(Surface outSurface, int result, WindowState win, WindowStateAnimator winAnimator) &#123; if (!win.mHasSurface) &#123; result |= RELAYOUT_RES_SURFACE_CHANGED; &#125; WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked(); if (surfaceController != null) &#123; surfaceController.getSurface(outSurface); &#125; else &#123; outSurface.release(); &#125; return result;&#125; [-&gt;WindowSurfaceController.java] 123 void getSurface(Surface outSurface) &#123; outSurface.copyFrom(mSurfaceControl);&#125; [-&gt;WindowStateAnimator.java] 123456789101112 WindowSurfaceController createSurfaceLocked() &#123; ...... try &#123; ...... mSurfaceController = new WindowSurfaceController(mSession.mSurfaceSession, attrs.getTitle().toString(), width, height, format, flags, this); w.setHasSurface(true); &#125; ...... return mSurfaceController;&#125; [-&gt;WindowSurfaceController.java] 123456789101112131415public WindowSurfaceController(SurfaceSession s, String name, int w, int h, int format, int flags, WindowStateAnimator animator) &#123; mAnimator = animator; mSurfaceW = w; mSurfaceH = h; ...... if (animator.mWin.isChildWindow() &amp;&amp; animator.mWin.mSubLayer &lt; 0 &amp;&amp; animator.mWin.mAppToken != null) &#123; ...... &#125; else &#123; mSurfaceControl = new SurfaceControl( s, name, w, h, format, flags); &#125;&#125; 2.12、Surface创建过程[-&gt;SurfaceControl.java] 1234567 public SurfaceControl(SurfaceSession session, String name, int w, int h, int format, int flags) throws OutOfResourcesException &#123; ...... mNativeObject = nativeCreate(session, name, w, h, format, flags); ......&#125; [-&gt;android_view_SurfaceControl.cpp] 12345678910111213static jlong nativeCreate(JNIEnv* env, jclass clazz, jobject sessionObj, jstring nameStr, jint w, jint h, jint format, jint flags) &#123;ScopedUtfChars name(env, nameStr);sp&lt;SurfaceComposerClient&gt; client(android_view_SurfaceSession_getClient(env, sessionObj));sp&lt;SurfaceControl&gt; surface = client-&gt;createSurface( String8(name.c_str()), w, h, format, flags);if (surface == NULL) &#123; jniThrowException(env, OutOfResourcesException, NULL); return 0;&#125;surface-&gt;incStrong((void *)nativeCreate);return reinterpret_cast&lt;jlong&gt;(surface.get());&#125; 该函数首先得到前面创建好的SurfaceComposerClient对象，通过该对象向SurfaceFlinger端的Client对象发送创建Surface的请求，最后得到一个SurfaceControl对象。[-&gt;SurfaceComposerClient.cpp] 1234567891011121314151617181920sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags) &#123;sp&lt;SurfaceControl&gt; sur;if (mStatus == NO_ERROR) &#123; sp&lt;IBinder&gt; handle; sp&lt;IGraphicBufferProducer&gt; gbp; status_t err = mClient-&gt;createSurface(name, w, h, format, flags, &amp;handle, &amp;gbp); ALOGE_IF(err, \"SurfaceComposerClient::createSurface error %s\", strerror(-err)); if (err == NO_ERROR) &#123; sur = new SurfaceControl(this, handle, gbp); &#125;&#125;return sur;&#125; SurfaceComposerClient将Surface创建请求转交给保存在其成员变量中的Bp SurfaceComposerClient对象来完成，在SurfaceFlinger端的Client本地对象会返回一个ISurface代理对象给应用程序，通过该代理对象为应用程序当前创建的Surface创建一个SurfaceControl对象。[ISurfaceComposerClient.cpp] 1234567891011 virtual status_t createSurface(const String8&amp; name, uint32_t width, uint32_t height, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) &#123; Parcel data, reply; ...... remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply); *handle = reply.readStrongBinder(); *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder()); return reply.readInt32();&#125; [Client.cpp]MessageCreateSurface消息是专门为应用程序请求创建Surface而定义的一种消息类型： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 status_t Client::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123; /* * createSurface must be called from the GL thread so that it can * have access to the GL context. */ class MessageCreateLayer : public MessageBase &#123; SurfaceFlinger* flinger; Client* client; sp&lt;IBinder&gt;* handle; sp&lt;IGraphicBufferProducer&gt;* gbp; status_t result; const String8&amp; name; uint32_t w, h; PixelFormat format; uint32_t flags; public: MessageCreateLayer(SurfaceFlinger* flinger, const String8&amp; name, Client* client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) : flinger(flinger), client(client), handle(handle), gbp(gbp), result(NO_ERROR), name(name), w(w), h(h), format(format), flags(flags) &#123; &#125; status_t getResult() const &#123; return result; &#125; virtual bool handler() &#123; result = flinger-&gt;createLayer(name, client, w, h, format, flags, handle, gbp); return true; &#125; &#125;; sp&lt;MessageBase&gt; msg = new MessageCreateLayer(mFlinger.get(), name, this, w, h, format, flags, handle, gbp); mFlinger-&gt;postMessageSync(msg); return static_cast&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult(); &#125;Client将应用程序创建Surface的请求转换为异步消息投递到SurfaceFlinger的消息队列中，将创建Surface的任务转交给SurfaceFlinger。[-&gt;SurfaceFlinger.cpp] status_t SurfaceFlinger::createLayer( const String8&amp; name, const sp&lt;Client&gt;&amp; client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123; //ALOGD(\"createLayer for (%d x %d), name=%s\", w, h, name.string()); ...... status_t result = NO_ERROR; sp&lt;Layer&gt; layer; ////根据flags创建不同类型的layer switch (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123; case ISurfaceComposerClient::eFXSurfaceNormal: result = createNormalLayer(client, name, w, h, flags, format, handle, gbp, &amp;layer); break; case ISurfaceComposerClient::eFXSurfaceDim: result = createDimLayer(client, name, w, h, flags, handle, gbp, &amp;layer); break; default: result = BAD_VALUE; break; &#125; if (result != NO_ERROR) &#123; return result; &#125; //将创建好的Layer对象保存在Client中 result = addClientLayer(client, *handle, *gbp, layer); if (result != NO_ERROR) &#123; return result; &#125; setTransactionFlags(eTransactionNeeded); return result; &#125; SurfaceFlinger根据标志位创建对应类型的Surface，当前系统定义了2种类型的Layer: [-&gt;ISurfaceComposerClient.h] 12eFXSurfaceNormal = 0x00000000,eFXSurfaceDim = 0x00020000, [-&gt;SurfaceFlinger.cpp] 123456789101112131415161718192021222324status_t SurfaceFlinger::createNormalLayer(const sp&lt;Client&gt;&amp; client, const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat&amp; format, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)&#123;// initialize the surfacesswitch (format) &#123;case PIXEL_FORMAT_TRANSPARENT:case PIXEL_FORMAT_TRANSLUCENT: format = PIXEL_FORMAT_RGBA_8888; break;case PIXEL_FORMAT_OPAQUE: format = PIXEL_FORMAT_RGBX_8888; break;&#125;//在SurfaceFlinger端为应用程序的Surface创建对应的Layer对象 *outLayer = new Layer(this, client, name, w, h, flags);status_t err = (*outLayer)-&gt;setBuffers(w, h, format, flags);if (err == NO_ERROR) &#123; *handle = (*outLayer)-&gt;getHandle(); *gbp = (*outLayer)-&gt;getProducer();&#125;ALOGE_IF(err, \"createNormalLayer() failed (%s)\", strerror(-err));return err;&#125; 在SurfaceFlinger服务端为应用程序创建的Surface创建对应的Layer对象。应用程序请求创建Surface过程如下： 第一次强引用Layer对象时，onFirstRef()函数被回调[Layer.cpp] 123456789101112131415161718192021void Layer::onFirstRef() &#123;// Creates a custom BufferQueue for SurfaceFlingerConsumer to usesp&lt;IGraphicBufferProducer&gt; producer;sp&lt;IGraphicBufferConsumer&gt; consumer;//创建BufferQueue对象BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);mProducer = new MonitoredProducer(producer, mFlinger);mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName, this);mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(0));mSurfaceFlingerConsumer-&gt;setContentsChangedListener(this);mSurfaceFlingerConsumer-&gt;setName(mName);#ifdef TARGET_DISABLE_TRIPLE_BUFFERING#warning \"disabling triple buffering\"#elsemProducer-&gt;setMaxDequeuedBufferCount(2);#endifconst sp&lt;const DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());updateTransformHint(hw);&#125; 根据buffer可用监听器的注册过程，我们知道，当生产者也就是应用程序填充好图形buffer数据后，通过回调方式通知消费者的 BufferQueue构造过程[-&gt;BufferQueue.cpp] 1234567891011void BufferQueue::createBufferQueue(sp&lt;IGraphicBufferProducer&gt;* outProducer, sp&lt;IGraphicBufferConsumer&gt;* outConsumer, const sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) &#123;......sp&lt;BufferQueueCore&gt; core(new BufferQueueCore(allocator));sp&lt;IGraphicBufferProducer&gt; producer(new BufferQueueProducer(core));sp&lt;IGraphicBufferConsumer&gt; consumer(new BufferQueueConsumer(core));*outProducer = producer;*outConsumer = consumer;&#125; [-&gt;BufferQueueCore.cpp]所以核心都是这个BufferQueueCore，他是管理图形缓冲区的中枢。这里举一个SurfaceTexture的例子，来看看他们之间的关系： 123456789101112131415161718192021BufferQueueCore::BufferQueueCore(const sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) :mAllocator(allocator),......&#123;if (allocator == NULL) &#123; sp&lt;ISurfaceComposer&gt; composer(ComposerService::getComposerService()); mAllocator = composer-&gt;createGraphicBufferAlloc(); if (mAllocator == NULL) &#123; BQ_LOGE(\"createGraphicBufferAlloc failed\"); &#125;&#125;int numStartingBuffers = getMaxBufferCountLocked();for (int s = 0; s &lt; numStartingBuffers; s++) &#123; mFreeSlots.insert(s);&#125;for (int s = numStartingBuffers; s &lt; BufferQueueDefs::NUM_BUFFER_SLOTS; s++) &#123; mUnusedSlots.push_front(s);&#125;&#125; BufferQueueCore类中定义了一个64项的数据mSlots，是一个容量大小为64的数组，因此BufferQueueCore可以管理最多64块的GraphicBuffer。 [-&gt;ISurfaceComposer.cpp] 1234567 virtual sp&lt;IGraphicBufferAlloc&gt; createGraphicBufferAlloc()&#123; Parcel data, reply; data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor()); remote()-&gt;transact(BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, data, &amp;reply); return interface_cast&lt;IGraphicBufferAlloc&gt;(reply.readStrongBinder());&#125; [-&gt;SurfaceFlinger.cpp] 12345sp&lt;IGraphicBufferAlloc&gt; SurfaceFlinger::createGraphicBufferAlloc()&#123;sp&lt;GraphicBufferAlloc&gt; gba(new GraphicBufferAlloc());return gba;&#125; GraphicBufferAlloc构造过程[-&gt;GraphicBufferAlloc.cpp] 123456789sp&lt;GraphicBuffer&gt; GraphicBufferAlloc::createGraphicBuffer(uint32_t width, uint32_t height, PixelFormat format, uint32_t usage, std::string requestorName, status_t* error) &#123;sp&lt;GraphicBuffer&gt; graphicBuffer(new GraphicBuffer( width, height, format, usage, std::move(requestorName)));status_t err = graphicBuffer-&gt;initCheck();......return graphicBuffer;&#125; 图形缓冲区创建过程[-&gt;GraphicBuffer.cpp] 1234567891011121314GraphicBuffer::GraphicBuffer(uint32_t inWidth, uint32_t inHeight, PixelFormat inFormat, uint32_t inUsage, std::string requestorName): BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()), mInitCheck(NO_ERROR), mId(getUniqueId()), mGenerationNumber(0) &#123;width =height =stride =format =usage = 0;handle = NULL;mInitCheck = initSize(inWidth, inHeight, inFormat, inUsage, std::move(requestorName)); &#125; 根据图形buffer的宽高、格式等信息为图形缓冲区分配存储空间。 使用GraphicBufferAllocator对象来为图形缓冲区分配内存空间，GraphicBufferAllocator是对Gralloc模块中的gpu设备的封装类。关于GraphicBufferAllocator内存分配过程请查看Android图形缓冲区分配过程源码分析图形缓冲区分配完成后，还会映射到SurfaceFlinger服务进程的虚拟地址空间。 Android图形缓冲区分配过程源码分析[-&gt;Layer.cpp] 123456789101112131415Layer::Layer(SurfaceFlinger* flinger, const sp&lt;Client&gt;&amp; client, const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags): contentDirty(false), sequence(uint32_t(android_atomic_inc(&amp;sSequence))), mFlinger(flinger), mTextureName(-1U), mPremultipliedAlpha(true), mName(\"unnamed\"), mFormat(PIXEL_FORMAT_NONE), ......&#123;mCurrentCrop.makeInvalid();mFlinger-&gt;getRenderEngine().genTextures(1, &amp;mTextureName);mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);......&#125; 到此才算真正创建了一个可用于绘图的Surface (Layer)，从上面的分析我们可以看出，在WMS服务进程端，其实创建了两个Java层的Surface对象，第一个Surface使用了无参构造函数，仅仅构造一个Surface对象而已，而第二个Surface却使用了有参构造函数，参数指定了图象宽高等信息，这个Java层Surface对象还会在native层请求SurfaceFlinger创建一个真正能用于绘制图象的native层Surface。最后通过浅拷贝的方式将第二个Surface复制到第一个Surface中，最后通过writeToParcel方式写回到应用程序进程。到目前为止，应用程序和WMS一共创建了3个Java层Surface对象[更正：图示3号为SurfaceControl]，如上图所示，而真正能用于绘图的Surface只有3号，那么3号Surface与2号Surface之间是什么关系呢？outSurface.copyFrom(surface)[Surface.java] 12345678910111213 public void copyFrom(SurfaceControl other) &#123; ...... long surfaceControlPtr = other.mNativeObject; ...... long newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr); synchronized (mLock) &#123; if (mNativeObject != 0) &#123; nativeRelease(mNativeObject); &#125; setNativeObjectLocked(newNativeObject); &#125;&#125; [android_view_Surface.cpp] 123456789101112131415static jlong nativeCreateFromSurfaceControl(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj) &#123;/* * This is used by the WindowManagerService just after constructing * a Surface and is necessary for returning the Surface reference to * the caller. At this point, we should only have a SurfaceControl. */sp&lt;SurfaceControl&gt; ctrl(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj));sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());if (surface != NULL) &#123; surface-&gt;incStrong(&amp;sRefBaseOwner);&#125;return reinterpret_cast&lt;jlong&gt;(surface.get());&#125; 2号Surface引用到了3号Surface的SurfaceControl对象后，通过writeToParcel()函数写会到应用程序进程。[Surface.java] 12345678910111213141516 @Overridepublic void writeToParcel(Parcel dest, int flags) &#123; if (dest == null) &#123; throw new IllegalArgumentException(\"dest must not be null\"); &#125; synchronized (mLock) &#123; // NOTE: This must be kept synchronized with the native parceling code // in frameworks/native/libs/Surface.cpp dest.writeString(mName); dest.writeInt(mIsSingleBuffered ? 1 : 0); nativeWriteToParcel(mNativeObject, dest); &#125; if ((flags &amp; Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) &#123; release(); &#125;&#125; [android_view_Surface.cpp] 12345678910111213141516static void nativeWriteToParcel(JNIEnv* env, jclass clazz, jlong nativeObject, jobject parcelObj) &#123;Parcel* parcel = parcelForJavaObject(env, parcelObj);if (parcel == NULL) &#123; doThrowNPE(env); return;&#125;sp&lt;Surface&gt; self(reinterpret_cast&lt;Surface *&gt;(nativeObject));android::view::Surface surfaceShim;if (self != nullptr) &#123; surfaceShim.graphicBufferProducer = self-&gt;getIGraphicBufferProducer();&#125;// Calling code in Surface.java has already written the name of the Surface// to the ParcelsurfaceShim.writeToParcel(parcel, /*nameAlreadyWritten*/true);&#125; 应用程序进程中的1号Surface按相反顺序读取WMS服务端返回过来的Binder对象等数据，并构造一个native层的Surface对象。 1234567891011121314151617 public void readFromParcel(Parcel source) &#123; if (source == null) &#123; throw new IllegalArgumentException(\"source must not be null\"); &#125; synchronized (mLock) &#123; // nativeReadFromParcel() will either return mNativeObject, or // create a new native Surface and return it after reducing // the reference count on mNativeObject. Either way, it is // not necessary to call nativeRelease() here. // NOTE: This must be kept synchronized with the native parceling code // in frameworks/native/libs/Surface.cpp mName = source.readString(); mIsSingleBuffered = source.readInt() != 0; setNativeObjectLocked(nativeReadFromParcel(mNativeObject, source)); &#125;&#125; 应用程序进程中的1号Surface按相反顺序读取WMS服务端返回过来的Binder对象等数据，并构造一个native层的Surface对象。 123456789101112131415static jlong nativeCreateFromSurfaceControl(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj) &#123;/* * This is used by the WindowManagerService just after constructing * a Surface and is necessary for returning the Surface reference to * the caller. At this point, we should only have a SurfaceControl. */sp&lt;SurfaceControl&gt; ctrl(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj));sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());if (surface != NULL) &#123; surface-&gt;incStrong(&amp;sRefBaseOwner);&#125;return reinterpret_cast&lt;jlong&gt;(surface.get());&#125; 每个Activity可以有一个或多个Surface，默认情况下一个Activity只有一个Surface，当Activity中使用SurfaceView时，就存在多个Surface。Activity默认surface是在relayoutWindow过程中由WMS服务创建的，然后回传给应用程序进程，我们知道一个Surface其实就是应用程序端的本地窗口，关于Surface的初始化过程这里就不在介绍。 应用程序本地窗口Surface创建过程从前面分析可知，SurfaceFlinger在处理应用程序请求创建Surface中，在SurfaceFlinger服务端仅仅创建了Layer对象，那么应用程序本地窗口Surface在什么时候、什么地方创建呢？ 为应用程序创建好了Layer对象并返回ISurface的代理对象给应用程序，应用程序通过该代理对象创建了一个SurfaceControl对象，Java层Surface需要通过android_view_Surface.cpp中的JNI函数来操作native层的Surface，在操作native层Surface前，首先需要获取到native的Surface，应用程序本地窗口Surface就是在这个时候创建的。[-&gt;SurfaceControl.cpp] 12345678910sp&lt;Surface&gt; SurfaceControl::getSurface() const&#123;Mutex::Autolock _l(mLock);if (mSurfaceData == 0) &#123; // This surface is always consumed by SurfaceFlinger, so the // producerControlledByApp value doesn't matter; using false. mSurfaceData = new Surface(mGraphicBufferProducer, false);&#125;return mSurfaceData;&#125; [Surface.cpp] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Surface::Surface( const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer, bool controlledByApp): mGraphicBufferProducer(bufferProducer), mCrop(Rect::EMPTY_RECT), mGenerationNumber(0), mSharedBufferMode(false), mAutoRefresh(false), mSharedBufferSlot(BufferItem::INVALID_BUFFER_SLOT), mSharedBufferHasBeenQueued(false), mNextFrameNumber(1) &#123;// Initialize the ANativeWindow function pointers.ANativeWindow::setSwapInterval = hook_setSwapInterval;ANativeWindow::dequeueBuffer = hook_dequeueBuffer;ANativeWindow::cancelBuffer = hook_cancelBuffer;ANativeWindow::queueBuffer = hook_queueBuffer;ANativeWindow::query = hook_query;ANativeWindow::perform = hook_perform;ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;ANativeWindow::cancelBuffer_DEPRECATED = hook_cancelBuffer_DEPRECATED;ANativeWindow::lockBuffer_DEPRECATED = hook_lockBuffer_DEPRECATED;ANativeWindow::queueBuffer_DEPRECATED = hook_queueBuffer_DEPRECATED;const_cast&lt;int&amp;&gt;(ANativeWindow::minSwapInterval) = 0;const_cast&lt;int&amp;&gt;(ANativeWindow::maxSwapInterval) = 1;mReqWidth = 0;mReqHeight = 0;mReqFormat = 0;mReqUsage = 0;mTimestamp = NATIVE_WINDOW_TIMESTAMP_AUTO;mDataSpace = HAL_DATASPACE_UNKNOWN;mScalingMode = NATIVE_WINDOW_SCALING_MODE_FREEZE;mTransform = 0;mStickyTransform = 0;mDefaultWidth = 0;mDefaultHeight = 0;mUserWidth = 0;mUserHeight = 0;mTransformHint = 0;mConsumerRunningBehind = false;mConnectedToCpu = false;mProducerControlledByApp = controlledByApp;mSwapIntervalZero = false;&#125; 在创建完应用程序本地窗口Surface后，想要在该Surface上绘图，首先需要为该Surface分配图形buffer。我们前面介绍了Android应用程序图形缓冲区的分配都是由SurfaceFlinger服务进程来完成，在请求创建Surface时，在服务端创建了一个BufferQueue本地Binder对象，该对象负责管理应用程序一个本地窗口Surface的图形缓冲区。 3、执行窗口布局performLayout() [-&gt;ViewRootImpl.java] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; mLayoutRequested = false; mScrollMayChange = true; mInLayout = true; final View host = mView; try &#123; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mInLayout = false; int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) &#123; // requestLayout() was called during layout. // If no layout-request flags are set on the requesting views, there is no problem. // If some requests are still pending, then we need to clear those flags and do // a full request/measure/layout pass to handle this situation. ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, false); if (validLayoutRequesters != null) &#123; // Set this flag to indicate that any further requests are happening during // the second pass, which may result in posting those requests to the next // frame instead mHandlingLayoutInLayoutRequest = true; // Process fresh layout requests, then measure and layout int numValidRequests = validLayoutRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) &#123; final View view = validLayoutRequesters.get(i); Log.w(\"View\", \"requestLayout() improperly called by \" + view + \" during layout: running second layout pass\"); view.requestLayout(); &#125; measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); mInLayout = true; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mHandlingLayoutInLayoutRequest = false; // Check the valid requests again, this time without checking/clearing the // layout flags, since requests happening during the second pass get noop'd validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, true); if (validLayoutRequesters != null) &#123; final ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters; // Post second-pass requests to the next frame getRunQueue().post(new Runnable() &#123; @Override public void run() &#123; int numValidRequests = finalRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) &#123; final View view = finalRequesters.get(i); view.requestLayout(); &#125; &#125; &#125;);&#125; &#125; &#125; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; mInLayout = false;&#125; 4.执行窗口绘制performDraw()12345678910111213[-&gt;ViewRootImpl.java] private void performDraw() &#123; ...... try &#123; draw(fullRedrawNeeded); &#125; finally &#123; mIsDrawing = false; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; ...... &#125; &#125; Android是怎样将View画出来的？ [-&gt;ViewRootImpl.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 private void draw(boolean fullRedrawNeeded) &#123; Surface surface = mSurface; ...... mAttachInfo.mTreeObserver.dispatchOnDraw(); int xOffset = -mCanvasOffsetX; int yOffset = -mCanvasOffsetY + curScrollY; final WindowManager.LayoutParams params = mWindowAttributes; final Rect surfaceInsets = params != null ? params.surfaceInsets : null; if (surfaceInsets != null) &#123; xOffset -= surfaceInsets.left; yOffset -= surfaceInsets.top; // Offset dirty rect for surface insets. dirty.offset(surfaceInsets.left, surfaceInsets.right); &#125; boolean accessibilityFocusDirty = false; final Drawable drawable = mAttachInfo.mAccessibilityFocusDrawable; if (drawable != null) &#123; final Rect bounds = mAttachInfo.mTmpInvalRect; final boolean hasFocus = getAccessibilityFocusedRect(bounds); if (!hasFocus) &#123; bounds.setEmpty(); &#125; if (!bounds.equals(drawable.getBounds())) &#123; accessibilityFocusDirty = true; &#125; &#125; mAttachInfo.mDrawingTime = mChoreographer.getFrameTimeNanos() / TimeUtils.NANOS_PER_MS; if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123; if (mAttachInfo.mHardwareRenderer != null &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123; // If accessibility focus moved, always invalidate the root. boolean invalidateRoot = accessibilityFocusDirty || mInvalidateRootRequested; mInvalidateRootRequested = false; // Draw with hardware renderer. mIsAnimating = false; if (mHardwareYOffset != yOffset || mHardwareXOffset != xOffset) &#123; mHardwareYOffset = yOffset; mHardwareXOffset = xOffset; invalidateRoot = true; &#125; if (invalidateRoot) &#123; mAttachInfo.mHardwareRenderer.invalidateRoot(); &#125; ...... if (updated) &#123; requestDrawWindow(); &#125; mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, this); &#125; else &#123; if (mAttachInfo.mHardwareRenderer != null &amp;&amp; !mAttachInfo.mHardwareRenderer.isEnabled() &amp;&amp; mAttachInfo.mHardwareRenderer.isRequested()) &#123; try &#123; mAttachInfo.mHardwareRenderer.initializeIfNeeded( mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets); &#125; catch (OutOfResourcesException e) &#123; handleOutOfResourcesException(e); return; &#125; mFullRedrawNeeded = true; scheduleTraversals(); return; &#125; if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123; return; &#125; &#125; &#125; if (animating) &#123; mFullRedrawNeeded = true; scheduleTraversals(); &#125;&#125; 关于绘制这个流程很复杂，我们后续章节再分析。 参考博客：Android应用程序UI硬件加速渲染技术简要介绍和学习计划 这里我们因为要分析Surface机制，所以只分析ViewRootImpl的draw流程。（如果开启了硬件加速功能，则会使用hwui硬件绘制功能，这里我们忽略这个，使用默认的软件绘制流程drawSoftware）。 [-&gt;ViewRootImpl.java] 1234567891011121314151617181920212223242526272829303132 private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. final Canvas canvas; try &#123; ...... canvas = mSurface.lockCanvas(dirty); ...... &#125; ...... try &#123; canvas.translate(-xoff, -yoff); if (mTranslator != null) &#123; mTranslator.translateCanvas(canvas); &#125; canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0); attachInfo.mSetIgnoreDirtyState = false; mView.draw(canvas); drawAccessibilityFocusedDrawableIfNeeded(canvas); &#125;...... &#125; finally &#123; try &#123; surface.unlockCanvasAndPost(canvas); &#125; catch (IllegalArgumentException e) &#123; ...... return false; &#125; &#125; return true;&#125; 先看看Surface的lockCanvas方法：[-&gt;Surface.java] 1234567891011//mCanvas 变量直接赋值private final Canvas mCanvas = new CompatibleCanvas();public Canvas lockCanvas(Rect inOutDirty) throws Surface.OutOfResourcesException, IllegalArgumentException &#123;synchronized (mLock) &#123; checkNotReleasedLocked(); ...... mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty); return mCanvas;&#125;&#125; [-&gt;android_view_Surface.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static jlong nativeLockCanvas(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj, jobject dirtyRectObj) &#123; //获取java层的Surface保存的long型句柄sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject));if (!isSurfaceValid(surface)) &#123; doThrowIAE(env); return 0;&#125;Rect dirtyRect(Rect::EMPTY_RECT);Rect* dirtyRectPtr = NULL;//获取java层dirty Rect的位置大小信息if (dirtyRectObj) &#123; dirtyRect.left = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left); dirtyRect.top = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top); dirtyRect.right = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right); dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom); dirtyRectPtr = &amp;dirtyRect;&#125;ANativeWindow_Buffer outBuffer; //调用Surface的lock方法,将申请的图形缓冲区赋给outBufferstatus_t err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);......SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height, convertPixelFormat(outBuffer.format), outBuffer.format == PIXEL_FORMAT_RGBX_8888 ? kOpaque_SkAlphaType : kPremul_SkAlphaType);SkBitmap bitmap;//创建一个SkBitmap //图形缓冲区每一行像素大小ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);bitmap.setInfo(info, bpr);if (outBuffer.width &gt; 0 &amp;&amp; outBuffer.height &gt; 0) &#123; bitmap.setPixels(outBuffer.bits);&#125; else &#123; // be safe with an empty bitmap. bitmap.setPixels(NULL);&#125;Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);nativeCanvas-&gt;setBitmap(bitmap);if (dirtyRectPtr) &#123; nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top, dirtyRect.right, dirtyRect.bottom);&#125;if (dirtyRectObj) &#123; env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left, dirtyRect.left); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top, dirtyRect.top); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right, dirtyRect.right); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);&#125;......sp&lt;Surface&gt; lockedSurface(surface);lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);return (jlong) lockedSurface.get();&#125; 这段代码逻辑主要如下： 1）获取java层dirty 的Rect大小和位置信息； 2）调用Surface的lock方法,将申请的图形缓冲区赋给outBuffer； 3）创建一个Skbitmap，填充它用来保存申请的图形缓冲区，并赋值给Java层的Canvas对象； 4）将剪裁位置大小信息赋给java层Canvas对象。 unlockCanvasAndPost()Surface绘制完毕后，unlockCanvasAndPost操作。[-&gt;android_view_Surface.cpp] 1234567891011121314151617static void nativeUnlockCanvasAndPost(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj) &#123;sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject));if (!isSurfaceValid(surface)) &#123; return;&#125;// detach the canvas from the surfaceCanvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);nativeCanvas-&gt;setBitmap(SkBitmap());// unlock surfacestatus_t err = surface-&gt;unlockAndPost();if (err &lt; 0) &#123; doThrowIAE(env);&#125;&#125; Surface管理图形缓冲区我们上边分析到了申请图形缓冲区，用到了Surface的lock函数，我们继续查看。[-&gt;Surface.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384status_t Surface::lock( ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds) &#123;......ANativeWindowBuffer* out;int fenceFd = -1;//调用dequeueBuffer函数，申请图形缓冲区status_t err = dequeueBuffer(&amp;out, &amp;fenceFd);ALOGE_IF(err, \"dequeueBuffer failed (%s)\", strerror(-err));if (err == NO_ERROR) &#123; //获取图形缓冲区区域大小,赋给后备缓冲区变量backBuffer sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out)); const Rect bounds(backBuffer-&gt;width, backBuffer-&gt;height); Region newDirtyRegion; if (inOutDirtyBounds) &#123; //如果上层指定乐刷新脏矩形区域，则用这个区域和缓冲区区域求交集， //然后将交集的结果设给需要去刷新的新区域 newDirtyRegion.set(static_cast&lt;Rect const&amp;&gt;(*inOutDirtyBounds)); newDirtyRegion.andSelf(bounds); &#125; else &#123; /如果上层没有指定脏矩形区域，所以刷新整个图形缓冲区 newDirtyRegion.set(bounds); &#125; // figure out if we can copy the frontbuffer back //上一次绘制的信息保存在mPostedBuffer中，而这个mPostedBuffer则要在unLockAndPost函数中设置 int backBufferSlot(getSlotFromBufferLocked(backBuffer.get())); const sp&lt;GraphicBuffer&gt;&amp; frontBuffer(mPostedBuffer); const bool canCopyBack = (frontBuffer != 0 &amp;&amp; backBuffer-&gt;width == frontBuffer-&gt;width &amp;&amp; backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp; backBuffer-&gt;format == frontBuffer-&gt;format); if (canCopyBack) &#123; Mutex::Autolock lock(mMutex); Region oldDirtyRegion; if(mSlots[backBufferSlot].dirtyRegion.isEmpty()) &#123; oldDirtyRegion.set(bounds); &#125; else &#123; for(int i = 0 ; i &lt; NUM_BUFFER_SLOTS; i++ ) &#123; if(i != backBufferSlot &amp;&amp; !mSlots[i].dirtyRegion.isEmpty()) oldDirtyRegion.orSelf(mSlots[i].dirtyRegion); &#125; &#125; const Region copyback(oldDirtyRegion.subtract(newDirtyRegion)); if (!copyback.isEmpty()) //这里把mPostedBuffer中的旧数据拷贝到BackBuffer中。 //后续的绘画只要更新脏区域就可以了，这会节约不少资源 copyBlt(backBuffer, frontBuffer, copyback); &#125; else &#123; // if we can't copy-back anything, modify the user's dirty // region to make sure they redraw the whole buffer //如果两次图形缓冲区大小不一致，我们就要修改用户指定的dirty区域大小为整个缓冲区大小， //然后去更新整个缓冲区 newDirtyRegion.set(bounds); Mutex::Autolock lock(mMutex); for (size_t i=0 ; i&lt;NUM_BUFFER_SLOTS ; i++) &#123; mSlots[i].dirtyRegion.clear(); &#125; &#125; &#123; // scope for the lock Mutex::Autolock lock(mMutex); //将新的dirty赋给这个bufferslot mSlots[backBufferSlot].dirtyRegion = newDirtyRegion; &#125; if (inOutDirtyBounds) &#123; *inOutDirtyBounds = newDirtyRegion.getBounds(); &#125; void* vaddr; //lock和unlock分别用来锁定和解锁一个指定的图形缓冲区，在访问一块图形缓冲区的时候， //例如，向一块图形缓冲写入内容的时候，需要将该图形缓冲区锁定，用来避免访问冲突, //锁定之后，就可以获得由参数参数l、t、w和h所圈定的一块缓冲区的起始地址，保存在输出参数vaddr中 status_t res = backBuffer-&gt;lockAsync( GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN, newDirtyRegion.bounds(), &amp;vaddr, fenceFd); ......&#125;return err;&#125; Surface的lock函数用来申请图形缓冲区和一些操作，方法不长，大概工作有： 1）调用connect函数完成一些初始化； 2）调用dequeueBuffer函数，申请图形缓冲区； 3）计算需要绘制的新的dirty区域，旧的区域原样copy数据。 [-&gt;BufferQueueProducer.cpp] 123456789101112131415161718192021222324252627int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) &#123;uint32_t reqWidth;uint32_t reqHeight;PixelFormat reqFormat;uint32_t reqUsage;&#123; ......//申请图形缓冲区status_t result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, reqWidth, reqHeight, reqFormat, reqUsage);......//根据index获取缓冲区sp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer);......if ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == 0) &#123; //由于申请的内存是在surfaceflinger进程中， //BufferQueue中的图形缓冲区也是通过匿名共享内存和binder传递描述符映射过去的， //Surface通过调用requestBuffer将图形缓冲区映射到Surface所在进程 result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf); ......&#125;......//获取这个这个buffer对象的指针内容*buffer = gbuf.get();......return OK;&#125; [-&gt;BufferQueueProducer.cpp] 12345678910status_t BufferQueueProducer::requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf) &#123;ATRACE_CALL();Mutex::Autolock lock(mCore-&gt;mMutex);......mSlots[slot].mRequestBufferCalled = true;*buf = mSlots[slot].mGraphicBuffer;return NO_ERROR;&#125; 这个比较简单，还是很好理解的额，就是根据指定index取出mSlots中的slot中的buffer。 图形缓冲区入队我们前面讲了，省略了第二步绘制流程，因此我们这里分析第三部，绘制完毕后再queueBuffer。同样，调用了Surface的unlockCanvasAndPost函数，我们查看它的实现： [-&gt;Surface.cpp] 123456789101112131415status_t Surface::unlockAndPost()&#123;......int fd = -1;//解锁图形缓冲区，和前面的lockAsync成对出现status_t err = mLockedBuffer-&gt;unlockAsync(&amp;fd);//queueBuffer去归还图形缓冲区err = queueBuffer(mLockedBuffer.get(), fd);mPostedBuffer = mLockedBuffer;mLockedBuffer = 0;return err;&#125; 这里也比较简单，核心也是分两步： 1）解锁图形缓冲区，和前面的lockAsync成对出现； 2）queueBuffer去归还图形缓冲区； 所以我们还是重点分析第二步，查看queueBuffer的实现： [-&gt;Surface.cpp] 1234567int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) &#123;......status_t err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);mLastQueueDuration = systemTime() - now;......return err;&#125; 调用BufferQueueProducer的queueBuffer归还缓冲区，将绘制后的图形缓冲区queue回去。[-&gt;BufferQueueProducer.cpp] 1234567891011121314151617181920status_t BufferQueueProducer::queueBuffer(int slot, const QueueBufferInput &amp;input, QueueBufferOutput *output) &#123;......&#123; // scope for the lock Mutex::Autolock lock(mCallbackMutex); while (callbackTicket != mCurrentCallbackTicket) &#123; mCallbackCondition.wait(mCallbackMutex); &#125; if (frameAvailableListener != NULL) &#123; frameAvailableListener-&gt;onFrameAvailable(item); &#125; else if (frameReplacedListener != NULL) &#123; frameReplacedListener-&gt;onFrameReplaced(item); &#125; ......&#125;......return NO_ERROR;&#125; 总结： 1）从传入的QueueBufferInput ，解析填充一些变量； 2）改变入队Slot的状态为QUEUED，每次推进来，mFrameCounter都加1。这里的slot，上一篇讲分配缓冲区返回最老的FREE状态buffer，就是用这个mFrameCounter最小值判断，就是上一篇LRU算法的判断； 3）创建一个BufferItem来描述GraphicBuffer，用mSlots[slot]中的slot填充BufferItem； 4）将BufferItem塞进mCore的mQueue队列，依照指定规则； 5）然后通知SurfaceFlinger去消费。 上述lockCanvas和unlockCanvasAndPost可以用下图来总结一下： 通知SF消费合成 当绘制完毕的GraphicBuffer入队之后，会通知SurfaceFlinger去消费，就是BufferQueueProducer的queueBuffer函数的最后几行，listener-&gt;onFrameAvailable()。listener最终通过回调，会回到Layer当中，所以最终调用Layer的onFrameAvailable接口，我们看看它的实现：[Layer.cpp] 123456789101112void Layer::onFrameAvailable(const BufferItem&amp; item) &#123;// Add this buffer from our internal queue tracker&#123; // Autolock scope ...... mQueueItems.push_back(item); android_atomic_inc(&amp;mQueuedFrames); // Wake up any pending callbacks mLastFrameNumberReceived = item.mFrameNumber; mQueueItemCondition.broadcast();&#125;mFlinger-&gt;signalLayerUpdate();&#125; 这里又调用SurfaceFlinger的signalLayerUpdate函数，继续查看：[SurfaceFlinger.cpp] 123void SurfaceFlinger::signalLayerUpdate() &#123;mEventQueue.invalidate();&#125; 这里又调用MessageQueue的invalidate函数：[MessageQueue.cpp] 123void MessageQueue::invalidate() &#123;mEvents-&gt;requestNextVsync();&#125; 贴一下SurfaceFlinger的初始化请求vsync信号流程图： 最终结果会走到SurfaceFlinger的vsync信号接收逻辑，即SurfaceFlinger的onMessageReceived函数：[SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930void SurfaceFlinger::onMessageReceived(int32_t what) &#123;ATRACE_CALL();switch (what) &#123; case MessageQueue::INVALIDATE: &#123; bool frameMissed = !mHadClientComposition &amp;&amp; mPreviousPresentFence != Fence::NO_FENCE &amp;&amp; mPreviousPresentFence-&gt;getSignalTime() == INT64_MAX; ATRACE_INT(\"FrameMissed\", static_cast&lt;int&gt;(frameMissed)); if (mPropagateBackpressure &amp;&amp; frameMissed) &#123; signalLayerUpdate(); break; &#125; bool refreshNeeded = handleMessageTransaction(); refreshNeeded |= handleMessageInvalidate(); refreshNeeded |= mRepaintEverything; if (refreshNeeded) &#123; // Signal a refresh if a transaction modified the window state, // a new buffer was latched, or if HWC has requested a full // repaint signalRefresh(); &#125; break; &#125; case MessageQueue::REFRESH: &#123; handleMessageRefresh(); break; &#125;&#125;&#125; SurfaceFlinger收到了VSync信号后，调用了handleMessageRefresh函数[SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627void SurfaceFlinger::handleMessageRefresh() &#123;ATRACE_CALL();nsecs_t refreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC);preComposition();rebuildLayerStacks();setUpHWComposer();doDebugFlashRegions();doComposition();postComposition(refreshStartTime);mPreviousPresentFence = mHwc-&gt;getRetireFence(HWC_DISPLAY_PRIMARY);mHadClientComposition = false;for (size_t displayId = 0; displayId &lt; mDisplays.size(); ++displayId) &#123; const sp&lt;DisplayDevice&gt;&amp; displayDevice = mDisplays[displayId]; mHadClientComposition = mHadClientComposition || mHwc-&gt;hasClientComposition(displayDevice-&gt;getHwcDisplayId());&#125;// Release any buffers which were replaced this framefor (auto&amp; layer : mLayersWithQueuedFrames) &#123; layer-&gt;releasePendingBuffer();&#125;mLayersWithQueuedFrames.clear();&#125; 我们主要看下下面几个函数。[SurfaceFlinger.cpp] 123456preComposition();rebuildLayerStacks();setUpHWComposer();doDebugFlashRegions();doComposition();postComposition(refreshStartTime); 一、preComposition()函数我们先来看第一个函数preComposition()[SurfaceFlinger.cpp] 1234567891011121314void SurfaceFlinger::preComposition()&#123;bool needExtraInvalidate = false;const LayerVector&amp; layers(mDrawingState.layersSortedByZ);const size_t count = layers.size();for (size_t i=0 ; i&lt;count ; i++) &#123; if (layers[i]-&gt;onPreComposition()) &#123; needExtraInvalidate = true; &#125;&#125;if (needExtraInvalidate) &#123; signalLayerUpdate();&#125;&#125; 上面函数先是调用了mDrawingState的layersSortedByZ来得到上次绘图的Layer层列表。并不是所有的Layer都会参与屏幕图像的绘制，因此SurfaceFlinger用state对象来记录参与绘制的Layer对象。记得我们之前分析过createLayer函数来创建Layer，创建之后会调用addClientLayer函数。[SurfaceFlinger.cpp] 1234567891011121314151617181920status_t SurfaceFlinger::addClientLayer(const sp&lt;Client&gt;&amp; client, const sp&lt;IBinder&gt;&amp; handle, const sp&lt;IGraphicBufferProducer&gt;&amp; gbc, const sp&lt;Layer&gt;&amp; lbc) &#123;// add this layer to the current state list&#123; Mutex::Autolock _l(mStateLock); if (mCurrentState.layersSortedByZ.size() &gt;= MAX_LAYERS) &#123; return NO_MEMORY; &#125; mCurrentState.layersSortedByZ.add(lbc); mGraphicBufferProducerList.add(IInterface::asBinder(gbc));&#125;// attach this layer to the clientclient-&gt;attachLayer(handle, lbc);return NO_ERROR;&#125; 我们来看下addClientLayer函数，这里会把Layer对象放在mCurrentState的layersSortedByZ对象中。而mDrawingState和mCurrentState什么关系呢？在后面我们会介绍，mDrawingState代表上一次绘图时的状态，处理完之后会把mCurrentState赋给mDrawingState。回到preComposition函数，遍历所有的Layer对象，调用其onPreComposition函数来检测Layer层中的图像是否有变化。 1.1、每个Layer的onFrameAvailable函数onPreComposition函数来根据mQueuedFrames来判断图像是否发生了变化，或者是mSidebandStreamChanged、mAutoRefresh。[Layer.cpp] 1234bool Layer::onPreComposition() &#123;mRefreshPending = false;return mQueuedFrames &gt; 0 || mSidebandStreamChanged || mAutoRefresh;&#125; 当Layer所对应的Surface更新图像后，它所对应的Layer对象的onFrameAvailable函数会被调用来通知这种变化。在SurfaceFlinger的preComposition函数中当有Layer的图像改变了，最后也会调用SurfaceFlinger的signalLayerUpdate函数。SurfaceFlinger::signalLayerUpdate是调用了MessageQueue的invalidate函数最后处理还是调用了SurfaceFlinger的onMessageReceived函数。看看SurfaceFlinger的onMessageReceived函数对NVALIDATE的处理handleMessageInvalidate函数中调用了handlePageFlip函数，这个函数将会处理Layer中的缓冲区，把更新过的图像缓冲区切换到前台，等待VSync信号更新到FrameBuffer。 1.2、绘制流程具体完整的绘制流程如图。用户进程更新Surface图像，将导致SurfaceFlinger中的Layer发送invalidate消息，处理该消息会调用handleTransaction函数和handlePageFilp函数来更新Layer对象。一旦VSync信号到来，再调用rebuildlayerStacks setUpHWComposer doComposition postComposition函数将所有Layer的图像混合后更新到显示设备上去。 二、handleTransaction handPageFlip更新Layer对象在上一节中的绘图的流程中，我们看到了handleTransaction和handPageFlip这两个函数通常是在用户进程更新Surface图像时会调用，来更新Layer对象。这节就主要讲解这两个函数。 2.1、handleTransaction函数handleTransaction函数的参数是transactionFlags，不过函数中没有使用这个参数，而是通过getTransactionFlags(eTransactionMask)来重新对transactionFlags赋值，然后使用它作为参数来调用函数handleTransactionLocked。[SurfaceFlinger.cpp] 123456789101112131415void SurfaceFlinger::handleTransaction(uint32_t transactionFlags)&#123;ATRACE_CALL();Mutex::Autolock _l(mStateLock);const nsecs_t now = systemTime();mDebugInTransaction = now;transactionFlags = getTransactionFlags(eTransactionMask);handleTransactionLocked(transactionFlags);mLastTransactionTime = systemTime() - now;mDebugInTransaction = 0;invalidateHwcGeometry();&#125; getTransactionFlags函数的参数是eTransactionMask只是屏蔽其他位。handleTransactionLocked函数会调用每个Layer类的doTransaction函数，在分析handleTransactionLocked函数之前，我们先看看Layer类 的doTransaction函数。 2.2、Layer的doTransaction函数下面是Layer的doTransaction函数代码[Layer.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475uint32_t Layer::doTransaction(uint32_t flags) &#123;ATRACE_CALL();pushPendingState();//上次绘制的State对象 Layer::State c = getCurrentState();//当前使用的State对象 const Layer::State&amp; s(getDrawingState());const bool sizeChanged = (c.requested.w != s.requested.w) || (c.requested.h != s.requested.h);if (sizeChanged) &#123; // the size changed, we need to ask our client to request a new buffer //如果Layer的尺寸发生变化，就要改变Surface的缓冲区的尺寸 // record the new size, form this point on, when the client request // a buffer, it'll get the new size. mSurfaceFlingerConsumer-&gt;setDefaultBufferSize( c.requested.w, c.requested.h);&#125;const bool resizePending = (c.requested.w != c.active.w) || (c.requested.h != c.active.h);if (!isFixedSize()) &#123; if (resizePending &amp;&amp; mSidebandStream == NULL) &#123; //如果Layer不是固定尺寸的类型，比较它的实际大小和要求的改变大小 flags |= eDontUpdateGeometryState; &#125;&#125;//如果没有eDontUpdateGeometryState标志，更新active的值为request if (flags &amp; eDontUpdateGeometryState) &#123;&#125; else &#123; Layer::State&amp; editCurrentState(getCurrentState()); if (mFreezePositionUpdates) &#123; float tx = c.active.transform.tx(); float ty = c.active.transform.ty(); c.active = c.requested; c.active.transform.set(tx, ty); editCurrentState.active = c.active; &#125; else &#123; editCurrentState.active = editCurrentState.requested; c.active = c.requested; &#125;&#125;// 如果当前state的active和以前的State的active不等，设置更新标志 if (s.active != c.active) &#123; // invalidate and recompute the visible regions if needed flags |= Layer::eVisibleRegion;&#125;//如果当前state的sequence和以前state的sequence不等，设置更新标志if (c.sequence != s.sequence) &#123; // invalidate and recompute the visible regions if needed flags |= eVisibleRegion; this-&gt;contentDirty = true; // we may use linear filtering, if the matrix scales us const uint8_t type = c.active.transform.getType(); mNeedsFiltering = (!c.active.transform.preserveRects() || (type &gt;= Transform::SCALE));&#125;// If the layer is hidden, signal and clear out all local sync points so// that transactions for layers depending on this layer's frames becoming// visible are not blockedif (c.flags &amp; layer_state_t::eLayerHidden) &#123; Mutex::Autolock lock(mLocalSyncPointMutex); for (auto&amp; point : mLocalSyncPoints) &#123; point-&gt;setFrameAvailable(); &#125; mLocalSyncPoints.clear();&#125;// Commit the transactioncommitTransaction(c);return flags;&#125; Layer类中的两个类型为Layer::State的成员变量mDrawingState、mCurrentState，这里为什么要两个对象呢？Layer对象在绘制图形时，使用的是mDrawingState变量，用户调用接口设置Layer对象属性是，设置的值保存在mCurrentState对象中，这样就不会因为用户的操作而干扰Layer对象的绘制了。Layer的doTransaction函数据你是比较这两个变量，如果有不同的地方，说明在上次绘制以后，用户改变的Layer的设置，要把这种变化通过flags返回。State的结构中有两个Geometry字段，active和requested。他们表示layer的尺寸，其中requested保存是用户设置的尺寸，而active保存的值通过计算后的实际尺寸。State中的z字段的值就是Layer在显示轴的位置，值越小位置越靠下。layerStack字段是用户指定的一个值，用户可以给DisplayDevice也指定一个layerStack值，只有Layer对象和DisplayDevice对象的layerStack相等，这个Layer才能在这个显示设备上输出，这样的好处是可以让显示设备只显示某个Surface的内容。例如，可以让HDMI显示设备只显示手机上播放视频的Surface窗口，但不显示Activity窗口。sequence字段是个序列值，每当用户调用了Layer的接口，例如setAlpha、setSize或者setLayer等改变Layer对象属性的哈数，这个值都会加1。因此在doTransaction函数中能通过比较sequence值来判断Layer的属性值有没有变化。doTransaction函数最后会调用commitTransaction函数，就是把mCurrentState赋值给mDrawingState[Layer.cpp] 123void Layer::commitTransaction(const State&amp; stateToCommit) &#123;mDrawingState = stateToCommit;&#125; 2.3、handleTransactionLocked函数下面我们来分析handleTransactionLocked函数，这个函数比较长，我们分段分析 2.3.1 处理Layer的事务[SurfaceFlinger.cpp] 123456789101112131415161718192021void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)&#123;const LayerVector&amp; currentLayers(mCurrentState.layersSortedByZ);const size_t count = currentLayers.size();// Notify all layers of available framesfor (size_t i = 0; i &lt; count; ++i) &#123; currentLayers[i]-&gt;notifyAvailableFrames();&#125;if (transactionFlags &amp; eTraversalNeeded) &#123; for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); uint32_t trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded); if (!trFlags) continue; const uint32_t flags = layer-&gt;doTransaction(0); if (flags &amp; Layer::eVisibleRegion) mVisibleRegionsDirty = true; &#125;&#125; 在SurfaceFlinger中也有两个类型为State的变量mCurrentState和mDrawingState，但是和Layer中的不要混起来。它的名字相同而已 1234 struct State &#123; LayerVector layersSortedByZ; DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays;&#125;; 结构layersSortedByZ字段保存所有参与绘制的Layer对象，而字段displays保存的是所有输出设备的DisplayDeviceState对象这里用两个变量的目的是和Layer中使用两个变量是一样的。上面代码根据eTraversalNeeded标志来决定是否要检查所有的Layer对象。如果某个Layer对象中有eTransactionNeeded标志，将调用它的doTransaction函数。Layer的doTransaction函数返回的flags如果有eVisibleRegion，说明这个Layer需要更新，就把mVisibleRegionsDirty设置为true 2.3.2、处理显示设备的变化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172 if (transactionFlags &amp; eDisplayTransactionNeeded) &#123; // here we take advantage of Vector's copy-on-write semantics to // improve performance by skipping the transaction entirely when // know that the lists are identical const KeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; curr(mCurrentState.displays); const KeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; draw(mDrawingState.displays); if (!curr.isIdenticalTo(draw)) &#123; mVisibleRegionsDirty = true; const size_t cc = curr.size(); size_t dc = draw.size(); // find the displays that were removed // (ie: in drawing state but not in current state) // also handle displays that changed // (ie: displays that are in both lists) for (size_t i=0 ; i&lt;dc ; i++) &#123; const ssize_t j = curr.indexOfKey(draw.keyAt(i)); if (j &lt; 0) &#123; // in drawing state but not in current state if (!draw[i].isMainDisplay()) &#123; // Call makeCurrent() on the primary display so we can // be sure that nothing associated with this display // is current. const sp&lt;const DisplayDevice&gt; defaultDisplay(getDefaultDisplayDevice()); defaultDisplay-&gt;makeCurrent(mEGLDisplay, mEGLContext); sp&lt;DisplayDevice&gt; hw(getDisplayDevice(draw.keyAt(i))); if (hw != NULL) hw-&gt;disconnect(getHwComposer()); if (draw[i].type &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) mEventThread-&gt;onHotplugReceived(draw[i].type, false); mDisplays.removeItem(draw.keyAt(i)); &#125; else &#123; ALOGW(\"trying to remove the main display\"); &#125; &#125; else &#123; // this display is in both lists. see if something changed. const DisplayDeviceState&amp; state(curr[j]); const wp&lt;IBinder&gt;&amp; display(curr.keyAt(j)); const sp&lt;IBinder&gt; state_binder = IInterface::asBinder(state.surface); const sp&lt;IBinder&gt; draw_binder = IInterface::asBinder(draw[i].surface); if (state_binder != draw_binder) &#123; // changing the surface is like destroying and // recreating the DisplayDevice, so we just remove it // from the drawing state, so that it get re-added // below. sp&lt;DisplayDevice&gt; hw(getDisplayDevice(display)); if (hw != NULL) hw-&gt;disconnect(getHwComposer()); mDisplays.removeItem(display); mDrawingState.displays.removeItemsAt(i); dc--; i--; // at this point we must loop to the next item continue; &#125; const sp&lt;DisplayDevice&gt; disp(getDisplayDevice(display)); if (disp != NULL) &#123; if (state.layerStack != draw[i].layerStack) &#123; disp-&gt;setLayerStack(state.layerStack); &#125; if ((state.orientation != draw[i].orientation) || (state.viewport != draw[i].viewport) || (state.frame != draw[i].frame)) &#123; disp-&gt;setProjection(state.orientation, state.viewport, state.frame); &#125; if (state.width != draw[i].width || state.height != draw[i].height) &#123; disp-&gt;setDisplaySize(state.width, state.height); &#125; &#125; &#125; &#125; // find displays that were added // (ie: in current state but not in drawing state) for (size_t i=0 ; i&lt;cc ; i++) &#123; if (draw.indexOfKey(curr.keyAt(i)) &lt; 0) &#123; const DisplayDeviceState&amp; state(curr[i]); sp&lt;DisplaySurface&gt; dispSurface; sp&lt;IGraphicBufferProducer&gt; producer; sp&lt;IGraphicBufferProducer&gt; bqProducer; sp&lt;IGraphicBufferConsumer&gt; bqConsumer; BufferQueue::createBufferQueue(&amp;bqProducer, &amp;bqConsumer, new GraphicBufferAlloc()); int32_t hwcDisplayId = -1; if (state.isVirtualDisplay()) &#123; // Virtual displays without a surface are dormant: // they have external state (layer stack, projection, // etc.) but no internal state (i.e. a DisplayDevice). if (state.surface != NULL) &#123; int width = 0; DisplayUtils* displayUtils = DisplayUtils::getInstance(); int status = state.surface-&gt;query( NATIVE_WINDOW_WIDTH, &amp;width); ALOGE_IF(status != NO_ERROR, \"Unable to query width (%d)\", status); int height = 0; status = state.surface-&gt;query( NATIVE_WINDOW_HEIGHT, &amp;height); ALOGE_IF(status != NO_ERROR, \"Unable to query height (%d)\", status); if (MAX_VIRTUAL_DISPLAY_DIMENSION == 0 || (width &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION &amp;&amp; height &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION)) &#123; int usage = 0; status = state.surface-&gt;query( NATIVE_WINDOW_CONSUMER_USAGE_BITS, &amp;usage); ALOGW_IF(status != NO_ERROR, \"Unable to query usage (%d)\", status); if ( (status == NO_ERROR) &amp;&amp; displayUtils-&gt;canAllocateHwcDisplayIdForVDS(usage)) &#123; hwcDisplayId = allocateHwcDisplayId(state.type); &#125; &#125; displayUtils-&gt;initVDSInstance(mHwc, hwcDisplayId, state.surface, dispSurface, producer, bqProducer, bqConsumer, state.displayName, state.isSecure, state.type); &#125; &#125; else &#123; ALOGE_IF(state.surface!=NULL, \"adding a supported display, but rendering \" \"surface is provided (%p), ignoring it\", state.surface.get()); hwcDisplayId = allocateHwcDisplayId(state.type); // for supported (by hwc) displays we provide our // own rendering surface dispSurface = new FramebufferSurface(*mHwc, state.type, bqConsumer); producer = bqProducer; &#125; const wp&lt;IBinder&gt;&amp; display(curr.keyAt(i)); if (dispSurface != NULL &amp;&amp; producer != NULL) &#123; sp&lt;DisplayDevice&gt; hw = new DisplayDevice(this, state.type, hwcDisplayId, mHwc-&gt;getFormat(hwcDisplayId), state.isSecure, display, dispSurface, producer, mRenderEngine-&gt;getEGLConfig()); hw-&gt;setLayerStack(state.layerStack); hw-&gt;setProjection(state.orientation, state.viewport, state.frame); hw-&gt;setDisplayName(state.displayName); // When a new display device is added update the active // config by querying HWC otherwise the default config // (config 0) will be used. if (hwcDisplayId &gt;= DisplayDevice::DISPLAY_PRIMARY &amp;&amp; hwcDisplayId &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) &#123; int activeConfig = mHwc-&gt;getActiveConfig(hwcDisplayId); if (activeConfig &gt;= 0) &#123; hw-&gt;setActiveConfig(activeConfig); &#125; &#125; mDisplays.add(display, hw); if (state.isVirtualDisplay()) &#123; if (hwcDisplayId &gt;= 0) &#123; mHwc-&gt;setVirtualDisplayProperties(hwcDisplayId, hw-&gt;getWidth(), hw-&gt;getHeight(), hw-&gt;getFormat()); &#125; &#125; else &#123; mEventThread-&gt;onHotplugReceived(state.type, true); &#125; &#125; &#125; &#125; &#125;&#125; 这段代码的作用是处理显示设备的变化，分成3种情况：1.显示设备减少了，需要把显示设备对应的DisplayDevice移除2.显示设备发生了变化，例如用户设置了Surface、重新设置了layerStack、旋转了屏幕等，这就需要重新设置显示对象的属性3.显示设备增加了，创建新的DisplayDevice加入系统中。 2.3.3、设置TransfromHit12345678910111213141516171819202122232425262728293031323334353637383940 if (transactionFlags &amp; (eTraversalNeeded|eDisplayTransactionNeeded)) &#123; ...... sp&lt;const DisplayDevice&gt; disp; uint32_t currentlayerStack = 0; for (size_t i=0; i&lt;count; i++) &#123; // NOTE: we rely on the fact that layers are sorted by // layerStack first (so we don't have to traverse the list // of displays for every layer). const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); uint32_t layerStack = layer-&gt;getDrawingState().layerStack; if (i==0 || currentlayerStack != layerStack) &#123; currentlayerStack = layerStack; // figure out if this layerstack is mirrored // (more than one display) if so, pick the default display, // if not, pick the only display it's on. disp.clear(); for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); if (hw-&gt;getLayerStack() == currentlayerStack) &#123; if (disp == NULL) &#123; disp = hw; &#125; else &#123; disp = NULL; break; &#125; &#125; &#125; &#125; if (disp == NULL) &#123; // NOTE: TEMPORARY FIX ONLY. Real fix should cause layers to // redraw after transform hint changes. See bug 8508397. // could be null when this layer is using a layerStack // that is not visible on any display. Also can occur at // screen off/on times. disp = getDefaultDisplayDevice(); &#125; layer-&gt;updateTransformHint(disp); &#125;&#125; 这段代码的作用是根据每种显示设备的不同，设置和显示设备关联在一起的Layer（主要看Layer的layerStack是否和DisplayDevice的layerStack）的TransformHint（主要指设备的显示方向orientation）。 2.3.4、处理Layer增加情况123456789101112131415161718192021222324252627282930/* * Perform our own transaction if needed */const LayerVector&amp; layers(mDrawingState.layersSortedByZ);if (currentLayers.size() &gt; layers.size()) &#123; // layers have been added mVisibleRegionsDirty = true;&#125;// some layers might have been removed, so// we need to update the regions they're exposing.if (mLayersRemoved) &#123; mLayersRemoved = false; mVisibleRegionsDirty = true; const size_t count = layers.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); if (currentLayers.indexOf(layer) &lt; 0) &#123; // this layer is not visible anymore // TODO: we could traverse the tree from front to back and // compute the actual visible region // TODO: we could cache the transformed region const Layer::State&amp; s(layer-&gt;getDrawingState()); Region visibleReg = s.active.transform.transform( Region(Rect(s.active.w, s.active.h))); invalidateLayerStack(s.layerStack, visibleReg); &#125; &#125;&#125; 这段代码处理Layer的增加情况，如果Layer增加了，需要重新计算设备的更新区域，因此把mVisibleRegionsDirty设为true，如果Layer删除了，需要把Layer的可见区域加入到系统需要更新的区域中。 2.3.5、设置mDrawingState123 commitTransaction();updateCursorAsync();&#125; 调用commitTransaction和updateCursorAsync函数 commitTransaction函数作用是把mDrawingState的值设置成mCurrentState的值。而updateCursorAsync函数会更新所有显示设备中光标的位置。 2.3.6 小结handleTransaction函数的作用的就是处理系统在两次刷新期间的各种变化。SurfaceFlinger模块中不管是SurfaceFlinger类还是Layer类，都采用了双缓冲的方式来保存他们的属性，这样的好处是刚改变SurfaceFlinger对象或者Layer类对象的属性是，不需要上锁，大大的提高了系统效率。只有在最后的图像输出是，才进行一次上锁，并进行内存的属性变化处理。正因此，应用进程必须收到VSync信号才开始改变Surface的内容。 2.4、handlePageFlip函数handlePageFlip函数代码如下：[SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool SurfaceFlinger::handlePageFlip()&#123;Region dirtyRegion;bool visibleRegions = false;const LayerVector&amp; layers(mDrawingState.layersSortedByZ);bool frameQueued = false;// Store the set of layers that need updates. This set must not change as// buffers are being latched, as this could result in a deadlock.// Example: Two producers share the same command stream and:// 1.) Layer 0 is latched// 2.) Layer 0 gets a new frame// 2.) Layer 1 gets a new frame// 3.) Layer 1 is latched.// Display is now waiting on Layer 1's frame, which is behind layer 0's// second frame. But layer 0's second frame could be waiting on display.Vector&lt;Layer*&gt; layersWithQueuedFrames;for (size_t i = 0, count = layers.size(); i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); if (layer-&gt;hasQueuedFrame()) &#123; frameQueued = true; if (layer-&gt;shouldPresentNow(mPrimaryDispSync)) &#123; layersWithQueuedFrames.push_back(layer.get()); &#125; else &#123; layer-&gt;useEmptyDamage(); &#125; &#125; else &#123; layer-&gt;useEmptyDamage(); &#125;&#125;for (size_t i = 0, count = layersWithQueuedFrames.size() ; i&lt;count ; i++) &#123; Layer* layer = layersWithQueuedFrames[i]; const Region dirty(layer-&gt;latchBuffer(visibleRegions)); layer-&gt;useSurfaceDamage(); const Layer::State&amp; s(layer-&gt;getDrawingState()); invalidateLayerStack(s.layerStack, dirty);&#125;mVisibleRegionsDirty |= visibleRegions;// If we will need to wake up at some time in the future to deal with a// queued frame that shouldn't be displayed during this vsync period, wake// up during the next vsync period to check again.if (frameQueued &amp;&amp; layersWithQueuedFrames.empty()) &#123; signalLayerUpdate();&#125;// Only continue with the refresh if there is actually new work to doreturn !layersWithQueuedFrames.empty();&#125; handlePageFlip函数先调用每个Layer对象的hasQueuedFrame函数，确定这个Layer对象是否有需要更新的图层，然后把需要更新的Layer对象放到layersWithQueuedFrames中。我们先来看Layer的hasQueuedFrame方法就是看其mQueuedFrames是否大于0 和mSidebandStreamChanged。前面小节分析只要Surface有数据写入，就会调用Layer的onFrameAvailable函数，然后mQueuedFrames值加1.继续看handlePageFlip函数，接着调用需要更新的Layer对象的latchBuffer函数，然后根据返回的更新区域调用invalidateLayerStack函数来设置更新设备对象的更新区域。下面我们看看latchBuffer函数 LatchBuffer函数调用updateTextImage来得到需要的图像。这里参数r是Reject对象，其作用是判断在缓冲区的尺寸是否符合要求。调用updateTextImage函数如果得到的结果是PRESENT_LATER,表示推迟处理，然后调用signalLayerUpdate函数来发送invalidate消息，这次绘制过程就不处理这个Surface的图像了。如果不需要推迟处理，把mQueuedFrames的值减1.最后LatchBuffer函数调用mSurfaceFlingerConsumer的getCurrentBuffer来取回当前的图像缓冲区指针，保存在mActiveBuffer中。 2.5 小结这样经过handleTransaction handlePageFlip两个函数处理，SurfaceFlinger中无论是Layer属性的变化还是图像的变化都处理好了，只等VSync信号到来就可以输出了。 三、rebuildLayerStacks函数前面介绍，VSync信号到来后，先是调用了rebuildLayerStacks函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445void SurfaceFlinger::rebuildLayerStacks() &#123;updateExtendedMode();// rebuild the visible layer list per screenif (CC_UNLIKELY(mVisibleRegionsDirty)) &#123; ATRACE_CALL(); mVisibleRegionsDirty = false; invalidateHwcGeometry(); //计算每个显示设备上可见的Layer const LayerVector&amp; layers(mDrawingState.layersSortedByZ); for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; Region opaqueRegion; Region dirtyRegion; Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ; const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]); const Transform&amp; tr(hw-&gt;getTransform()); const Rect bounds(hw-&gt;getBounds()); if (hw-&gt;isDisplayOn()) &#123; //计算每个layer的可见区域，确定设备需要重新绘制的区域 computeVisibleRegions(hw-&gt;getHwcDisplayId(), layers, hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion); const size_t count = layers.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); &#123; //只需要和显示设备的LayerStack相同的layer Region drawRegion(tr.transform( layer-&gt;visibleNonTransparentRegion)); drawRegion.andSelf(bounds); if (!drawRegion.isEmpty()) &#123; //如果Layer的显示区域和显示设备的窗口有交集 //把Layer加入列表中 layersSortedByZ.add(layer); &#125; &#125; &#125; &#125; //设置显示设备的可见Layer列表 hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ); hw-&gt;undefinedRegion.set(bounds); hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion)); hw-&gt;dirtyRegion.orSelf(dirtyRegion); &#125;&#125;&#125; rebuildLayerStacks函数的作用是重建每个显示设备的可见layer对象列表。对于按显示轴（Z轴）排列的Layer对象，排在最前面的当然会优先显示，但是Layer图像可能有透明域，也可能有尺寸没有覆盖整个屏幕，因此下面的layer也有显示的机会。rebuildLayerStacks函数对每个显示设备，先计算和显示设备具有相同layerStack值的Layer对象在该显示设备上的可见区域。然后将可见区域和显示设备的窗口区域有交集的layer组成一个新的列表，最后把这个列表设置到显示设备对象中。computeVisibleRegions函数首先计算每个Layer在设备上的可见区域visibleRegion。计算方法就是用整个Layer的区域减去上层所有不透明区域aboveOpaqueLayers。而上层所有不透明区域值是一个逐层累计的过程，每层都需要把自己的不透明区域累加到aboveOpaqueLayers中。而每层的不透明区域的计算方法：如果Layer的alpha的值为255，并且layer的isOpaque函数为true，则本层的不透明区域等于Layer所在区域，否则为0.这样一层层算下来，就很容易得到每层的可见区域大小了。其次，计算整个显示设备需要更新的区域outDirtyRegion。outDirtyRegion的值也是累计所有层的需要重回的区域得到的。如果Layer中的显示内容发生了变化，则整个可见区域visibleRegion都需要更新，同时还要包括上一次的可见区域，然后在去掉被上层覆盖后的区域得到的就是Layer需要更新的区域。如果Layer显示的内容没有变化，但是考虑到窗口大小的变化或者上层窗口的变化，因此Layer中还是有区域可以需要重绘的地方。这种情况下最简单的算法是用Layer计算出可见区域减去以前的可见区域就可以了。但是在computeVisibleRegions函数还引入了被覆盖区域，通常被覆盖区域和可见区域并不重复，因此函数中计算暴露区域是用可见区域减去被覆盖区域的。 四、setUpHWComposer函数setUpHWComposer函数的作用是更新HWComposer对象中图层对象列表以及图层属性。[SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102void SurfaceFlinger::setUpHWComposer() &#123;for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; bool dirty = !mDisplays[dpy]-&gt;getDirtyRegion(false).isEmpty(); bool empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == 0; bool wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers; ...... bool mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty); ...... mDisplays[dpy]-&gt;beginFrame(mustRecompose); if (mustRecompose) &#123; mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty; &#125;&#125;//得到系统HWComposer对象 HWComposer&amp; hwc(getHwComposer());if (hwc.initCheck() == NO_ERROR) &#123; // build the h/w work list if (CC_UNLIKELY(mHwWorkListDirty)) &#123; mHwWorkListDirty = false; for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;= 0) &#123; const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers( hw-&gt;getVisibleLayersSortedByZ()); const size_t count = currentLayers.size(); //根据Layer数量在HWComposer中创建hwc_layer_list_t列表 if (hwc.createWorkList(id, count) == NO_ERROR) &#123; HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123; const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); layer-&gt;setGeometry(hw, *cur); if (mDebugDisableHWC || mDebugRegion || mDaltonize || mHasColorMatrix) &#123; cur-&gt;setSkip(true); &#125; &#125; &#125; &#125; &#125; &#125; // set the per-frame data for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;= 0) &#123; bool freezeSurfacePresent = false; isfreezeSurfacePresent(freezeSurfacePresent, hw, id); const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers( hw-&gt;getVisibleLayersSortedByZ()); const size_t count = currentLayers.size(); HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123; /* * update the per-frame h/w composer data for each layer * and build the transparent region of the FB */ const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); //将Layer的mActiveBuffer设置到HWComposer中 layer-&gt;setPerFrameData(hw, *cur); setOrientationEventControl(freezeSurfacePresent,id); &#125; &#125; &#125; // If possible, attempt to use the cursor overlay on each display. for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;= 0) &#123; const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers( hw-&gt;getVisibleLayersSortedByZ()); const size_t count = currentLayers.size(); HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123; const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); if (layer-&gt;isPotentialCursor()) &#123; cur-&gt;setIsCursorLayerHint(); break; &#125; &#125; &#125; &#125; dumpDrawCycle(true); status_t err = hwc.prepare(); ALOGE_IF(err, \"HWComposer::prepare failed (%s)\", strerror(-err)); for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); hw-&gt;prepareFrame(hwc); &#125;&#125;&#125; HWComposer中有一个类型为DisplayData结构的数组mDisplayData，它维护着每个显示设备的信息。DisplayData结构中有一个类型为hwc_display_contents_l字段list，这个字段又有一个hwc_layer_l类型的数组hwLayers，记录该显示设备所有需要输出的Layer信息。setUpHWComposer函数调用HWComposer的createWorkList函数就是根据每种显示设备的Layer数量，创建和初始化hwc_display_contents_l对象和hwc_layer_l数组创建完HWComposer中的列表后，接下来是对每个Layer对象调用它的setPerFrameData函数，参数是HWComposer和HWCLayerInterface。setPerFrameData函数将Layer对象的当前图像缓冲区mActiveBuffer设置到HWCLayerInterface对象对应的hwc_layer_l对象中。HWComposer类中除了前面介绍的Gralloc还管理着Composer模块，这个模块实现了硬件的图像合成功能。setUpHWComposer函数接下来调用HWComposer类的prepare函数，而prepare函数会调用Composer模块的prepare接口。最后到各个厂家的实现hwc_prepare函数将每种HWComposer中的所有图层的类型都设置为HWC_FRAMEBUFFER就结束了。 五、合成所有层的图像 （doComposition()函数）doComposition函数是合成所有层的图像，代码如下：[SurfaceFlinger.cpp] 123456789101112131415161718192021void SurfaceFlinger::doComposition() &#123;ATRACE_CALL();const bool repaintEverything = android_atomic_and(0, &amp;mRepaintEverything);for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]); if (hw-&gt;isDisplayOn()) &#123; // transform the dirty region into this screen's coordinate space const Region dirtyRegion(hw-&gt;getDirtyRegion(repaintEverything)); // repaint the framebuffer (if needed) doDisplayComposition(hw, dirtyRegion); hw-&gt;dirtyRegion.clear(); hw-&gt;flip(hw-&gt;swapRegion); hw-&gt;swapRegion.clear(); &#125; // inform the h/w that we're done compositing hw-&gt;compositionComplete();&#125;postFramebuffer();&#125; doComposition函数针对每种显示设备调用doDisplayComposition函数来合成，合成后调用postFramebuffer函数，我们先来看看doDisplayComposition函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void SurfaceFlinger::doDisplayComposition(const sp&lt;const DisplayDevice&gt;&amp; hw, const Region&amp; inDirtyRegion) &#123;// We only need to actually compose the display if:// 1) It is being handled by hardware composer, which may need this to// keep its virtual display state machine in sync, or// 2) There is work to be done (the dirty region isn't empty)bool isHwcDisplay = hw-&gt;getHwcDisplayId() &gt;= 0;if (!isHwcDisplay &amp;&amp; inDirtyRegion.isEmpty()) &#123; ALOGV(\"Skipping display composition\"); return;&#125;ALOGV(\"doDisplayComposition\");Region dirtyRegion(inDirtyRegion);// compute the invalid region//swapRegion设置为需要更新的区域 hw-&gt;swapRegion.orSelf(dirtyRegion);uint32_t flags = hw-&gt;getFlags();//获得显示设备支持的更新方式标志 if (flags &amp; DisplayDevice::SWAP_RECTANGLE) &#123; // we can redraw only what's dirty, but since SWAP_RECTANGLE only // takes a rectangle, we must make sure to update that whole // rectangle in that case dirtyRegion.set(hw-&gt;swapRegion.bounds());&#125; else &#123; if (flags &amp; DisplayDevice::PARTIAL_UPDATES) &#123;//支持部分更新 // We need to redraw the rectangle that will be updated // (pushed to the framebuffer). // This is needed because PARTIAL_UPDATES only takes one // rectangle instead of a region (see DisplayDevice::flip()) //将更新区域调整为整个窗口大小 dirtyRegion.set(hw-&gt;swapRegion.bounds()); &#125; else &#123; // we need to redraw everything (the whole screen) dirtyRegion.set(hw-&gt;bounds()); hw-&gt;swapRegion = dirtyRegion; &#125;&#125;//合成 if (!doComposeSurfaces(hw, dirtyRegion)) return;// update the swap region and clear the dirty regionhw-&gt;swapRegion.orSelf(dirtyRegion);//没有硬件composer的情况，输出图像 // swap buffers (presentation)hw-&gt;swapBuffers(getHwComposer());&#125; doDisplayComposition函数根据显示设备支持的更新方式，重新设置需要更新区域的大小。真正的合成工作是在doComposerSurfaces函数中完成，这个函数在layer的类型为HWC_FRAMEBUFFER,或者不支持硬件的composer的情况下，调用layer的draw函数来一层一层低合成最后的图像。合成完后，doDisplayComposition函数调用了hw的swapBuffers函数，这个函数前面介绍过了，它将在系统不支持硬件的composer情况下调用eglSwapBuffers来输出图像到显示设备。 六、postFramebuffer函数上一节的doComposition函数最后调用了postFramebuffer函数，代码如下：[SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void SurfaceFlinger::postFramebuffer()&#123;ATRACE_CALL();const nsecs_t now = systemTime();mDebugInSwapBuffers = now;HWComposer&amp; hwc(getHwComposer());if (hwc.initCheck() == NO_ERROR) &#123; if (!hwc.supportsFramebufferTarget()) &#123; // EGL spec says: // \"surface must be bound to the calling thread's current context, // for the current rendering API.\" getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext); &#125; hwc.commit();&#125;// make the default display current because the VirtualDisplayDevice code cannot// deal with dequeueBuffer() being called outside of the composition loop; however// the code below can call glFlush() which is allowed (and does in some case) call// dequeueBuffer().getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(hw-&gt;getVisibleLayersSortedByZ()); hw-&gt;onSwapBuffersCompleted(hwc); const size_t count = currentLayers.size(); int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;=0 &amp;&amp; hwc.initCheck() == NO_ERROR) &#123; HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i = 0; cur != end &amp;&amp; i &lt; count; ++i, ++cur) &#123; currentLayers[i]-&gt;onLayerDisplayed(hw, &amp;*cur); &#125; &#125; else &#123; for (size_t i = 0; i &lt; count; i++) &#123; currentLayers[i]-&gt;onLayerDisplayed(hw, NULL); &#125; &#125;&#125;mLastSwapBufferTime = systemTime() - now;mDebugInSwapBuffers = 0;uint32_t flipCount = getDefaultDisplayDevice()-&gt;getPageFlipCount();if (flipCount % LOG_FRAME_STATS_PERIOD == 0) &#123; logFrameStats();&#125;&#125; postFramebuffer先判断系统是否支持composer，如果不支持，我们知道图像已经在doComposition函数时调用hw-&gt;swapBuffers输出了，就返回了。如果支持硬件composer，postFramebuffer函数将调用HWComposer的commit函数继续执行。[HWComposer.cpp] 12345678910111213141516171819202122232425262728293031323334353637status_t HWComposer::commit() &#123;int err = NO_ERROR;if (mHwc) &#123; if (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123; // On version 1.0, the OpenGL ES target surface is communicated // by the (dpy, sur) fields and we are guaranteed to have only // a single display. mLists[0]-&gt;dpy = eglGetCurrentDisplay(); mLists[0]-&gt;sur = eglGetCurrentSurface(EGL_DRAW); &#125; for (size_t i=VIRTUAL_DISPLAY_ID_BASE; i&lt;mNumDisplays; i++) &#123; DisplayData&amp; disp(mDisplayData[i]); if (disp.outbufHandle) &#123; mLists[i]-&gt;outbuf = disp.outbufHandle; mLists[i]-&gt;outbufAcquireFenceFd = disp.outbufAcquireFence-&gt;dup(); &#125; &#125; err = mHwc-&gt;set(mHwc, mNumDisplays, mLists); for (size_t i=0 ; i&lt;mNumDisplays ; i++) &#123; DisplayData&amp; disp(mDisplayData[i]); disp.lastDisplayFence = disp.lastRetireFence; disp.lastRetireFence = Fence::NO_FENCE; if (disp.list) &#123; if (disp.list-&gt;retireFenceFd != -1) &#123; disp.lastRetireFence = new Fence(disp.list-&gt;retireFenceFd); disp.list-&gt;retireFenceFd = -1; &#125; disp.list-&gt;flags &amp;= ~HWC_GEOMETRY_CHANGED; &#125; &#125;&#125;return (status_t)err;&#125; /**Vsync**/ 参考文档（特别感谢）：startActivity启动过程分析浅析Android的窗口 - DEV CLUBAndroid源码解析之（十四）–&gt;Activity启动流程Android6.0 显示系统（六） 图像的输出过程 - kc58236582的博客 - CSDN博客Android应用setContentView与LayoutInflater加载解析机制源码分析Android应用程序窗口设计框架介绍 - 深入剖析Android系统 - CSDN博客Android显示系统设计框架介绍 - 深入剖析Android系统 - CSDN博客图解Android - Android GUI 系统 (2) - 窗口管理 (View, Canvas, Window Manager) - 漫天尘沙 - 博客园Android SurfaceFlinger 学习之路(五)—-VSync 工作原理 | April is your lieAndroid graphics 学习－生产者、消费者、BufferQueue介绍 - armwind的专栏 - CSDN博客 Graphics DEMO Bingo Android 图形系统概述","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Activity 启动流程 （AMS）分析","slug":"Android-7-1-2-Android-N-Activity启动流程分析","date":"2017-09-30T16:00:00.000Z","updated":"2018-03-23T07:22:02.000Z","comments":true,"path":"2017/10/01/Android-7-1-2-Android-N-Activity启动流程分析/","link":"","permalink":"http://zhoujinjian.cc/2017/10/01/Android-7-1-2-Android-N-Activity启动流程分析/","excerpt":"Activity启动流程概述：● 点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；● system_server进程接收到请求后，向zygote进程发送创建进程的请求；● Zygote进程fork出新的子进程，即App进程；● App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；● system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；● App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；● 主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。","text":"Activity启动流程概述：● 点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；● system_server进程接收到请求后，向zygote进程发送创建进程的请求；● Zygote进程fork出新的子进程，即App进程；● App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；● system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；● App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；● 主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。 一、概述基于Android 7.1.2的源码剖析， 分析Android Activity启动流程，相关源码： frameworks/base/services/core/java/com/android/server/am/● ActivityManagerService.java● ActivityStackSupervisor.java● ActivityStack.java● ActivityRecord.java● ProcessRecord.java● TaskRecord.java frameworks/base/services/core/java/com/android/server/pm/● PackageManagerService.java frameworks/base/core/java/android/os/● Process.java frameworks/base/core/java/android/app/● IActivityManager.java● ActivityManagerNative.java (内含AMP)● ActivityManager.java● Activity.java● ActivityThread.java● Instrumentation.java● IApplicationThread.java● ApplicationThreadNative.java (内含ATP)● ActivityThread.java (内含ApplicationThread)● ContextImpl.java 博客原图链接 主要对象功能介绍：● ActivityManagerService，简称AMS，服务端对象，负责系统中所有Activity的生命周期。● ActivityManagerNative继承Java的Binder类，同时实现了IActivityManager接口，即ActivityManagerNative将作为Binder通信的服务端为用户提供支持。● ActivityManagerProxy：在ActivityManagerNative类中定义了内部类ActivityManagerProxy，该类同样实现了IActivityManager接口，将作为客户端使用的服务端代理。● ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作● ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。● ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。● Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。● ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。● ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。● TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。 相关类的类图：（1）IActivityManager相关类（2）IApplicationThread相关类（3）ActivityManagerService相关类 1.1、Task和StackAndroid系统中的每一个Activity都位于一个Task中。一个Task可以包含多个Activity，同一个Activity也可能有多个实例。 在AndroidManifest.xml中，我们可以通过android:launchMode来控制Activity在Task中的实例。 另外，在startActivity的时候，我们也可以通过setFlag 来控制启动的Activity在Task中的实例。 Task管理的意义还在于近期任务列表以及Back栈。 当你通过多任务键（有些设备上是长按Home键，有些设备上是专门提供的多任务键）调出多任务时，其实就是从ActivityManagerService获取了最近启动的Task列表。 Back栈管理了当你在Activity上点击Back键，当前Activity销毁后应该跳转到哪一个Activity的逻辑。关于Task和Back栈，请参见这里：Tasks and Back Stack。 其实在ActivityManagerService与WindowManagerService内部管理中，在Task之外，还有一层容器，这个容器应用开发者和用户可能都不会感觉到或者用到，但它却非常重要，那就是Stack。 下文中，我们将看到，Android系统中的多窗口管理，就是建立在Stack的数据结构上的。 一个Stack中包含了多个Task，一个Task中包含了多个Activity（Window），下图描述了它们的关系：另外还有一点需要注意的是，ActivityManagerService和WindowManagerService中的Task和Stack结构是一一对应的，对应关系对于如下： ActivityStack &lt;–&gt; TaskStackTaskRecord &lt;–&gt; Task即，ActivityManagerService中的每一个ActivityStack或者TaskRecord在WindowManagerService中都有对应的TaskStack和Task，这两类对象都有唯一的id（id是int类型），它们通过id进行关联。 1.2、小结： 用户从Launcher程序点击应用图标可启动应用的入口Activity，Activity启动时需要多个进程之间的交互，Android系统中有一个zygote进程专用于孵化Android框架层和应用层程序的进程。还有一个system_server进程，该进程里运行了很多binderservice，例如ActivityManagerService，PackageManagerService，WindowManagerService，这些binderservice分别运行在不同的线程中，其中ActivityManagerService负责管理Activity栈，应用进程，task。用户在Launcher程序里点击应用图标时，会通知ActivityManagerService启动应用的入口Activity，ActivityManagerService发现这个应用还未启动，则会通知Zygote进程孵化出应用进程，然后在这个应用进程里执行ActivityThread的main方法。应用进程接下来通知ActivityManagerService应用进程已启动，ActivityManagerService保存应用进程的一个代理对象，这样ActivityManagerService可以通过这个代理对象控制应用进程，然后ActivityManagerService通知应用进程创建入口Activity的实例，并执行它的生命周期方法。 总体启动流程图： 二、 开始请求执行启动Activity Activity.startActivity()Activity.startActivityForResult()Instrumentation.execStartActivity()ActivityManagerProxy.startActivity()ActivityManagerNative.onTransact()ActivityManagerService.startActivity() 2.1、Activity.startActivity()从Launcher启动应用的时候，经过调用会执行Activity中的startActivity。 12345678910111213141516[-&gt; Activity.java]......@Overridepublic void startActivity(Intent intent) &#123; this.startActivity(intent, null);&#125;......@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; ...... startActivityForResult(intent, -1); &#125;&#125; 2.2、Activity.startActivityForResult()1234567891011[-&gt; Activity.java] @Overridepublic void startActivityForResult( String who, Intent intent, int requestCode, @Nullable Bundle options) &#123; ...... Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, who, intent, requestCode, options); ......&#125; 可以发现execStartActivity方法传递的几个参数：this，为启动Activity的对象；contextThread，为Binder对象，是主进程的context对象；token，也是一个Binder对象，指向了服务端一个ActivityRecord对象；target，为启动的Activity；intent，启动的Intent对象；requestCode，请求码；options，参数； 2.3、Instrumentation.execStartActivity()1234567891011121314151617[-&gt; Instrumentation.java] ......public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; ...... try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; ......&#125; 关于 ActivityManagerNative.getDefault()返回的是? 1234567 [-&gt;ActivityManagerNative.java]/** * Retrieve the system's default/global activity manager. */static public IActivityManager getDefault() &#123; return gDefault.get();&#125; 直接返回的是gDefault.get()，那么gDefault又是什么呢？ 1234567891011121314 [-&gt;ActivityManagerNative.java] private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(\"activity\"); if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125;&#125;; 可以发现启动过asInterface()方法创建，然后我们继续看一下asInterface方法的实现： 123456789101112 static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj);&#125; 最后直接返回一个对象，此处startActivity()的共有10个参数, 下面说说每个参数传递AMP.startActivity()每一项的对应值: caller: 当前应用的ApplicationThread对象mAppThread;callingPackage: 调用当前ContextImpl.getBasePackageName(),获取当前Activity所在包名;intent: 这便是启动Activity时,传递过来的参数;resolvedType: 调用intent.resolveTypeIfNeeded而获取;resultTo: 来自于当前Activity.mTokenresultWho: 来自于当前Activity.mEmbeddedIDrequestCode = -1;startFlags = 0;profilerInfo = null;options = null; 好吧，最后直接返回一个对象，而继承与IActivityManager，到了这里就引出了我们android系统中很重要的一个概念：Binder机制。我们知道应用进程与SystemServer进程属于两个不同的进程，进程之间需要通讯，android系统采取了自身设计的Binder机制，这里的和ActivityManagerNative都是继承与IActivityManager的而SystemServer进程中的ActivityManagerService对象则继承与ActivityManagerNative。简单的表示：Binder接口 –&gt; ActivityManagerNative/ –&gt; ActivityManagerService； 这样，ActivityManagerNative与相当于一个Binder的客户端而ActivityManagerService相当于Binder的服务端，这样当ActivityManagerNative调用接口方法的时候底层通过Binder driver就会将请求数据与请求传递给server端，并在server端执行具体的接口逻辑。需要注意的是Binder机制是单向的，是异步的，也就是说只能通过client端向server端传递数据与请求而不用等待服务端的返回，也无法返回，那如果SystemServer进程想向应用进程传递数据怎么办？这时候就需要重新定义一个Binder请求以SystemServer为client端，以应用进程为server端，这样就是实现了两个进程之间的双向通讯。 好了，说了这么多我们知道这里的ActivityManagerNative是ActivityManagerService在应用进程的一个client就好了，通过它就可以滴啊用ActivityManagerService的方法了。 2.4、ActivityManagerProxy.startActivity()ActivityManagerNative.getDefault()方法会返回一个对象，那么我们看一下对象的startActivity方法： 12345678910111213[-&gt; ActivityManagerNative.java :: ActivityManagerProxy]class ActivityManagerProxy implements IActivityManager&#123;... public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; ...... mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); ......&#125;...&#125; 2.5、ActivityManagerNative.onTransact()1234567891011121314[-&gt; ActivityManagerNative.java] @Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case START_ACTIVITY_TRANSACTION: &#123; ...... int result = startActivity(app, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options); ...... &#125; ...... &#125; 这里就涉及到了具体的Binder数据传输机制了，我们不做过多的分析，知道通过数据传输之后就会调用SystemServer进程的ActivityManagerService的startActivity就好了。 以上其实都是发生在应用进程中，下面开始调用的ActivityManagerService的执行时发生在SystemServer进程。 三、 ActivityManagerService接收启动Activity的请求 ActivityManagerService.startActivity()ActivityStarter.startActivityMayWait()ActivityStarter.startActivityLocked()ActivityStarter.startActivityUnchecked()ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()ActivityStack.resumeTopActivityUncheckedLocked()ActivityStack.resumeTopActivityInnerLocked()–&gt;ActivityStackSupervisor.pauseBackStacks() [if (mResumedActivity != null)]–&gt;ActivityStackSupervisor.startSpecificActivityLocked() [if (mResumedActivity == null)] 3.1、ActivityManagerService.startActivity() 12345678910111213141516171819202122232425262728293031323334[-&gt; ActivityManagerService.java] public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125; @Overridepublic final int startActivityAsCaller(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, boolean ignoreTargetSecurity, int userId) &#123; ...... try &#123; int ret = mActivityStarter.startActivityMayWait(null, targetUid, targetPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null, null, null, bOptions, ignoreTargetSecurity, userId, null, null); return ret; &#125; ......&#125;final int startActivity(Intent intent, ActivityStackSupervisor.ActivityContainer container) &#123; enforceNotIsolatedCaller(\"ActivityContainer.startActivity\"); final int userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), mStackSupervisor.mCurrentUser, false, ActivityManagerService.ALLOW_FULL_ONLY, \"ActivityContainer\", null); ...... return mActivityStarter.startActivityMayWait(null, -1, null, intent, mimeType, null, null, null, null, 0, 0, null, null, null, null, false, userId, container, null);&#125; 可以看到这里只是进行了一些关于userid的逻辑判断，然后就调用mStackSupervisor.startActivityMayWait方法，此处mStackSupervisor的数据类型为ActivityStackSupervisor。当程序运行到这里时, ASS.startActivityMayWait的各个参数取值如下: caller = ApplicationThreadProxy, 用于跟调用者进程ApplicationThread进行通信的binder代理类.callingUid = -1;callingPackage = ContextImpl.getBasePackageName(),获取调用者Activity所在包名intent: 这是启动Activity时传递过来的参数;resolvedType = intent.resolveTypeIfNeededvoiceSession = null;voiceInteractor = null;resultTo = Activity.mToken, 其中Activity是指调用者所在Activity, mToken对象保存自己所处的ActivityRecord信息resultWho = Activity.mEmbeddedID, 其中Activity是指调用者所在ActivityrequestCode = -1;startFlags = 0;profilerInfo = null;outResult = null;config = null;options = null;ignoreTargetSecurity = false;userId = AMS.handleIncomingUser, 当调用者userId跟当前处于同一个userId,则直接返回该userId;当不相等时则根据调用者userId来决定是否需要将callingUserId转换为mCurrentUserId.iContainer = null;inTask = null; 下面我们来看一下这个方法的具体实现： 3.2、ActivityStarter.startActivityMayWait()1234567891011121314151617181920212223242526272829303132333435[-&gt;ActivityStarter.java]final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config, Bundle bOptions, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) &#123; ...... // Save a copy in case ephemeral needs it final Intent ephemeralIntent = new Intent(intent); // Don't modify the client's object! intent = new Intent(intent); ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId); ...... // Collect information about the target of the Intent. ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo); ActivityOptions options = ActivityOptions.fromBundle(bOptions); ActivityStackSupervisor.ActivityContainer container = (ActivityStackSupervisor.ActivityContainer)iContainer; ...... final ActivityRecord[] outRecord = new ActivityRecord[1]; int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, container, inTask); ...... return res; &#125;&#125; 该过程主要功能：通过resolveActivity来获取ActivityInfo信息, 然后再进入ASS.startActivityLocked().先来看看 3.2.1、ActivityStackSupervisor.resolveActivity()1234567891011121314151617181920[-&gt;ActivityStackSupervisor.java] ResolveInfo resolveIntent(Intent intent, String resolvedType, int userId) &#123; return resolveIntent(intent, resolvedType, userId, 0);&#125;ResolveInfo resolveIntent(Intent intent, String resolvedType, int userId, int flags) &#123; try &#123; return AppGlobals.getPackageManager().resolveIntent(intent, resolvedType, PackageManager.MATCH_DEFAULT_ONLY | flags | ActivityManagerService.STOCK_PM_FLAGS, userId); &#125; catch (RemoteException e) &#123; &#125; return null;&#125;ActivityInfo resolveActivity(Intent intent, String resolvedType, int startFlags, ProfilerInfo profilerInfo, int userId) &#123; final ResolveInfo rInfo = resolveIntent(intent, resolvedType, userId); return resolveActivity(intent, rInfo, startFlags, profilerInfo);&#125; 3.2.2、PackageManagerService.resolveIntent()AppGlobals.getPackageManager()经过函数层层调用，获取的是ApplicationPackageManager对象。经过binder IPC调用，最终会调用PackageManagerService对象。故此时调用方法为PMS.resolveIntent(). 12345678910111213141516171819202122232425262728293031323334353637383940[-&gt; PackageManagerService.java] @Overridepublic ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) &#123; try &#123; ...... final List&lt;ResolveInfo&gt; query = queryIntentActivitiesInternal(intent, resolvedType, flags, userId); ...... final ResolveInfo bestChoice = chooseBestActivity(intent, resolvedType, flags, query, userId); return bestChoice; &#125; ......&#125; private @NonNull List&lt;ResolveInfo&gt; queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int userId) &#123; ...... ComponentName comp = intent.getComponent(); if (comp == null) &#123; if (intent.getSelector() != null) &#123; intent = intent.getSelector(); comp = intent.getComponent(); &#125; &#125; if (comp != null) &#123; final List&lt;ResolveInfo&gt; list = new ArrayList&lt;ResolveInfo&gt;(1); final ActivityInfo ai = getActivityInfo(comp, flags, userId); if (ai != null) &#123; final ResolveInfo ri = new ResolveInfo(); ri.activityInfo = ai; list.add(ri); &#125; return list; &#125; ......&#125; ActivityStackSupervisor.resolveActivity()方法的核心功能是找到相应的Activity组件，并保存到intent对象。 3.3、ActivityStarter.startActivityLocked()继续ActivityStarter.startActivityMayWait()个方法中执行了启动Activity的一些其他逻辑判断，在经过判断逻辑之后调用startActivityLocked方法： 1234567891011121314151617181920212223242526272829[-&gt;ActivityStarter.java] final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) &#123; ...... ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; ...... ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, mSupervisor, container, options, sourceRecord); ...... try &#123; mService.mWindowManager.deferSurfaceLayout(); err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); &#125; ...... return err;&#125; 这个方法中主要构造了ActivityManagerService端的Activity对象–&gt;ActivityRecord，并根据Activity的启动模式执行了相关逻辑。然后调用了startActivityUncheckedLocked方法： 3.4、ActivityStarter.startActivityUnchecked()12345678910111213141516171819202122232425262728293031323334353637[-&gt;ActivityStarter.java] private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) &#123; ...... boolean newTask = false; ...... mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions); if (mDoResume) &#123; if (!mLaunchTaskBehind) &#123; // ...... mService.setFocusedActivityLocked(mStartActivity, \"startedActivity\"); &#125; final ActivityRecord topTaskActivity = mStartActivity.task.topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123; // ...... mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); // ....... mWindowManager.executeAppTransition(); &#125; else &#123; //3.6 ActivityStackSupervisor.resumeFocusedStackTopActivityLocked() mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); &#125; &#125; else &#123; mTargetStack.addRecentActivityLocked(mStartActivity); &#125; mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack); mSupervisor.handleNonResizableTaskIfNeeded( mStartActivity.task, preferredLaunchStackId, mTargetStack.mStackId); return START_SUCCESS;&#125; 找到或创建新的Activit所属于的Task对象，之后调用ActivityStack.startActivityLocked() 3.4.1、ActivityStack.startActivityLocked()1234567891011121314151617181920212223[-&gt; ActivityStack.java] final void startActivityLocked(ActivityRecord r, boolean newTask, boolean keepCurTransition, ActivityOptions options) &#123; ...... &#125; else &#123; // If this is the first activity, don't do any fancy animations, // because there is nothing for it to animate on top of. addConfigOverride(r, task); ...... &#125; ......&#125; void addConfigOverride(ActivityRecord r, TaskRecord task) &#123; final Rect bounds = task.updateOverrideConfigurationFromLaunchBounds(); // TODO: VI deal with activity mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind, bounds, task.mOverrideConfig, task.mResizeMode, r.isAlwaysFocusable(), task.isHomeTask(), r.appInfo.targetSdkVersion, r.mRotationAnimationHint); r.taskConfigOverride = task.mOverrideConfig;&#125; 3.5、ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()123456789101112 [-&gt;ActivityStackSupervisor.java] boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) &#123; mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; return false;&#125; 3.6、ActivityStack.resumeTopActivityUncheckedLocked() inResumeTopActivity用于保证每次只有一个Activity执行resumeTopActivityLocked()操作. 123456789101112131415161718192021[-&gt;ActivityStack.java] boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; // Don't even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123; mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); &#125; result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result;&#125; 3.7、ActivityStack.resumeTopActivityInnerLocked()说明：启动一个新Activity时，如果界面还存在其它的Activity，那么必须先中断其它的Activity。因此，除了第一个启动的Home界面对应的Activity外，其它的Activity均需要进行此操作，当系统启动第一个Activity，即Home时，mResumedActivity的值才会为null。经过一系列处理逻辑之后最终调用了startPausingLocked方法，这个方法作用就是让系统中栈中的Activity执行onPause方法。 12345678910111213141516 [-&gt;ActivityStack.java] private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; ...... // We need to start pausing the current activity so the top one can be resumed... final boolean dontWaitForPause = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != 0; boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, dontWaitForPause); if (mResumedActivity != null) &#123; pausing |= startPausingLocked(userLeaving, false, next, dontWaitForPause); &#125; ...... else &#123; ...... mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125;&#125; 3.8、ActivityStackSupervisor.pauseBackStacks()暂停所有处于后台栈的所有Activity。 12345678910111213141516 [-&gt;ActivityStackSupervisor.java] boolean pauseBackStacks(boolean userLeaving, ActivityRecord resuming, boolean dontWait) &#123; boolean someActivityPaused = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFocusedStack(stack) &amp;&amp; stack.mResumedActivity != null) &#123; ...... someActivityPaused |= stack.startPausingLocked(userLeaving, false, resuming, dontWait); &#125; &#125; &#125; return someActivityPaused;&#125; 四、执行栈顶Activity的onPause方法 ActivityStack.startPausingLocked()ActivityThread.schedulePauseActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()-&gt;ActivityThread.handlePauseActivity()–&gt;ActivityThread.performPauseActivity()—-&gt;ActivityThread.performPauseActivityIfNeeded()—-&gt; Instrumentation.callActivityOnPause()—-&gt; Activity.performPause()—-&gt; Activity.onPause()–&gt;ActivityManagerService.activityPaused()—-&gt;ActivityStack.activityPausedLocked()—-&gt;ActivityStack.completePauseLocked()—-&gt;ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()—-&gt;ActivityStack.resumeTopActivityUncheckedLocked()—-&gt;ActivityStack.resumeTopActivityInnerLocked()—-&gt;ActivityStackSupervisor.startSpecificActivityLocked() 4.1、ActivityStack.startPausingLocked()123456789101112 [-&gt;ActivityStack.java] final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, ActivityRecord resuming, boolean dontWait) &#123; ...... try &#123; ...... mService.updateUsageStats(prev, false); prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); &#125; ......&#125; 可以看到这里执行了pre.app.thread.schedulePauseActivity方法，通过分析不难发现这里的thread是一个IApplicationThread类型的对象，而在ActivityThread中也定义了一个ApplicationThread的类，其继承了IApplicationThread，并且都是Binder对象，不难看出这里的IAppcation是一个Binder的client端而ActivityThread中的ApplicationThread是一个Binder对象的server端，所以通过这里的thread.schedulePauseActivity实际上调用的就是ApplicationThread的schedulePauseActivity方法。 这里的ApplicationThread可以和ActivityManagerNative对于一下： 通过ActivityManagerNative –&gt; ActivityManagerService实现了应用进程与SystemServer进程的通讯 通过AppicationThread &lt;– IApplicationThread实现了SystemServer进程与应用进程的通讯 然后我们继续看一下ActivityThread中schedulePauseActivity的具体实现： 4.2、ActivityThread.schedulePauseActivity()12345678910111213 [-&gt;ActivityThread.java] public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) &#123; int seq = getLifecycleSeq(); if (DEBUG_ORDER) Slog.d(TAG, \"pauseActivity \" + ActivityThread.this + \" operation received seq: \" + seq); sendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? USER_LEAVING : 0) | (dontReport ? DONT_REPORT : 0), configChanges, seq);&#125; 4.3、ActivityThread.sendMessage()12345 [-&gt;ActivityThread.java] private void sendMessage(int what, Object obj, int arg1, int arg2, int seq) &#123; ...... mH.sendMessage(msg);&#125; 最终调用了mH的sendMessage方法，mH是在ActivityThread中定义的一个Handler对象，主要处理SystemServer进程的消息，我们看一下其handleMessge方法的实现： 4.4、[ActivityThread.handleMessage() : mH]12345678910111213[-&gt;ActivityThread.java : mH] public void handleMessage(Message msg) &#123; switch (msg.what) &#123; ...... case PAUSE_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\"); SomeArgs args = (SomeArgs) msg.obj; handlePauseActivity((IBinder) args.arg1, false, (args.argi1 &amp; USER_LEAVING) != 0, args.argi2, (args.argi1 &amp; DONT_REPORT) != 0, args.argi3); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; 可以发现其调用了handlePauseActivity方法： 4.5、ActivityThread.handlePauseActivity()123456789101112131415161718[-&gt;ActivityThread.java]private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport, int seq) &#123; ActivityClientRecord r = mActivities.get(token); ...... performPauseActivity(token, finished, r.isPreHoneycomb(), \"handlePauseActivity\"); ...... // Tell the activity manager we have paused. if (!dontReport) &#123; try &#123; ActivityManagerNative.getDefault().activityPaused(token); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; mSomeActivitiesChanged = true; &#125;&#125; 然后在方法体内部通过调用performPauseActivity方法来实现对栈顶Activity的onPause生命周期方法的回调，可以具体看一下他的实现： 4.6、ActivityThread.performPauseActivity()123456789101112131415 [-&gt;ActivityThread.java] final Bundle performPauseActivity(ActivityClientRecord r, boolean finished, boolean saveState, String reason) &#123; ...... performPauseActivityIfNeeded(r, reason); ......&#125;private void performPauseActivityIfNeeded(ActivityClientRecord r, String reason) &#123; ...... try &#123; r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); ......&#125; 这样回到了mInstrumentation的callActivityOnPuase方法： 4.7、Instrumentation.callActivityOnPuase()1234 [-&gt;Instrumentation.java]public void callActivityOnPause(Activity activity) &#123; activity.performPause();&#125; 原来最终回调到了Activity的performPause方法： 4.7、Activity.performPause()123456789101112131415[-&gt;Activity.java] final void performPause() &#123; mDoReportFullyDrawn = false; mFragments.dispatchPause(); mCalled = false; onPause(); mResumed = false; if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123; throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onPause()\"); &#125; mResumed = false;&#125; 终于，太不容易了，回调到了Activity的onPause方法，哈哈，Activity生命周期中的第一个生命周期方法终于被我们找到了。。。。也就是说我们在启动一个Activity的时候最先被执行的是栈顶的Activity的onPause方法。记住这点吧，面试的时候经常会问到类似的问题。 然后回到我们的handlePauseActivity方法，在该方法的最后面执行了ActivityManagerNative.getDefault().activityPaused(token);方法，这是应用进程告诉服务进程，栈顶Activity已经执行完成onPause方法了，通过前面我们的分析，我们知道这句话最终会被ActivityManagerService的activityPaused方法执行。 123456789101112 [-&gt;ActivityManagerService.java] @Overridepublic final void activityPaused(IBinder token) &#123; final long origId = Binder.clearCallingIdentity(); synchronized(this) &#123; ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) &#123; stack.activityPausedLocked(token, false); &#125; &#125; Binder.restoreCallingIdentity(origId);&#125; 以发现，该方法内部会调用ActivityStack的activityPausedLocked方法，好吧，看一下activityPausedLocked方法的实现，然后执行了completePauseLocked方法： 1234567891011121314151617181920 private void completePauseLocked(boolean resumeNext, ActivityRecord resuming) &#123; ...... if (resumeNext) &#123; final ActivityStack topStack = mStackSupervisor.getFocusedStack(); if (!mService.isSleepingOrShuttingDownLocked()) &#123; mStackSupervisor.resumeFocusedStackTopActivityLocked(topStack, prev, null); &#125; else &#123; mStackSupervisor.checkReadyForSleepLocked(); ActivityRecord top = topStack.topRunningActivityLocked(); if (top == null || (prev != null &amp;&amp; top != prev)) &#123; // If there are no more activities available to run, do resume anyway to start // something. Also if the top activity on the stack is not the just paused // activity, we need to go ahead and resume it to ensure we complete an // in-flight app switch. mStackSupervisor.resumeFocusedStackTopActivityLocked(); &#125; &#125; &#125; ......&#125; 经过了一系列的逻辑之后，又调用了resumeTopActivitiesLocked方法，又回到了第三步中解析的方法中了，这样经过 ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()–&gt;ActivityStack.resumeTopActivityUncheckedLocked() –&gt;ActivityStack.resumeTopActivityInnerLocked() –&gt;ActivityStackSupervisor.startSpecificActivityLocked() 好吧，我们看一下startSpecificActivityLocked的具体实现： 1234567891011121314151617181920212223242526 [-&gt;ActivityStack.java] void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; ...... realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when starting activity \" + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true);&#125; 可以发现在这个方法中，首先会判断一下需要启动的Activity所需要的应用进程是否已经启动，若启动的话，则直接调用realStartAtivityLocked方法，否则调用startProcessLocked方法，用于启动应用进程。这样关于启动Activity时的第三步骤就已经执行完成了，这里主要是实现了对栈顶Activity执行onPause方法，而这个方法首先判断需要启动的Activity所属的进程是否已经启动，若已经启动则直接调用启动Activity的方法，否则将先启动Activity的应用进程，然后在启动该Activity。 五、创建Activity所属的应用进程 ActivityManagerService.startProcessLocked()Process.start() -&gt; 创建进程Process.startViaZygote() -&gt; 创建进程Process.zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote) -&gt; 创建进程ActivityThread.main()ActivityThread.attach()ActivityManagerProxy.attachApplication()ActivityManagerNative.onTransact()ActivityManagerService.attachApplication()ActivityManagerService.attachApplicationLocked()ApplicationThreadNative.ApplicationThreadProxy.bindApplication()ApplicationThreadNative.onTransact()ActivityThread.ApplicationThread.bindApplication()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleBindApplication() 5.1、ActivityManagerService.startProcessLocked()123456789101112131415161718192021222324 [-&gt;ActivityManagerService.java] private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) &#123; startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */, null /* entryPoint */, null /* entryPointArgs */);&#125;private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123; ...... // Start the process. It will either succeed and return a result containing // the PID of the new process, or else throw a RuntimeException. boolean isActivityProcess = (entryPoint == null); if (entryPoint == null) entryPoint = \"android.app.ActivityThread\"; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" + app.processName); checkTime(startTime, \"startProcess: asking zygote to start proc\"); Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); checkTime(startTime, \"startProcess: returned from zygote!\"); ...... &#125; 可以发现其经过一系列的初始化操作之后调用了Process.start方法，并且传入了启动的类名“android.app.ActivityThread”: 5.2、Process.start()12345678910111213141516171819202122 [-&gt;Process.java] public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) &#123; try &#123; return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; Log.e(LOG_TAG, \"Starting VM process through Zygote failed\"); throw new RuntimeException( \"Starting VM process through Zygote failed\", ex); &#125;&#125; 然后调用了startViaZygote方法： 5.3、Process.startViaZygote()12345678910111213141516171819 [-&gt;Process.java] private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx &#123; synchronized(Process.class) &#123; ...... return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125;&#125; 继续查看一下zygoteSendArgsAndGetResult方法的实现： 5.4、Process.zygoteSendArgsAndGetResult()12345678910111213141516171819 [-&gt;Process.java] private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; ...... // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); // Always read the entire result from the input stream to avoid leaving // bytes in the stream for future process starts to accidentally stumble // upon. //等待socket服务端（即zygote）返回新创建的进程pid; result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); ...... return result; ......&#125; 这个方法的主要功能是通过socket通道向Zygote进程发送一个参数列表，然后进入阻塞等待状态，直到远端的socket服务端发送回来新创建的进程pid才返回。 5.5、Process.openZygoteSocketIfNeeded()12345678910111213141516171819202122232425262728293031 [-&gt;Process.java] private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123; try &#123; //向主zygote发起connect()操作 primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe); &#125; &#125; if (primaryZygoteState.matches(abi)) &#123; return primaryZygoteState; &#125; // The primary zygote didn't match. Try the secondary. if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123; try &#123; //当主zygote没能匹配成功，则采用第二个zygote，发起connect()操作 secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe); &#125; &#125; if (secondaryZygoteState.matches(abi)) &#123; return secondaryZygoteState; &#125; throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);&#125; openZygoteSocketIfNeeded(abi)方法是根据当前的abi来选择与zygote还是zygote64来进行通信。既然system_server进程的zygoteSendArgsAndGetResult()方法通过socket向Zygote进程发送消息，这是便会唤醒Zygote进程，来响应socket客户端的请求（即system_server端)具体详细过程可参考大神博客理解Android进程创建流程 和 Android四大组件与进程启动的关系大神是基于Android M，之后我会跟着大神的脚步站在巨人的肩膀上，完成Android N进程创建流程，估计变化不大加深自己理解。进程创建流程图：总结：可以发现其最终调用了Zygote并通过socket通信的方式让Zygote进程fork除了一个新的进程，并根据我们刚刚传递的”android.app.ActivityThread”字符串，反射出该对象并执行ActivityThread的main方法。这样我们所要启动的应用进程这时候其实已经启动了，但是还没有执行相应的初始化操作。 我们平时App-Crash常见的log就是从ActivityThread.main()抛出异常的,可参考文档：Android 7.1.2(Android N) Android系统启动流程。 java.lang.RuntimeException: Unable to start activity ComponentInfo{……} at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2665) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2726) at android.app.ActivityThread.-wrap12(ActivityThread.java) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1477) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:154) at android.app.ActivityThread.main(ActivityThread.java:6119) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:892) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:782) 为什么我们平时都将ActivityThread称之为ui线程或者是主线程，这里可以看出，应用进程被创建之后首先执行的是ActivityThread的main方法，所以我们将ActivityThread成为主线程。 好了，这时候我们看一下ActivityThread的main方法的实现逻辑。 5.6、ActivityThread.main()123456789101112131415161718192021222324252627 [-&gt;ActivityThread.java] public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); ...... Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125;&#125; 在main方法中主要执行了一些初始化的逻辑，并且创建了一个UI线程消息队列，这也就是为什么我们可以在主线程中随意的创建Handler而不会报错的原因，这里提出一个问题，大家可以思考一下：子线程可以创建Handler么？可以的话应该怎么做？然后执行了ActivityThread的attach方法，这里我们看一下attach方法执行了那些逻辑操作。 5.7、ActivityThread.attach()12345678910111213141516 private void attach(boolean system) &#123; ...... //此时进程名还是\"&lt;pre-initialized&gt;\" android.ddm.DdmHandleAppName.setAppName(\"&lt;pre-initialized&gt;\", UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); //创建对象 final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; //调用基于IActivityManager接口的Binder通道 mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; ......&#125; 5.8、ActivityManagerProxy .attachApplication()1234567891011[-&gt; ActivityManagerNative.java::ActivityManagerProxy]public void attachApplication(IApplicationThread app) throws RemoteException&#123;Parcel data = Parcel.obtain();Parcel reply = Parcel.obtain();data.writeInterfaceToken(IActivityManager.descriptor);data.writeStrongBinder(app.asBinder());mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0); reply.readException();data.recycle();reply.recycle();&#125; 5.9、ActivityManagerNative.onTransact()123456789101112131415161718[-&gt; ActivityManagerNative.java]public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;switch (code) &#123;... case ATTACH_APPLICATION_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); //获取ApplicationThread的binder代理类 ApplicationThreadProxy IApplicationThread app = ApplicationThreadNative.asInterface( data.readStrongBinder()); if (app != null) &#123; attachApplication(app); //此处是ActivityManagerService类中的方法 &#125; reply.writeNoException(); return true;&#125;&#125;&#125; 刚刚我们已经分析过对象是ActivityManagerService的Binder client，所以这里调用了attachApplication实际上就是通过Binder机制调用了ActivityManagerService的attachApplication，具体调用的过程，我们看一下ActivityManagerService是如何实现的： 5.10、ActivityManagerService.attachApplication()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 [-&gt;ActivityManagerService.java] @Overridepublic final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); //此处的thread便是ApplicationThreadProxy对象,用于跟前面通过Process.start()所创建的进程中ApplicationThread对象进行通信. attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125;&#125; private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; // 根据pid获取ProcessRecord ProcessRecord app; if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123; synchronized (mPidsSelfLocked) &#123; app = mPidsSelfLocked.get(pid); &#125; &#125; ...... //获取应用appInfo ApplicationInfo appInfo = app.instrumentationInfo != null ? app.instrumentationInfo : app.info; app.compat = compatibilityInfoForPackageLocked(appInfo); if (profileFd != null) &#123; profileFd = profileFd.dup(); &#125; ...... //绑定应用 thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked()); updateLruProcessLocked(app, false, null); &#125; ...... // See if the top visible activity is waiting to run in this process... if (normalMode) &#123; try &#123; if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; Slog.wtf(TAG, \"Exception thrown launching activities in \" + app, e); badApp = true; &#125; &#125; ...... return true;&#125; 下面,再来说说thread.bindApplication的过程. 5.11、ApplicationThreadProxy.bindApplication()123456789101112131415161718[-&gt; ApplicationThreadNative.java ::ApplicationThreadProxy]class ApplicationThreadProxy implements IApplicationThread &#123;... @Overridepublic final void bindApplication(String packageName, ApplicationInfo info, List&lt;ProviderInfo&gt; providers, ComponentName testName, ProfilerInfo profilerInfo, Bundle testArgs, IInstrumentationWatcher testWatcher, IUiAutomationConnection uiAutomationConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean restrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) throws RemoteException &#123; ...... mRemote.transact(BIND_APPLICATION_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125;...&#125; 5.12、ApplicationThreadNative.onTransact()12345678910111213141516[-&gt; ApplicationThreadNative.java]public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;switch (code) &#123;... case BIND_APPLICATION_TRANSACTION: &#123; ...... bindApplication(packageName, info, providers, testName, profilerInfo, testArgs, testWatcher, uiAutomationConnection, testMode, enableBinderTracking, trackAllocation, restrictedBackupMode, persistent, config, compatInfo, services, coreSettings); return true; &#125;...&#125; 5.13、ApplicationThread.bindApplication()[-&gt; ActivityThread.java ::ApplicationThread] 1234567891011121314151617181920 public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123; if (services != null) &#123; // Setup the service cache in the ServiceManager ServiceManager.initServiceCache(services); &#125; setCoreSettings(coreSettings); AppBindData data = new AppBindData(); ...... sendMessage(H.BIND_APPLICATION, data);&#125; 5.14、ActivityThread.handleBindApplication()当主线程收到H.BIND_APPLICATION,则调用handleBindApplication 12345678910111213141516171819202122232425262728293031323334353637383940414243 [-&gt; ActivityThread.java ::H] private void handleBindApplication(AppBindData data) &#123; ...... mBoundApplication = data; mConfiguration = new Configuration(data.config); mCompatConfiguration = new Configuration(data.config); //设置进程名, 也就是说进程名是在进程真正创建以后的BIND_APPLICATION过程中才取名 // send up app name; do this *before* waiting for debugger Process.setArgV0(data.processName); android.ddm.DdmHandleAppName.setAppName(data.processName, UserHandle.myUserId()); ...... 获取LoadedApk对象 data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo); ...... //创建ContextImpl上下文 final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); updateLocaleListFromAppContext(appContext, mResourcesManager.getConfiguration().getLocales()); ...... try &#123; // If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. // 此处data.info是指LoadedApk, 通过反射创建目标应用Application对象 Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ...... // Do this after providers, since instrumentation tests generally start their // test thread at this point, and we don't want that racing. try &#123; mInstrumentation.onCreate(data.instrumentationArgs); &#125; ...... try &#123; mInstrumentation.callApplicationOnCreate(app); &#125; ......&#125; 在handleBindApplication()的过程中,会同时设置以下两个值: LoadedApk.mApplicationAT.mInitialApplication 图示总结： 六、执行启动Acitivity ActivityStackSupervisor.attachApplicationLocked()ActivityStackSupervisor.realStartActivityLocked()IApplicationThread.scheduleLaunchActivity()ActivityThread.ApplicationThread.scheduleLaunchActivity()ActivityThread.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleLauncherActivity()ActivityThread.performLauncherActivity()Instrumentation.callActivityOnCreate()Activity.performCreate()Activity.onCreate() 在第五节AMS.startProcessLocked()整个过程，创建完新进程后会在新进程中调用AMP.attachApplication ，该方法经过binder ipc后调用到AMS.attachApplicationLocked。该方法执行了一系列的初始化操作，在执行完bindApplication()之后进入ActivityStackSupervisor.attachApplicationLocked()，这样我们整个应用进程已经启动起来了。终于可以开始activity的启动逻辑了。关系图：ActivityThread简介首先看一下attachApplicationLocked方法的实现： 6.1、ActivityStackSupervisor.attachApplicationLocked()1234567891011121314151617181920212223242526272829 [-&gt;ActivityStackSupervisor.java] boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123; final String processName = app.processName; boolean didSomething = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFocusedStack(stack)) &#123; continue; &#125; ActivityRecord hr = stack.topRunningActivityLocked(); if (hr != null) &#123; if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; if (realStartActivityLocked(hr, app, true, true)) &#123; didSomething = true; &#125; &#125; ...... &#125; &#125; &#125; &#125; if (!didSomething) &#123; ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); &#125; return didSomething;&#125; 可以发现其内部调用了realStartActivityLocked方法，通过名字可以知道这个方法应该就是用来启动Activity的，看一下这个方法的实现逻辑： 6.2、ActivityStackSupervisor.realStartActivityLocked()12345678910111213141516 [-&gt;ActivityStackSupervisor.java] final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ...... app.forceProcessStateUpTo(mService.mTopProcessState); app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ...... return true;&#125; 可以发现与第四节执行栈顶Activity onPause时类似，这里也是通过调用IApplicationThread的方法实现的，这里调用的是scheduleLaunchActivity方法，所以真正执行的是ActivityThread中的scheduleLaunchActivity。 6.3、ApplicationThread.scheduleLaunchActivity()1234567891011121314151617[-&gt; ActivityThread.java :ApplicationThread] public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); ...... updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 6.4、H.handleMessage12345678910111213[-&gt; ActivityThread.java ::H] public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\"); &#125; break; ...... &#125; 6.5、ActivityThread.handleLaunchActivity()ActivityThread接收到SystemServer进程的消息之后会通过其内部的Handler对象分发消息，经过一系列的分发之后调用了ActivityThread的handleLaunchActivity方法： 1234567891011121314151617[-&gt; ActivityThread.java] private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; ...... // Initialize before creating the activity WindowManagerGlobal.initialize(); Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); &#125; ......&#125; 可以发现这里调用了performLauncherActivity，看名字应该就是执行Activity的启动操作了…… 6.6、ActivityThread.performLaunchActivity()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[-&gt; ActivityThread.java] private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; ...... try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); ...... if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); ...... activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); ...... activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ...... //生命周期onStart、onresume if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; ...... return activity;&#125; 可以发现这里我们需要的Activity对象终于是创建出来了，然后在代码中其调用Instrumentation的callActivityOnCreate方法。 6.7、Instrumentation.callActivityOnCreate()1234567 [-&gt;Instrumentation.java] public void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) &#123; prePerformCreate(activity); activity.performCreate(icicle, persistentState); postPerformCreate(activity);&#125; 然后执行activity的performCreate方法…… 6.8、Activity.performCreate()123456 final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123; restoreHasCurrentPermissionRequest(icicle); onCreate(icicle, persistentState); mActivityTransitionState.readState(icicle); performCreateCommon();&#125; 简要说明剩余生命周期：回到我们的performLaunchActivity方法，其在调用了mInstrumentation.callActivityOnCreate方法之后又调用了activity.performStart()方法，看一下他的实现方式： 123456789101112131415161718[-&gt;Activity.java]final void performStart() &#123; mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions()); mFragments.noteStateNotSaved(); mCalled = false; mFragments.execPendingActions(); mInstrumentation.callActivityOnStart(this); if (!mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onStart()\"); &#125; mFragments.dispatchStart(); mFragments.reportLoaderStart(); ...... mActivityTransitionState.enterReady(this);&#125; 还是通过Instrumentation调用callActivityOnStart方法： 12345[-&gt;Instrumentation.java]public void callActivityOnStart(Activity activity) &#123; activity.onStart();&#125; 然后是直接调用activity的onStart方法，第三个生命周期方法出现了，O(∩_∩)O 还是回到我们刚刚的handleLaunchActivity方法，在调用完performLaunchActivity方法之后，其有吊用了handleResumeActivity方法，好吧，看名字应该是回调Activity的onResume方法的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[-&gt; ActivityThread.java] final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ActivityClientRecord r = mActivities.get(token); ...... // TODO Push resumeArgs into the activity for consideration r = performResumeActivity(token, clearHide, reason); ..... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) &#123; a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity // in addView-&gt;ViewRootImpl#setView. If we are instead reusing // the decor view we have to notify the view root that the // callbacks may have changed. ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) &#123; impl.notifyChildRebuilt(); &#125; &#125; if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. &#125; else if (!willBeVisible) &#123; if (localLOGV) Slog.v( TAG, \"Launch \" + r + \" mStartedActivity set\"); r.hideForNow = true; &#125; if (!r.onlyLocalRequest) &#123; r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v( TAG, \"Scheduling idle handler for \" + r); //线程空闲，也就是activity创建完毕之后，它会执行queueIdle里面的代码。 Looper.myQueue().addIdleHandler(new Idler()); &#125; &#125; 可以发现其resumeActivity的逻辑调用到了performResumeActivity方法，我们来看一下performResumeActivity是如何实现的。 1234567891011121314151617181920212223242526272829[-&gt; ActivityThread.java] public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide, String reason) &#123; ActivityClientRecord r = mActivities.get(token); if (localLOGV) Slog.v(TAG, \"Performing resume of \" + r + \" finished=\" + r.activity.mFinished); if (r != null &amp;&amp; !r.activity.mFinished) &#123; ... try &#123; ...... r.activity.performResume(); for (int i = mRelaunchingActivities.size() - 1; i &gt;= 0; i--) &#123; final ActivityClientRecord relaunching = mRelaunchingActivities.get(i); if (relaunching.token == r.token &amp;&amp; relaunching.onlyLocalRequest &amp;&amp; relaunching.startsNotResumed) &#123; relaunching.startsNotResumed = false; &#125; &#125; EventLog.writeEvent(LOG_AM_ON_RESUME_CALLED, UserHandle.myUserId(), r.activity.getComponentName().getClassName(), reason); r.paused = false; r.stopped = false; r.state = null; r.persistentState = null; &#125; ...... &#125; return r; &#125; 在方法体中，最终调用了r.activity.performResume()方法，好吧，这个方法是Activity中定义的方法，我们需要在Activity中查看这个方法的具体实现： 12345678[-&gt; Activity.java]final void performResume() &#123; performRestart(); ... mInstrumentation.callActivityOnResume(this); ... &#125; 可以看到第一个分支走了performRestart()，这个方法即时onRestart()生命周期。 12345678910111213141516171819202122 final void performRestart() &#123; ... mInstrumentation.callActivityOnRestart(this); performStart();&#125; final void performRestart() &#123; mFragments.noteStateNotSaved(); if (mToken != null &amp;&amp; mParent == null) &#123; // No need to check mStopped, the roots will check if they were actually stopped. WindowManagerGlobal.getInstance().setStoppedState(mToken, false /* stopped */); &#125; if (mStopped) &#123; mStopped = false; ...... mCalled = false; mInstrumentation.callActivityOnRestart(this); ...... performStart(); &#125; &#125; 可以看到首先判断当前activity是否为Stopped状态，是才会走OnRestart()-&gt;Onstart()生命周期。 继续看下performResume()第二个分支，又是熟悉的味道，通过Instrumentation来调用了callActivityOnResume方法。。。 12345678910111213141516[-&gt;Instrumentation.java]public void callActivityOnResume(Activity activity) &#123; activity.mResumed = true; activity.onResume(); if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); am.match(activity, activity, activity.getIntent()); &#125; &#125; &#125; &#125; O(∩_∩)O，第四个生命周期方法出现了，onResume方法。。。 终于回调onResume方法了，这时候我们的界面应该已经展示出来了，照理来说我们的Activity应该已经启动完成了，但是还没有。 有一个问题，Activity a 启动 Activity b 会触发那些生命周期方法？你可能会回答？b的onCreate onStart方法，onResume方法 a的onPause方法和onStop方法，onStop方法还没回调，O(∩_∩)O，对了缺少的就是对onStop方法的回调。 七、栈顶Activity执行onStop方法 Looper.myQueue().addIdleHandler(new Idler())Idler.queueIdle()ActivityManagerNative.getDefault().activityIdle()ActivityManagerService.activityIdle()ActivityStackSupervisor.activityIdleInternalLocked()ActivityStack.stopActivityLocked()IApplicationThread.scheduleStopActivity()ActivityThread.scheduleStopActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleStopActivity()ActivityThread.performStopActivityInner()ActivityThread.callCallActivityOnSaveInstanceState()Instrumentation.callActivityOnSaveInstanceState()Activity.performSaveInstanceState()Activity.onSaveInstanceState()Activity.performStop()Instrumentation.callActivityOnStop()Activity.onStop() 回到我们的handleResumeActivity方法，在方法体最后有这样的一代码： 1Looper.myQueue().addIdleHandler(new Idler()); 这段代码是异步消息机制相关的代码，我们可以看一下Idler对象的具体实现： 1234567891011121314151617181920212223242526private class Idler implements MessageQueue.IdleHandler &#123; @Override public final boolean queueIdle() &#123; ActivityClientRecord a = mNewActivities; ..... if (a != null) &#123; mNewActivities = null; IActivityManager am = ActivityManagerNative.getDefault(); ActivityClientRecord prev; do &#123; ...... if (a.activity != null &amp;&amp; !a.activity.mFinished) &#123; try &#123; am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; &#125; catch (RemoteException ex) &#123; // Ignore &#125; &#125; prev = a; a = a.nextIdle; prev.nextIdle = null; &#125; while (a != null); &#125; &#125; &#125; 这样当Messagequeue执行add方法之后就会回调其queueIdle()方法，我们可以看到在方法体中其调用了ActivityManagerNative.getDefault().activityIdle()，好吧，熟悉了Binder机制以后我们知道这段代码会执行到ActivityManagerService的activityIdle方法： 123456789101112131415161718192021@Overridepublic final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123; final long origId = Binder.clearCallingIdentity(); synchronized (this) &#123; ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) &#123; ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, false, config); if (stopProfiling) &#123; if ((mProfileProc == r.app) &amp;&amp; (mProfileFd != null)) &#123; try &#123; mProfileFd.close(); &#125; catch (IOException e) &#123; &#125; clearProfilerLocked(); &#125; &#125; &#125; &#125; Binder.restoreCallingIdentity(origId);&#125; 然后在activityIdle方法中又调用了ActivityStackSupervisor.activityIdleInternalLocked方法： 12345678910111213141516171819[-&gt;ActivityStackSupervisor.java]final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) &#123; ... for (int i = 0; i &lt; NS; i++) &#123; r = stops.get(i); final ActivityStack stack = r.task.stack; if (stack != null) &#123; if (r.finishing) &#123; stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false); &#125; else &#123; stack.stopActivityLocked(r); &#125; &#125; &#125; ... return r; &#125; 可以发现在其中又调用了ActivityStack.stopActivityLocked方法： 12345678final void stopActivityLocked(ActivityRecord r) &#123; if ((r.intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (r.info.flags&amp;ActivityInfo.FLAG_NO_HISTORY) != 0) &#123; ... r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags); ... &#125; &#125; 好吧，又是相同的逻辑通过IApplicationThread.scheduleStopActivity,最终调用了ActivityThread.scheduleStopActivity()方法。。。。 123456public final void scheduleStopActivity(IBinder token, boolean showWindow, int configChanges) &#123; sendMessage( showWindow ? H.STOP_ACTIVITY_SHOW : H.STOP_ACTIVITY_HIDE, token, 0, configChanges); &#125; 然后执行sendMessage方法，最终执行H（Handler）的sendMessage方法，并被H的handleMessge方法接收执行handleStopActivity方法。。。 123456private void handleStopActivity(IBinder token, boolean show, int configChanges) &#123; ... performStopActivityInner(r, info, show, true); ... &#125; 然后我们看一下performStopActivityInner的实现逻辑： 123456789101112131415[-&gt;ActivityThread.java]private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean keepShown, boolean saveState) &#123; ... if (!keepShown) &#123; try &#123; r.activity.performStop(); &#125; catch (Exception e) &#123; ...... &#125; r.stopped = true; &#125; &#125; &#125; 我们看一下performStopActivityInner中调用到的Activity方法的performStop方法 1234567891011final void performStop() &#123; if (!mStopped) &#123; ...... mFragments.dispatchStop(); mCalled = false; mInstrumentation.callActivityOnStop(this); ...... mStopped = true; &#125; mResumed = false; &#125; 还是通过Instrumentation来实现的，调用了它的callActivityOnStop方法。。 123public void callActivityOnStop(Activity activity) &#123; activity.onStop(); &#125; 生命周期方法onStop()出来了。 我们来看一下Activity 的生命周期： protected void onCreate(); protected void onRestart(); protected void onStart(); protected void onResume(); protected void onPause(); protected void onStop(); protected void onDestory(); 前面我们分析了onCreate()、onStart()、onRestart() 、onResume()、onPause()、onStop()。Activity 销毁时的 onDestroy() 回调都与前面的过程大同小异，这里就只列举相应的方法栈，不再继续描述。 Activity.finish()ActivityManagerNative.getDefault().finishActivity()ActivityManagerService.finishActivity()ActivityStack.requestFinishActivityLocked()ActivityStack.finishActivityLocked()ActivityStack.startPausingLocked()参考：Android源码解析之（十五）–&gt;Activity销毁流程 启动流程： 1、点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；2、system_server进程接收到请求后，向zygote进程发送创建进程的请求；3、Zygote进程fork出新的子进程，即App进程；4、App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；5、system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；6、App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；7、主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。 到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。 启动Activity较为复杂，后续介绍窗口加载渲染过程，可参考文档：【Android 7.1.2 (Android N) Activity-Window加载显示流程分析】 参考文档(特别感谢)：Android Activity启动过程分析Android源码解析之（十四）–&gt;Activity启动流程Android源码解析之（十五）–&gt;Activity销毁流程凯子哥带你学Framework–Activity启动过程全解析 深入理解Activity启动流程(一)–Activity启动的概要流程 Android 7.0 ActivityManagerService 启动Activity的过程 系列Activity生命周期的回调，你应该知道得更多！–Android源码剖析（上）Activity生命周期的回调，你应该知道得更多！–Android源码剖析（下）","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Android 系统启动流程 分析","slug":"Android-7-1-2-Android-N-Android系统启动流程","date":"2017-08-31T16:00:00.000Z","updated":"2018-03-23T07:18:14.000Z","comments":true,"path":"2017/09/01/Android-7-1-2-Android-N-Android系统启动流程/","link":"","permalink":"http://zhoujinjian.cc/2017/09/01/Android-7-1-2-Android-N-Android系统启动流程/","excerpt":"Android系统启动流程概述：基于Linux内核的android系统，在内核启动完成后将创建一个Init用户进程，实现了内核空间到用户空间的转变。init进程启动后会读取init.rc配置文件，通过fork系统调用启动init.rc文件配置的各个Service进程。init进程首先启动启动android的服务大管家ServiceManager服务，然后启动Zygote进程；然后是启动C++相关的本地服务，如SurfaceFlinger等。Zygote进程的启动开创了Java世界，无论是SystemServer进程还是android的应用进程都是Zygote的子进程，在Zygote进程启动完成后创建第一个进程SystemServer进程，SystemServer进程在main()方法中启动android的各大关键Java服务。当用户点击Luncher上的应用图标时，Luncher进程通过socket向Zygote进程发送进程创建请求，Zygote进程接受客户端的请求后，通过fork系统调用为应用程序创建相应的进程。","text":"Android系统启动流程概述：基于Linux内核的android系统，在内核启动完成后将创建一个Init用户进程，实现了内核空间到用户空间的转变。init进程启动后会读取init.rc配置文件，通过fork系统调用启动init.rc文件配置的各个Service进程。init进程首先启动启动android的服务大管家ServiceManager服务，然后启动Zygote进程；然后是启动C++相关的本地服务，如SurfaceFlinger等。Zygote进程的启动开创了Java世界，无论是SystemServer进程还是android的应用进程都是Zygote的子进程，在Zygote进程启动完成后创建第一个进程SystemServer进程，SystemServer进程在main()方法中启动android的各大关键Java服务。当用户点击Luncher上的应用图标时，Luncher进程通过socket向Zygote进程发送进程创建请求，Zygote进程接受客户端的请求后，通过fork系统调用为应用程序创建相应的进程。 源码：system/core/rootdir/ init.rc init.zygote64.rc system/core/init/ init.cpp init_parser.cpp signal_handler.cpp frameworks/base/cmds/app_process/ App_main.cpp frameworks/base/core/jni/ AndroidRuntime.cpp frameworks/base/core/java/com/android/internal/os/ ZygoteInit.java Zygote.java ZygoteConnection.java frameworks/base/core/java/com/android/internal/os/ ZygoteInit.java RuntimeInit.java Zygote.java frameworks/base/core/services/java/com/android/server/ SystemServer.java frameworks/base/core/jni/ com_android_internal_os_Zygote.cpp AndroidRuntime.cpp frameworks/base/services/java/com/android/server/ SystemServer.java frameworks/base/services/core/java/com/android/server/ SystemServiceManager.java ServiceThread.java am/ActivityManagerService.java frameworks/base/core/java/android/app/ ActivityThread.java LoadedApk.java ContextImpl.java frameworks/base/core/java/android/app/ ActivityThread.java LoadedApk.java ContextImpl.java frameworks/base/services/java/com/android/server/ SystemServer.java frameworks/base/services/core/java/com/android/server/ SystemServiceManager.java ServiceThread.java pm/Installer.java am/ActivityManagerService.java 博客原图链接一、Android概述Android系统非常庞大，底层是采用Linux作为基底，上层采用带有虚拟机的Java层，通过通过JNI技术，将上下打通，融为一体。下图是Google提供的一张经典的4层架构图，从下往上，依次分为Linux内核，系统库和Android Runtime，应用框架层，应用程序层这4层架构，每一层都包含大量的子模块或子系统。 二、系统启动Google提供的4层架构图，是非常经典，但只是如垒砖般的方式，简单地分层，而不足表达Android整个系统的启动过程，环环相扣的连接关系，本文更多的是以进程的视角，以分层的架构来诠释Android系统的全貌。 系统启动架构图 三、设备启动过程3.1、Bootloader引导 Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在ROM里的预设出代码开始执行，然后加载引导程序到RAM； Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件设备（如CPU、内存、Flash等）并且通过建立内存空间映射，为装载Linux内核准备合适的环境。一旦Linux内核装载完毕，Bootloader将会从内存中清除掉。如果用户在Bootloader运行期间，按下预定义的组合健，可以进入系统的更新模块。Android的下载更新可以选择进入Fastboot模式或者Recovery模式。 Fastboot是Android设计的一套通过USB来更新手机分区映像的协议，方便开发人员能快速更新指定的手机分区。但是一般的零售机上往往去掉了Fastboot，Google销售的开发机则带有Fastboot模块。Recovery模式是Android特有的升级系统。利用Recovery模式，手机可以进行恢复出厂设置或进行OTA、补丁和固件升级。进入Recovery模式实际上是启动了一个文本模式的Linux。 3.2、装载和启动Linux内核到这里才刚刚开始进入Android系统. 启动Kernel的0号进程：初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作；启动kthreadd进程（pid=2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。kthreadd进程是所有内核进程的鼻祖。 Android的boot.img存放的就是Linux内核和一个根文件系统。Bootloader会把boot.img映像装载进内存。然后Linux内核会执行整个系统的初始化，完成后装载根文件系统，最后启动Init进程。 3.3、启动Init进程Linux内核加载完毕后，会首先启动Init进程，Init进程是系统的第一个进程。在Init进程的启动过程中，会解析Linux的配置脚本init.rc文件，根据init.rc文件的内容，Init进程会装载Android的文件系统、创建系统目录。初始 化属性系统、启动Android系统重要的守护进程，这些进程包括USB守护进程、adb守护进程、vold守护进程、rild守护进程。 启动init进程(pid=1),是Linux系统的用户进程，init进程是所有用户进程的鼻祖。 init进程启动Media Server(多媒体服务)、servicemanager(binder服务管家)、bootanim(开机动画)等重要服务init进程还会孵化出installd、ueventd、adbd、等用户守护进程；init进程孵化出Zygote进程，Zygote进程是Android系统的首个Java进程，Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的。Android 7.0 init.rc的一点改变 - 哈哈的个人专栏 - CSDN博客 12345678910111213/system/core/rootdir/init.rc.....service ueventd /sbin/ueventdclass corecriticalseclabel u:r:ueventd:s0service healthd /sbin/healthdclass corecriticalseclabel u:r:healthd:s0group root system wakelock...... 3.4、启动Zygote进程 init进程初始化结束时，会启动Zygote进程。Zygote进程负责fork出应用进程，是所有应用进程的父进程。Zygote进程初始化时会创建Dalivik虚拟机、预装系统的资源文件和Java类。所有从Zygote进程fork出的用户进程将继承和共享这些预加载的资源，不用浪费时间重新加载，加快了应用程序的启动过程。启动结束后，Zygote进程也将变成守护进程，负责响应和启动APK应用程序的请求： 1234567891011/system/core/rootdir/init.zygote64.rcservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-serverclass mainsocket zygote stream 660 root systemonrestart write /sys/android_power/request_state wakeonrestart write /sys/power/state ononrestart restart audioserveronrestart restart cameraserveronrestart restart mediaonrestart restart netdwritepid /dev/cpuset/foreground/tasks 3.5、启动SystemServerSystemServer是Zygote进程fork出的第一个进程，也是整个Android系统的核心进程。在SystemServer中运行着系统大部分的Binder服务，SystemServer首先启动本地服务SensorService；接着启动ActivityManagerService、WindowManagerService、PackageManagerService在内的所有Java服务。 Zygote进程fork出System Server进程，System Server是Zygote孵化的第一个进程，地位非常重要；System Server进程：负责启动和管理整个Java framework，包含ActivityManager，PowerManager等服务。Media Server进程：负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。 12/frameworks/base/services/java/com/android/server/SystemServer.javaSystemServer().run() 3.6、启动ActivityManagerService3.7、启动Launcher(Activity) SystemServer加载完所有的Java服务后，最后会调用ActivityManagerService的SystemReady()方法，在这个方法的执行中，会发出Intent“android.intent.category.HOME”。凡是响应这个Intent的APK都会运行起来，Launcher应用就是Android系统默认的桌面应用，一般只有它会响应这个Intent，因此，系统开机后，第一个运行的应用就是Launcher。Zygote进程孵化出的第一个App进程是Launcher； 12/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javastartHomeActivityLocked(mCurrentUserId, \"systemReady\"); 四、设备启动过程详细分析（1）、启动Init进程概述：init是Linux系统中用户空间的第一个进程，进程号为1。Kernel启动后，在用户空间，启动init进程，并调用init中的main()方法执行init进程的职责。对于init进程的功能分为4部分： 分析和运行所有的init.rc文件;生成设备驱动节点; （通过rc文件创建）处理子进程的终止(signal方式);提供属性服务。接下来从main()方法说起。 4.1.1、main()[-&gt; init.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168int main(int argc, char** argv) &#123;if (!strcmp(basename(argv[0]), \"ueventd\")) &#123; return ueventd_main(argc, argv);&#125;if (!strcmp(basename(argv[0]), \"watchdogd\")) &#123; return watchdogd_main(argc, argv);&#125;// Clear the umask.//设置文件属性0777umask(0);add_environment(\"PATH\", _PATH_DEFPATH);bool is_first_stage = (argc == 1) || (strcmp(argv[1], \"--second-stage\") != 0);// Get the basic filesystem setup we need put together in the initramdisk// on / and then we'll let the rc file figure out the rest.//创建文件系统目录并挂载相关的文件系统if (is_first_stage) &#123; mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"); mkdir(\"/dev/pts\", 0755); mkdir(\"/dev/socket\", 0755); mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL); #define MAKE_STR(x) __STRING(x) mount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC)); mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL);&#125;// We must have some place other than / to create the device nodes for// kmsg and null, otherwise we won't be able to remount / read-only// later on. Now that tmpfs is mounted on /dev, we can actually talk// to the outside world.//屏蔽标准的输入输出open_devnull_stdio(); //初始化kernel log，位于设备节点/dev/kmsgklog_init(); //设置输出的log级别klog_set_level(KLOG_NOTICE_LEVEL); // 输出init启动阶段的logNOTICE(\"init %s started!\\n\", is_first_stage ? \"first stage\" : \"second stage\");if (!is_first_stage) &#123; // Indicate that booting is in progress to background fw loaders, etc. close(open(\"/dev/.booting\", O_WRONLY | O_CREAT | O_CLOEXEC, 0000)); //创建一块共享的内存空间，用于属性服务 property_init(); // If arguments are passed both on the command line and in DT, // properties set in DT always have priority over the command-line ones. process_kernel_dt(); process_kernel_cmdline(); // Propagate the kernel variables to internal variables // used by init as well as the current required properties. export_kernel_boot_props();&#125;// Set up SELinux, including loading the SELinux policy if we're in the kernel domain.selinux_initialize(is_first_stage);// If we're in the kernel domain, re-exec init to transition to the init domain now// that the SELinux policy has been loaded.if (is_first_stage) &#123; if (restorecon(\"/init\") == -1) &#123; ERROR(\"restorecon failed: %s\\n\", strerror(errno)); security_failure(); &#125; char* path = argv[0]; char* args[] = &#123; path, const_cast&lt;char*&gt;(\"--second-stage\"), nullptr &#125;; if (execv(path, args) == -1) &#123; ERROR(\"execv(\\\"%s\\\") failed: %s\\n\", path, strerror(errno)); security_failure(); &#125;&#125;// These directories were necessarily created before initial policy load// and therefore need their security context restored to the proper value.// This must happen before /dev is populated by ueventd.NOTICE(\"Running restorecon...\\n\");restorecon(\"/dev\");restorecon(\"/dev/socket\");restorecon(\"/dev/__properties__\");restorecon(\"/property_contexts\");restorecon_recursive(\"/sys\");epoll_fd = epoll_create1(EPOLL_CLOEXEC);if (epoll_fd == -1) &#123; ERROR(\"epoll_create1 failed: %s\\n\", strerror(errno)); exit(1);&#125;//初始化子进程退出的信号处理过程signal_handler_init();property_load_boot_defaults();export_oem_lock_status();start_property_service();const BuiltinFunctionMap function_map;Action::set_function_map(&amp;function_map);Parser&amp; parser = Parser::GetInstance();parser.AddSectionParser(\"service\",std::make_unique&lt;ServiceParser&gt;());parser.AddSectionParser(\"on\", std::make_unique&lt;ActionParser&gt;());parser.AddSectionParser(\"import\", std::make_unique&lt;ImportParser&gt;());parser.ParseConfig(\"/init.rc\");ActionManager&amp; am = ActionManager::GetInstance();am.QueueEventTrigger(\"early-init\");// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...am.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");// ... so that we can start queuing up actions that require stuff from /dev.am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");am.QueueBuiltinAction(set_mmap_rnd_bits_action, \"set_mmap_rnd_bits\");am.QueueBuiltinAction(keychord_init_action, \"keychord_init\");am.QueueBuiltinAction(console_init_action, \"console_init\");// Trigger all the boot actions to get us started.am.QueueEventTrigger(\"init\");// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random// wasn't ready immediately after wait_for_coldboot_doneam.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");// Don't mount filesystems or start core system services in charger mode.std::string bootmode = property_get(\"ro.bootmode\");if (bootmode == \"charger\") &#123; am.QueueEventTrigger(\"charger\");&#125; else &#123; am.QueueEventTrigger(\"late-init\");&#125;// Run all property triggers based on current state of the properties.am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\");while (true) &#123; if (!waiting_for_exec) &#123; am.ExecuteOneCommand(); restart_processes(); &#125; int timeout = -1; if (process_needs_restart) &#123; timeout = (process_needs_restart - gettime()) * 1000; if (timeout &lt; 0) timeout = 0; &#125; if (am.HasMoreCommands()) &#123; timeout = 0; &#125; bootchart_sample(&amp;timeout); epoll_event ev; int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout)); if (nr == -1) &#123; ERROR(\"epoll_wait failed: %s\\n\", strerror(errno)); &#125; else if (nr == 1) &#123; ((void (*)()) ev.data.ptr)(); &#125;&#125;return 0;&#125; 4.1.2、创建文件系统目录并挂载相关的文件系统此时android的log系统还没有启动，采用kernel的log系统，打开的设备节点/dev/kmsg， 那么可通过cat /dev/kmsg来获取内核log。 接下来，设置log的输出级别为KLOG_NOTICE_LEVEL(5)，当log级别小于5时则会输出到kernel log， 默认值为3. 123456789101112131415add_environment(\"PATH\", _PATH_DEFPATH);bool is_first_stage = (argc == 1) || (strcmp(argv[1], \"--second-stage\") != 0);// Get the basic filesystem setup we need put together in the initramdisk// on / and then we'll let the rc file figure out the rest.if (is_first_stage) &#123; mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"); mkdir(\"/dev/pts\", 0755); mkdir(\"/dev/socket\", 0755); mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL); #define MAKE_STR(x) __STRING(x) mount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC)); mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL);&#125; 该部分主要用于创建和挂载启动所需的文件目录。需要注意的是，在编译Android系统源码时，在生成的根文件系统中，并不存在这些目录，它们是系统运行时的目录，即当系统终止时，就会消失。 在init初始化过程中，Android分别挂载了tmpfs，devpts，proc，sysfs这4类文件系统。 tmpfs是一种虚拟内存文件系统，它会将所有的文件存储在虚拟内存中，如果你将tmpfs文件系统卸载后，那么其下的所有的内容将不复存在。tmpfs既可以使用RAM，也可以使用交换分区，会根据你的实际需要而改变大小。tmpfs的速度非常惊人，毕竟它是驻留在RAM中的，即使用了交换分区，性能仍然非常卓越。由于tmpfs是驻留在RAM的，因此它的内容是不持久的。断电后，tmpfs的内容就消失了，这也是被称作tmpfs的根本原因。 devpts文件系统为伪终端提供了一个标准接口，它的标准挂接点是/dev/ pts。只要pty的主复合设备/dev/ptmx被打开，就会在/dev/pts下动态的创建一个新的pty设备文件。 proc文件系统是一个非常重要的虚拟文件系统，它可以看作是内核内部数据结构的接口，通过它我们可以获得系统的信息，同时也能够在运行时修改特定的内核参数。 与proc文件系统类似，sysfs文件系统也是一个不占有任何磁盘空间的虚拟文件系统。它通常被挂接在/sys目录下。sysfs文件系统是Linux2.6内核引入的，它把连接在系统上的设备和总线组织成为一个分级的文件，使得它们可以在用户空间存取。 4.1.4、屏蔽标准的输入输出[-&gt; init.cpp] 12345678910111213141516171819202122232425void open_devnull_stdio(void)&#123;// Try to avoid the mknod() call if we can. Since SELinux makes// a /dev/null replacement available for free, let's use it.int fd = open(\"/sys/fs/selinux/null\", O_RDWR);if (fd == -1) &#123; // OOPS, /sys/fs/selinux/null isn't available, likely because // /sys/fs/selinux isn't mounted. Fall back to mknod. static const char *name = \"/dev/__null__\"; if (mknod(name, S_IFCHR | 0600, (1 &lt;&lt; 8) | 3) == 0) &#123; fd = open(name, O_RDWR); unlink(name); &#125; if (fd == -1) &#123; exit(1); &#125;&#125;dup2(fd, 0);dup2(fd, 1);dup2(fd, 2);if (fd &gt; 2) &#123; close(fd);&#125;&#125; 前文生成/dev目录后，init进程将调用open_devnull_stdio函数，屏蔽标准的输入输出。open_devnull_stdio函数会在/dev目录下生成null设备节点文件，并将标准输入、标准输出、标准错误输出全部重定向到null设备中。open_devnull_stdio函数定义于system/core/init/util.cpp中。 这里需要说明的是，dup2函数的作用是用来复制一个文件的描述符，通常用来重定向进程的stdin、stdout和stderr。它的函数原形是： int dup2(int oldfd, int targetfd) 该函数执行后，targetfd将变成oldfd的复制品。 因此上述过程其实就是：创建出null设备后，将0、1、2绑定到null设备上。因此init进程调用open_devnull_stdio函数后，通过标准的输入输出无法输出信息。 4.1.5、初始化内核log系统我们继续回到init进程的main函数，init进程通过klog_init函数，提供输出log信息的设备。[-&gt; init.cpp] 1234567891011121314151617klog_init();klog_set_level(KLOG_NOTICE_LEVEL);void klog_init(void) &#123;if (klog_fd &gt;= 0) return; /* Already initialized */klog_fd = open(\"/dev/kmsg\", O_WRONLY | O_CLOEXEC);if (klog_fd &gt;= 0) &#123; return;&#125;static const char* name = \"/dev/__kmsg__\";if (mknod(name, S_IFCHR | 0600, (1 &lt;&lt; 8) | 11) == 0) &#123; klog_fd = open(name, O_WRONLY | O_CLOEXEC); unlink(name);&#125;&#125; klog_init函数定义于system/core/libcutils/klog.c中。通过klog_init函数，init进程生成kmsg设备节点文件。该设备可以调用内核信息输出函数printk，以输出log信息。 4.1.6、初始化属性域12345if (!is_first_stage) &#123;.......property_init();.......&#125; 调用property_init初始化属性域。在Android平台中，为了让运行中的所有进程共享系统运行时所需要的各种设置值，系统开辟了属性存储区域，并提供了访问该区域的API。 这里存在一个问题是，在init进程中有部分代码块以is_first_stage标志进行区分，决定是否需要进行初始化。is_first_stage的值，由init进程main函数的入口参数决定，之前不太明白具体的含义。后来写博客后，有朋友留言，在引入selinux机制后，有些操作必须要在内核态才能完成；但init进程作为android的第一个进程，又是运行在用户态的。于是，最终设计为用is_first_stage进行区分init进程的运行状态。init进程在运行的过程中，会完成从内核态到用户态的切换。 123456void property_init() &#123;if (__system_property_area_init()) &#123; ERROR(\"Failed to initialize property area\\n\"); exit(1);&#125;&#125; property_init函数定义于system/core/init/property_service.cpp中，如上面代码所示，最终调用_system_property_area_init函数初始化属性域。 4.1.7、完成SELinux相关工作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Set up SELinux, including loading the SELinux policy if we're in the kernel domain.selinux_initialize(is_first_stage);static void selinux_initialize(bool in_kernel_domain) &#123;Timer t;selinux_callback cb;//用于打印log的回调函数cb.func_log = selinux_klog_callback;selinux_set_callback(SELINUX_CB_LOG, cb);//用于检查权限的回调函数cb.func_audit = audit_callback;selinux_set_callback(SELINUX_CB_AUDIT, cb);if (in_kernel_domain) &#123; //内核态处理流程 INFO(\"Loading SELinux policy...\\n\"); //用于加载sepolicy文件。该函数最终将sepolicy文件传递给kernel，这样kernel就有了安全策略配置文件，后续的MAC才能开展起来。 if (selinux_android_load_policy() &lt; 0) &#123; ERROR(\"failed to load policy: %s\\n\", strerror(errno)); security_failure(); &#125; //内核中读取的信息 bool kernel_enforcing = (security_getenforce() == 1); //命令行中得到的数据 bool is_enforcing = selinux_is_enforcing(); if (kernel_enforcing != is_enforcing) &#123; //用于设置selinux的工作模式。selinux有两种工作模式： //1、”permissive”，所有的操作都被允许（即没有MAC），但是如果违反权限的话，会记录日志 //2、”enforcing”，所有操作都会进行权限检查。在一般的终端中，应该工作于enforing模式 if (security_setenforce(is_enforcing)) &#123; ERROR(\"security_setenforce(%s) failed: %s\\n\", is_enforcing ? \"true\" : \"false\", strerror(errno)); //将重启进入recovery mode security_failure(); &#125; &#125; if (write_file(\"/sys/fs/selinux/checkreqprot\", \"0\") == -1) &#123; security_failure(); &#125; NOTICE(\"(Initializing SELinux %s took %.2fs.)\\n\", is_enforcing ? \"enforcing\" : \"non-enforcing\", t.duration());&#125; else &#123; selinux_init_all_handles();&#125;&#125; init进程进程调用selinux_initialize启动SELinux。从注释来看，init进程的运行确实是区分用户态和内核态的。 4.1.8、重新设置属性1234567891011121314151617181920212223242526// If we're in the kernel domain, re-exec init to transition to the init domain now// that the SELinux policy has been loaded.if (is_first_stage) &#123;//按selinux policy要求，重新设置init文件属性 if (restorecon(\"/init\") == -1) &#123; ERROR(\"restorecon failed: %s\\n\", strerror(errno)); security_failure(); &#125; char* path = argv[0]; char* args[] = &#123; path, const_cast&lt;char*&gt;(\"--second-stage\"), nullptr &#125;; //这里就是前面所说的，启动用户态的init进程，即second-stage if (execv(path, args) == -1) &#123; ERROR(\"execv(\\\"%s\\\") failed: %s\\n\", path, strerror(errno)); security_failure(); &#125;&#125;// These directories were necessarily created before initial policy load// and therefore need their security context restored to the proper value.// This must happen before /dev is populated by ueventd.NOTICE(\"Running restorecon...\\n\");restorecon(\"/dev\");restorecon(\"/dev/socket\");restorecon(\"/dev/__properties__\");restorecon(\"/property_contexts\");restorecon_recursive(\"/sys\"); 上述文件节点在加载Sepolicy之前已经被创建了，因此在加载完Sepolicy后，需要重新设置相关的属性。 4.1.9、创建epoll句柄如下面代码所示，init进程调用epoll_create1创建epoll句柄。 12345epoll_fd = epoll_create1(EPOLL_CLOEXEC);if (epoll_fd == -1) &#123; ERROR(\"epoll_create1 failed: %s\\n\", strerror(errno)); exit(1);&#125; 在linux的网络编程中，很长的时间都在使用select来做事件触发。在linux新的内核中，有了一种替换它的机制，就是epoll。相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。 epoll机制一般使用epoll_create(int size)函数创建epoll句柄，size用来告诉内核这个句柄可监听的fd的数目。注意这个参数不同于select()中的第一个参数，在select中需给出最大监听数加1的值。此外，当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，能够看到创建出的fd，因此在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。上述代码使用的epoll_create1(EPOLLCLOEXEC)来创建epoll句柄，该标志位表示生成的epoll fd具有“执行后关闭”特性。 4.1.10、装载子进程信号处理器12345678910111213141516171819202122232425void signal_handler_init() &#123;// Create a signalling mechanism for SIGCHLD.int s[2];//利用socketpair创建出已经连接的两个socket，分别作为信号的读、写端if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, s) == -1) &#123; ERROR(\"socketpair failed: %s\\n\", strerror(errno)); exit(1);&#125;signal_write_fd = s[0];signal_read_fd = s[1];// Write to signal_write_fd if we catch SIGCHLD.struct sigaction act;memset(&amp;act, 0, sizeof(act));//信号处理器为SIGCHLD_handler，其被存在sigaction结构体中，负责处理SIGCHLD消息act.sa_handler = SIGCHLD_handler;act.sa_flags = SA_NOCLDSTOP;//调用信号安装函数sigaction，将监听的信号及对应的信号处理器注册到内核中sigaction(SIGCHLD, &amp;act, 0);//相对于6.0的代码，进一步作了封装，用于终止出现问题的子进程，详细代码于后文分析。ServiceManager::GetInstance().ReapAnyOutstandingChildren();register_epoll_handler(signal_read_fd, handle_signal);&#125; Linux进程通过互相发送接收消息来实现进程间的通信，这些消息被称为“信号”。每个进程在处理其它进程发送的信号时都要注册处理者，处理者被称为信号处理器。 注意到sigaction结构体的sa_flags为SA_NOCLDSTOP。由于系统默认在子进程暂停时也会发送信号SIGCHLD，init需要忽略子进程在暂停时发出的SIGCHLD信号，因此将act.sa_flags 置为SA_NOCLDSTOP，该标志位表示仅当进程终止时才接受SIGCHLD信号。 我们来看看SIGCHLD_handler的具体工作。 12345static void SIGCHLD_handler(int) &#123;if (TEMP_FAILURE_RETRY(write(signal_write_fd, \"1\", 1)) == -1) &#123; ERROR(\"write(signal_write_fd) failed: %s\\n\", strerror(errno));&#125;&#125; 从上面代码我们知道，init进程是所有进程的父进程，当其子进程终止产生SIGCHLD信号时，SIGCHLD_handler对signal_write_fd执行写操作。由于socketpair的绑定关系，这将触发信号对应的signal_read_fd收到数据。 在装载信号监听器的最后，signal_handler_init调用register_epoll_handler，其代码如下所示，传入参数分别为signal_read_fd和handle_signal。 123456789void register_epoll_handler(int fd, void (*fn)()) &#123;epoll_event ev;ev.events = EPOLLIN;ev.data.ptr = reinterpret_cast&lt;void*&gt;(fn);//epoll_fd增加一个监听对象fd,fd上有数据到来时，调用fn处理if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;ev) == -1) &#123; ERROR(\"epoll_ctl failed: %s\\n\", strerror(errno));&#125;&#125; 根据代码，我们知道：当epoll句柄监听到signal_read_fd中有数据可读时，将调用handle_signal进行处理。 至此，结合上文我们知道：当init进程调用signal_handler_init后，一旦收到子进程终止带来的SIGCHLD消息后，将利用信号处理者SIGCHLD_handler向signal_write_fd写入信息； epoll句柄监听到signal_read_fd收消息后，将调用handle_signal进行处理。整个过程如下图所示。 1234567static void handle_signal() &#123;// Clear outstanding requests.char buf[32];read(signal_read_fd, buf, sizeof(buf));ServiceManager::GetInstance().ReapAnyOutstandingChildren();&#125; 从代码中可以看出，handle_signal只是清空signal_read_fd中的数据，然后调用ServiceManager::GetInstance().ReapAnyOutstandingChildren()。 ServiceManager定义于system/core/init/service.cpp中，是一个单例对象： 1234567891011121314............//C++中默认是private属性ServiceManager::ServiceManager() &#123;&#125;ServiceManager&amp; ServiceManager::GetInstance() &#123;static ServiceManager instance;return instance;&#125;void ServiceManager::ReapAnyOutstandingChildren() &#123;while (ReapOneProcess()) &#123;&#125;&#125;............ ReapAnyOutstandingChildren函数实际上调用了ReapOneProcess。我们结合代码，看看ReapOneProcess的具体工作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798bool ServiceManager::ReapOneProcess() &#123;int status;//用waitpid函数获取状态发生变化的子进程pid//waitpid的标记为WNOHANG，即非阻塞，返回为正值就说明有进程挂掉了pid_t pid = TEMP_FAILURE_RETRY(waitpid(-1, &amp;status, WNOHANG));if (pid == 0) &#123; return false;&#125; else if (pid == -1) &#123; ERROR(\"waitpid failed: %s\\n\", strerror(errno)); return false;&#125;//利用FindServiceByPid函数，找到pid对应的服务。//FindServiceByPid主要通过轮询解析init.rc生成的service_list，找到pid与参数一致的srvc。Service* svc = FindServiceByPid(pid);//输出服务结束的原因.........if (!svc) &#123; return true;&#125;//结束服务，相对于6.0作了进一步的封装if (svc-&gt;Reap()) &#123; waiting_for_exec = false; //移除服务对应的信息 RemoveService(*svc);&#125;return true;&#125;bool Service::Reap() &#123;//清理未携带SVC_ONESHOT 或 携带了SVC_RESTART标志的srvc的子进程if (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123; NOTICE(\"Service '%s' (pid %d) killing any children in process group\\n\", name_.c_str(), pid_); kill(-pid_, SIGKILL);&#125;//清除srvc中创建出的socketfor (const auto&amp; si : sockets_) &#123; std::string tmp = StringPrintf(ANDROID_SOCKET_DIR \"/%s\", si.name.c_str()); unlink(tmp.c_str());&#125;if (flags_ &amp; SVC_EXEC) &#123; INFO(\"SVC_EXEC pid %d finished...\\n\", pid_); return true;&#125;pid_ = 0;flags_ &amp;= (~SVC_RUNNING);//对于携带了SVC_ONESHOT并且未携带SVC_RESTART的srvc，将这类服务的标志置为SVC_DISABLED，不再启动if ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123; flags_ |= SVC_DISABLED;&#125;// Disabled and reset processes do not get restarted automatically.if (flags_ &amp; (SVC_DISABLED | SVC_RESET)) &#123; svc-&gt;NotifyStateChange(\"stopped\"); return true;&#125;time_t now = gettime();//未携带SVC_RESTART的关键服务，在规定的间隔内，crash字数过多时，会导致整机重启；if ((flags_ &amp; SVC_CRITICAL) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123; if (time_crashed_ + CRITICAL_CRASH_WINDOW &gt;= now) &#123; if (++nr_crashed_ &gt; CRITICAL_CRASH_THRESHOLD) &#123; .......... android_reboot(ANDROID_RB_RESTART2, 0, \"recovery\"); return true; &#125; &#125; else &#123; time_crashed_ = now; nr_crashed_ = 1; &#125;&#125;//将待重启srvc的标志位置为SVC_RESTARTING（init进程将根据该标志位，重启服务）flags_ &amp;= (~SVC_RESTART);flags_ |= SVC_RESTARTING;// Execute all onrestart commands for this service.//重启在init.rc文件中带有onrestart选项的服务，相对于6.0，此处也增加了封装性onrestart_.ExecuteAllCommands();svc-&gt;NotifyStateChange(\"restarting\");return true;&#125;void Action::ExecuteAllCommands() const &#123;for (const auto&amp; c : commands_) &#123; ExecuteCommand(c);&#125;&#125;void Action::ExecuteCommand(const Command&amp; command) const &#123;Timer t;//服务重启时，将执行对应的选项int result = command.InvokeFunc();//打印log........&#125; waitpid的函数原型为: 1pid_t waitpid(pid_t pid, int *status, int options) 其中，第一个参数pid为预等待的子进程的识别码，pid=-1表示等待任何子进程是否发出SIGCHLD。第二个参数status，用于返回子进程的结束状态。第三个参数决定waitpid函数是否处于阻塞处理方式，WNOHANG表示若pid指定的子进程没有结束，则waitpid()函数返回0，不予等待；若子进程结束，则返回子进程的pid。waitpid如果出错，则返回-1。 总结一下：整个signal_handler_init其实就是为了重启子进程用的，上述过程其实最终可以简化为下图： 4.1.11、设置默认系统属性1property_load_boot_defaults(); 接下来，进程调用property_load_boot_defaults进行默认属性配置相关的工作。 12void property_load_boot_defaults() &#123;load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT, NULL); 如代码所示，property_load_boot_defaults实际上就是调用load_properties_from_file解析配置文件；然后根据解析的结果，设置系统属性。该部分功能较为单一，不再深入分析。 4.1.12、配置属性的服务端12345678910111213start_property_service();void start_property_service() &#123;//创建了一个非阻塞socketproperty_set_fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0666, 0, 0, NULL);if (property_set_fd == -1) &#123; ERROR(\"start_property_service socket creation failed: %s\\n\", strerror(errno)); exit(1);&#125;//调用listen函数监听property_set_fd， 于是该socket变成一个serverlisten(property_set_fd, 8);//监听server socket上是否有数据到来register_epoll_handler(property_set_fd, handle_property_set_fd);&#125; 我们知道，在create_socket函数返回套接字property_set_fd时，property_set_fd是一个主动连接的套接字。此时，系统假设用户会对这个套接字调用connect函数，期待它主动与其它进程连接。 由于在服务器编程中，用户希望这个套接字可以接受外来的连接请求，也就是被动等待用户来连接，于是需要调用listen函数使用主动连接套接字变为被连接套接字，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程。 因此，调用listen后，init进程成为一个服务进程，其它进程可以通过property_set_fd连接init进程，提交设置系统属性的申请。 listen函数的第二个参数，涉及到一些网络的细节。 在进程处理一个连接请求的时候，可能还存在其它的连接请求。因为TCP连接是一个过程，所以可能存在一种半连接的状态。有时由于同时尝试连接的用户过多，使得服务器进程无法快速地完成连接请求。 因此，内核会在自己的进程空间里维护一个队列，以跟踪那些已完成连接但服务器进程还没有接手处理的用户，或正在进行的连接的用户。这样的一个队列不可能任意大，所以必须有一个上限。listen的第二个参数就是告诉内核使用这个数值作为上限。因此，init进程作为系统属性设置的服务器，最多可以同时为8个试图设置属性的用户提供服务。 在启动配置属性服务的最后，调用函数register_epoll_handler。根据上文所述，我们知道该函数将利用之前创建出的epoll句柄监听property_set_fd。当property_set_fd中有数据到来时，init进程将利用handle_property_set_fd函数进行处理。 12345678910111213static void handle_property_set_fd() &#123; .......... if ((s = accept(property_set_fd, (struct sockaddr *) &amp;addr, &amp;addr_size)) &lt; 0) &#123; return; &#125; ........ r = TEMP_FAILURE_RETRY(recv(s, &amp;msg, sizeof(msg), MSG_DONTWAIT)); ......... switch(msg.cmd) &#123; ......... &#125; .........&#125; handle_propery_set_fd函数实际上是调用accept函数监听连接请求，接收property_set_fd中到来的数据，然后利用recv函数接受到来的数据，最后根据到来数据的类型，进行设置系统属性等相关操作，在此不做深入分析。 在这一部分的最后，我们简单举例介绍一下，系统属性改变的一些用途。在init.rc中定义了一些与属性相关的触发器。当某个条件相关的属性被改变时，与该条件相关的触发器就会被触发。举例来说，如下面代码所示，debuggable属性变为1时，将执行启动console进程等操作。 12345on property:ro.debuggable=1# Give writes to anyone for the trace folder on debug builds.# The folder is used to store method traces.chmod 0773 /data/misc/tracestart console 总结一下，其它进程修改系统属性时，大致的流程如下图所示：其它的进程像init进程发送请求后，由init进程检查权限后，修改共享内存区。 4.1.12、解析init.rc文件关于解析init.rc的代码，Android 7.0相对于6.0，作了巨大的修改。 1234567891011121314//这里将Action的function_map_替换为BuiltinFunctionMap//下文将通过BuiltinFuntionMap的map方法，获取keyword对应的处理函数const BuiltinFunctionMap function_map;Action::set_function_map(&amp;function_map);//构造出解析文件用的parser对象Parser&amp; parser = Parser::GetInstance();//为一些类型的关键字，创建特定的parserparser.AddSectionParser(\"service\",std::make_unique&lt;ServiceParser&gt;());parser.AddSectionParser(\"on\", std::make_unique&lt;ActionParser&gt;());parser.AddSectionParser(\"import\", std::make_unique&lt;ImportParser&gt;());//开始实际的解析过程parser.ParseConfig(\"/init.rc\");........ 在解析init.rc文件的过程前，我们先来简单介绍一下init.rc文件。init.rc文件是在init进程启动后执行的启动脚本，文件中记录着init进程需执行的操作。在Android系统中，使用init.rc和init.{ hardware }.rc两个文件。 其中init.rc文件在Android系统运行过程中用于通用的环境设置与进程相关的定义，init.{hardware}.rc（例如，高通有init.qcom.rc，MTK有init.mediatek.rc）用于定义Android在不同平台下的特定进程和环境设置等。 此处解析函数传入的参数为“/init.rc”，解析的是运行时与init进程同在根目录下的init.rc文件。该文件在编译前，定义于system/core/rootdir/init.rc中（与平台相关的rc文件不在这里加载）。 init.rc文件大致分为两大部分，一部分是以“on”关键字开头的动作列表（action list）： 12345on early-init # Set init and its forked children's oom_adj. write /proc/1/oom_score_adj -1000 ......... start ueventd 另一部分是以“service”关键字开头的服务列表（service list）： 1234service ueventd /sbin/ueventd class core critical seclabel u:r:ueventd:s0 借助系统环境变量或Linux命令，动作列表用于创建所需目录，以及为某些特定文件指定权限，而服务列表用来记录init进程需要启动的一些子进程。如上面代码所示，service关键字后的第一个字符串表示服务（子进程）的名称，第二个字符串表示服务的执行路径。 接下来，我们从ParseConfig函数入手，逐步分析整个解析过程(函数定义于system/core/init/ init_parser.cpp中)： 123456789101112131415161718192021222324bool Parser::ParseConfig(const std::string&amp; path) &#123; if (is_dir(path.c_str())) &#123; //传入参数为目录地址 return ParseConfigDir(path); &#125; //传入参数为文件地址 return ParseConfigFile(path);&#125;bool Parser::ParseConfigDir(const std::string&amp; path) &#123; ........... std::unique_ptr&lt;DIR, int(*)(DIR*)&gt; config_dir(opendir(path.c_str()), closedir); .......... //看起来很复杂，其实就是递归目录 while ((current_file = readdir(config_dir.get()))) &#123; std::string current_path = android::base::StringPrintf(\"%s/%s\", path.c_str(), current_file-&gt;d_name); if (current_file-&gt;d_type == DT_REG) &#123; //最终还是靠ParseConfigFile来解析实际的文件 if (!ParseConfigFile(current_path)) &#123; ............. &#125; &#125; &#125;&#125; 从上面的代码可以看出，解析init.rc文件的函数是ParseConfigFile： 123456789101112bool Parser::ParseConfigFile(const std::string&amp; path) &#123; ........ std::string data; //读取路径指定文件中的内容，保存为字符串形式 if (!read_file(path.c_str(), &amp;data)) &#123; return false; &#125; ......... //解析获取的字符串 ParseData(path, data); .........&#125; ParseData函数定义于system/core/init/init_parser.cpp中，根据关键字解析出服务和动作。动作与服务会以链表节点的形式注册到service_list与action_list中，service_list与action_list是init进程中声明的全局结构体，其中的关键代码下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void Parser::ParseData(const std::string&amp; filename, const std::string&amp; data) &#123;.......parse_state state;.......std::vector&lt;std::string&gt; args;for (;;) &#123; //next_token以行为单位分割参数传递过来的字符串 //最先走到T_TEXT分支 switch (next_token(&amp;state)) &#123; case T_EOF: if (section_parser) &#123; //EOF,解析结束 section_parser-&gt;EndSection(); &#125; return; case T_NEWLINE: state.line++; if (args.empty()) &#123; break; &#125; //在前文创建parser时，我们为service，on，import定义了对应的parser //这里就是根据第一个参数，判断是否有对应的parser if (section_parsers_.count(args[0])) &#123; if (section_parser) &#123; //结束上一个parser的工作，将构造出的对象加入到对应的service_list与action_list中 section_parser-&gt;EndSection(); &#125; //获取参数对应的parser section_parser = section_parsers_[args[0]].get(); std::string ret_err; //调用实际parser的ParseSection函数 if (!section_parser-&gt;ParseSection(args, &amp;ret_err)) &#123; parse_error(&amp;state, \"%s\\n\", ret_err.c_str()); section_parser = nullptr; &#125; &#125; else if (section_parser) &#123; std::string ret_err; //如果第一个参数不是service，on，import //则调用前一个parser的ParseLineSection函数 //这里相当于解析一个参数块的子项 if (!section_parser-&gt;ParseLineSection(args, state.filename, state.line, &amp;ret_err)) &#123; parse_error(&amp;state, \"%s\\n\", ret_err.c_str()); &#125; &#125; //清空本次解析的数据 args.clear(); break; case T_TEXT: //将本次解析的内容写入到args中 args.emplace_back(state.text); break; &#125;&#125;&#125; 这里的解析看起来比较复杂，在6.0以前的版本中，整个解析是面向过程的。init进程统一调用一个函数来进行解析，然后在该函数中利用switch-case的形式，根据解析的内容进行相应的处理。在Android 7.0中，为了更好地封装及面向对象，对于不同的关键字定义了不同的parser对象，每个对象通过多态实现自己的解析操作。 我们现在回忆一下init进程main函数中，创建parser的代码： 123456...........Parser&amp; parser = Parser::GetInstance();parser.AddSectionParser(\"service\",std::make_unique&lt;ServiceParser&gt;());parser.AddSectionParser(\"on\", std::make_unique&lt;ActionParser&gt;());parser.AddSectionParser(\"import\", std::make_unique&lt;ImportParser&gt;());........... 看看三个Parser的定义： 123class ServiceParser : public SectionParser &#123;......&#125;class ActionParser : public SectionParser &#123;......&#125;class ImportParser : public SectionParser &#123;.......&#125; 可以看到三个Parser均是继承SectionParser，具体的实现各有不同，我们以比较常用的ServiceParser和ActionParser为例，看看解析的结果如何处理。 4.1.12..1 ServiceParserServiceParser定义于system/core/init/service.cpp中。从前面的代码，我们知道，解析一个service块，首先需要调用ParseSection函数，接着利用ParseLineSection处理子块，解析完所有数据后，调用EndSection。因此，我们着重看看ServiceParser的这三个函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 bool ServiceParser::ParseSection(.....) &#123; ....... const std::string&amp; name = args[1]; ....... std::vector&lt;std::string&gt; str_args(args.begin() + 2, args.end()); //主要根据参数，构造出一个service对象 service_ = std::make_unique&lt;Service&gt;(name, \"default\", str_args); return true;&#125;//注意这里已经在解析子项了bool ServiceParser::ParseLineSection(......) const &#123; //调用service对象的HandleLine return service_ ? service_-&gt;HandleLine(args, err) : false;&#125;bool Service::HandleLine(.....) &#123; ........ //OptionHandlerMap继承自keywordMap&lt;OptionHandler&gt; static const OptionHandlerMap handler_map; //根据子项的内容，找到对应的handler函数 //FindFunction定义与keyword模块中,FindFunction方法利用子类生成对应的map中，然后通过通用的查找方法，即比较键值找到对应的处理函数 auto handler = handler_map.FindFunction(args[0], args.size() - 1, err); if (!handler) &#123; return false; &#125; //调用handler函数 return (this-&gt;*handler)(args, err);&#125;class Service::OptionHandlerMap : public KeywordMap&lt;OptionHandler&gt; &#123; ........... Service::OptionHandlerMap::Map&amp; Service::OptionHandlerMap::map() const &#123; constexpr std::size_t kMax = std::numeric_limits&lt;std::size_t&gt;::max(); static const Map option_handlers = &#123; &#123;\"class\", &#123;1, 1, &amp;Service::HandleClass&#125;&#125;, &#123;\"console\", &#123;0, 0, &amp;Service::HandleConsole&#125;&#125;, &#123;\"critical\", &#123;0, 0, &amp;Service::HandleCritical&#125;&#125;, &#123;\"disabled\", &#123;0, 0, &amp;Service::HandleDisabled&#125;&#125;, &#123;\"group\", &#123;1, NR_SVC_SUPP_GIDS + 1, &amp;Service::HandleGroup&#125;&#125;, &#123;\"ioprio\", &#123;2, 2, &amp;Service::HandleIoprio&#125;&#125;, &#123;\"keycodes\", &#123;1, kMax, &amp;Service::HandleKeycodes&#125;&#125;, &#123;\"oneshot\", &#123;0, 0, &amp;Service::HandleOneshot&#125;&#125;, &#123;\"onrestart\", &#123;1, kMax, &amp;Service::HandleOnrestart&#125;&#125;, &#123;\"seclabel\", &#123;1, 1, &amp;Service::HandleSeclabel&#125;&#125;, &#123;\"setenv\", &#123;2, 2, &amp;Service::HandleSetenv&#125;&#125;, &#123;\"socket\", &#123;3, 6, &amp;Service::HandleSocket&#125;&#125;, &#123;\"user\", &#123;1, 1, &amp;Service::HandleUser&#125;&#125;, &#123;\"writepid\", &#123;1, kMax, &amp;Service::HandleWritepid&#125;&#125;, &#125;; return option_handlers;&#125;//以class对应的处理函数为例，可以看出其实就是填充service对象对应的域bool Service::HandleClass(const std::vector&lt;std::string&gt;&amp; args, std::string* err) &#123; classname_ = args[1]; return true;&#125;//注意此时service对象已经处理完毕void ServiceParser::EndSection() &#123; if (service_) &#123; ServiceManager::GetInstance().AddService(std::move(service_)); &#125;&#125;void ServiceManager::AddService(std::unique_ptr&lt;Service&gt; service) &#123; Service* old_service = FindServiceByName(service-&gt;name()); if (old_service) &#123; ERROR(\"ignored duplicate definition of service '%s'\", service-&gt;name().c_str()); return; &#125; //将service对象加入到services_里 //7.0里，services_已经是个vector了 services_.emplace_back(std::move(service));&#125; 从上面的一系列代码，我们可以看出ServiceParser其实就是：首先根据第一行的名字和参数创建出service对象，然后根据选项域的内容填充service对象，最后将创建出的service对象加入到vector类型的service链表中。 4.1.12.2 ActionParserActionParser定义于system/core/init/action.cpp中。Action的解析过程，其实与Service一样，也是先后调用ParseSection， ParseLineSection和EndSection。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool ActionParser::ParseSection(....) &#123; ........ //创建出新的action对象 auto action = std::make_unique&lt;Action&gt;(false); //根据参数，填充action的trigger域，不详细分析了 if (!action-&gt;InitTriggers(triggers, err)) &#123; return false; &#125; .........&#125;bool ActionParser::ParseLineSection(.......) const &#123; //构造Action对象的command域 return action_ ? action_-&gt;AddCommand(args, filename, line, err) : false;&#125;bool Action::AddCommand(.....) &#123; ........ //找出action对应的执行函数 auto function = function_map_-&gt;FindFunction(args[0], args.size() - 1, err); ........ //利用所有信息构造出command，加入到action对象中 AddCommand(function, args, filename, line); return true;&#125;void Action::AddCommand(......) &#123; commands_.emplace_back(f, args, filename, line);&#125;void ActionParser::EndSection() &#123; if (action_ &amp;&amp; action_-&gt;NumCommands() &gt; 0) &#123; ActionManager::GetInstance().AddAction(std::move(action_)); &#125;&#125;void ActionManager::AddAction(.....) &#123; ........ auto old_action_it = std::find_if(actions_.begin(), actions_.end(), [&amp;action] (std::unique_ptr&lt;Action&gt;&amp; a) &#123; return action-&gt;TriggersEqual(*a); &#125;); if (old_action_it != actions_.end()) &#123; (*old_action_it)-&gt;CombineAction(*action); &#125; else &#123; //加入到action链表中，类型也是vector，其中装的是指针 actions_.emplace_back(std::move(action)); &#125;&#125; 从上面的代码可以看出，加载action块的逻辑和service一样，不同的是需要填充trigger和command域。当然，最后解析出的action也需要加入到action链表中。 这里最后还剩下一个问题，那就是哪里定义了Action中command对应处理函数？实际上，前文已经出现了过了，在init.cpp的main函数中： 1234.......const BuiltinFunctionMap function_map;Action::set_function_map(&amp;function_map);....... 因此，Action中调用functionmap-&gt;FindFunction时，实际上调用的是BuiltinFunctionMap的FindFunction函数。我们已经知道FindFunction是keyword定义的通用函数，重点是重构的map函数。我们看看system/core/init/builtins.cpp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546BuiltinFunctionMap::Map&amp; BuiltinFunctionMap::map() const &#123; constexpr std::size_t kMax = std::numeric_limits&lt;std::size_t&gt;::max(); static const Map builtin_functions = &#123; &#123;\"bootchart_init\", &#123;0, 0, do_bootchart_init&#125;&#125;, &#123;\"chmod\", &#123;2, 2, do_chmod&#125;&#125;, &#123;\"chown\", &#123;2, 3, do_chown&#125;&#125;, &#123;\"class_reset\", &#123;1, 1, do_class_reset&#125;&#125;, &#123;\"class_start\", &#123;1, 1, do_class_start&#125;&#125;, &#123;\"class_stop\", &#123;1, 1, do_class_stop&#125;&#125;, &#123;\"copy\", &#123;2, 2, do_copy&#125;&#125;, &#123;\"domainname\", &#123;1, 1, do_domainname&#125;&#125;, &#123;\"enable\", &#123;1, 1, do_enable&#125;&#125;, &#123;\"exec\", &#123;1, kMax, do_exec&#125;&#125;, &#123;\"export\", &#123;2, 2, do_export&#125;&#125;, &#123;\"hostname\", &#123;1, 1, do_hostname&#125;&#125;, &#123;\"ifup\", &#123;1, 1, do_ifup&#125;&#125;, &#123;\"init_user0\", &#123;0, 0, do_init_user0&#125;&#125;, &#123;\"insmod\", &#123;1, kMax, do_insmod&#125;&#125;, &#123;\"installkey\", &#123;1, 1, do_installkey&#125;&#125;, &#123;\"load_persist_props\", &#123;0, 0, do_load_persist_props&#125;&#125;, &#123;\"load_system_props\", &#123;0, 0, do_load_system_props&#125;&#125;, &#123;\"loglevel\", &#123;1, 1, do_loglevel&#125;&#125;, &#123;\"mkdir\", &#123;1, 4, do_mkdir&#125;&#125;, &#123;\"mount_all\", &#123;1, kMax, do_mount_all&#125;&#125;, &#123;\"mount\", &#123;3, kMax, do_mount&#125;&#125;, &#123;\"powerctl\", &#123;1, 1, do_powerctl&#125;&#125;, &#123;\"restart\", &#123;1, 1, do_restart&#125;&#125;, &#123;\"restorecon\", &#123;1, kMax, do_restorecon&#125;&#125;, &#123;\"restorecon_recursive\", &#123;1, kMax, do_restorecon_recursive&#125;&#125;, &#123;\"rm\", &#123;1, 1, do_rm&#125;&#125;, &#123;\"rmdir\", &#123;1, 1, do_rmdir&#125;&#125;, &#123;\"setprop\", &#123;2, 2, do_setprop&#125;&#125;, &#123;\"setrlimit\", &#123;3, 3, do_setrlimit&#125;&#125;, &#123;\"start\", &#123;1, 1, do_start&#125;&#125;, &#123;\"stop\", &#123;1, 1, do_stop&#125;&#125;, &#123;\"swapon_all\", &#123;1, 1, do_swapon_all&#125;&#125;, &#123;\"symlink\", &#123;2, 2, do_symlink&#125;&#125;, &#123;\"sysclktz\", &#123;1, 1, do_sysclktz&#125;&#125;, &#123;\"trigger\", &#123;1, 1, do_trigger&#125;&#125;, &#123;\"verity_load_state\", &#123;0, 0, do_verity_load_state&#125;&#125;, &#123;\"verity_update_state\", &#123;0, 0, do_verity_update_state&#125;&#125;, &#123;\"wait\", &#123;1, 2, do_wait&#125;&#125;, &#123;\"write\", &#123;2, 2, do_write&#125;&#125;, &#125;; return builtin_functions;&#125; 上述代码的第四项就是Action每个command对应的执行函数。 4.1.13、向执行队列中添加其它action介绍完init进程解析init.rc文件的过程后，我们继续将视角拉回到init进程的main函数： 1234567891011121314151617181920212223242526272829ActionManager&amp; am = ActionManager::GetInstance();am.QueueEventTrigger(\"early-init\");// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...m.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");// ... so that we can start queuing up actions that require stuff from /dev.am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");am.QueueBuiltinAction(set_mmap_rnd_bits_action, \"set_mmap_rnd_bits\");am.QueueBuiltinAction(keychord_init_action, \"keychord_init\");am.QueueBuiltinAction(console_init_action, \"console_init\");// Trigger all the boot actions to get us started.am.QueueEventTrigger(\"init\");// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random// wasn't ready immediately after wait_for_coldboot_doneam.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");// Don't mount filesystems or start core system services in charger mode.std::string bootmode = property_get(\"ro.bootmode\");if (bootmode == \"charger\") &#123; am.QueueEventTrigger(\"charger\");&#125; else &#123; am.QueueEventTrigger(\"late-init\");&#125;// Run all property triggers based on current state of the properties. am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\"); 从上面的代码可以看出，接下来init进程中调用了大量的QueueEventTrigger和QueueBuiltinAction函数。 123void ActionManager::QueueEventTrigger(const std::string&amp; trigger) &#123; trigger_queue_.push(std::make_unique&lt;EventTrigger&gt;(trigger));&#125; 处QueueEventTrigger函数就是利用参数构造EventTrigger，然后加入到triggerqueue中。后续init进程处理trigger事件时，将会触发相应的操作。根据前文的分析，我们知道实际上就是将action_list中，对应trigger与第一个参数匹配的action，加入到运行队列action_queue中。 12345678910111213141516void ActionManager::QueueBuiltinAction(BuiltinFunction func, const std::string&amp; name) &#123; //创建action auto action = std::make_unique&lt;Action&gt;(true); std::vector&lt;std::string&gt; name_vector&#123;name&#125;; //保证唯一性 if (!action-&gt;InitSingleTrigger(name)) &#123; return; &#125; //创建action的cmd，指定执行函数和参数 action-&gt;AddCommand(func, name_vector); trigger_queue_.push(std::make_unique&lt;BuiltinTrigger&gt;(action.get())); actions_.emplace_back(std::move(action));&#125; QueueBuiltinAction函数中构造新的action加入到actions_中，第一个参数作为新建action携带cmd的执行函数；第二个参数既作为action的trigger name，也作为action携带cmd的参数。 4.1.14、处理添加到运行队列的事件12345678910111213141516171819202122232425262728293031323334353637while (true) &#123; //判断是否有事件需要处理 if (!waiting_for_exec) &#123; //依次执行每个action中携带command对应的执行函数 am.ExecuteOneCommand(); //重启一些挂掉的进程 restart_processes(); &#125; //以下决定timeout的时间，将影响while循环的间隔 int timeout = -1; //有进程需要重启时，等待该进程重启 if (process_needs_restart) &#123; timeout = (process_needs_restart - gettime()) * 1000; if (timeout &lt; 0) timeout = 0; &#125; //有action待处理，不等待 if (am.HasMoreCommands()) &#123; timeout = 0; &#125; //bootchart_sample应该是进行性能数据采样 bootchart_sample(&amp;timeout); epoll_event ev; //没有事件到来的话，最多阻塞timeout时间 int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout)); if (nr == -1) &#123; ERROR(\"epoll_wait failed: %s\\n\", strerror(errno)); &#125; else if (nr == 1) &#123; //有事件到来，执行对应处理函数 //根据上文知道，epoll句柄（即epoll_fd）主要监听子进程结束，及其它进程设置系统属性的请求。 ((void (*)()) ev.data.ptr)(); &#125;&#125; 从上面代码可以看出，init进程将所有需要操作的action加入运行队列后， 进入无限循环过程，不断处理运行队列中的事件，同时进行重启service等操作。 ExecuteOneCommand中的主要部分如下图所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void ActionManager::ExecuteOneCommand() &#123; // Loop through the trigger queue until we have an action to execute //当有可执行action或trigger queue为空时结束 while (current_executing_actions_.empty() &amp;&amp; !trigger_queue_.empty()) &#123; //轮询actions链表 for (const auto&amp; action : actions_) &#123; //依次查找trigger表 if (trigger_queue_.front()-&gt;CheckTriggers(*action)) &#123; //当action与trigger对应时，就可以执行当前action //一个trigger可以对应多个action，均加入current_executing_actions_ current_executing_actions_.emplace(action.get()); &#125; &#125; //trigger event出队 trigger_queue_.pop(); &#125; if (current_executing_actions_.empty()) &#123; return; &#125; //每次只执行一个action，下次init进程while循环时，跳过上面的while循环，接着执行 auto action = current_executing_actions_.front(); if (current_command_ == 0) &#123; std::string trigger_name = action-&gt;BuildTriggersString(); INFO(\"processing action (%s)\\n\", trigger_name.c_str()); &#125; //实际的执行过程，此处仅处理当前action中的一个cmd action-&gt;ExecuteOneCommand(current_command_); //适当地清理工作，注意只有当前action中所有的command均执行完毕后，才会将该action从current_executing_actions_移除 // If this was the last command in the current action, then remove // the action from the executing list. // If this action was oneshot, then also remove it from actions_. ++current_command_; if (current_command_ == action-&gt;NumCommands()) &#123; current_executing_actions_.pop(); current_command_ = 0; if (action-&gt;oneshot()) &#123; auto eraser = [&amp;action] (std::unique_ptr&lt;Action&gt;&amp; a) &#123; return a.get() == action; &#125;; actions_.erase(std::remove_if(actions_.begin(), actions_.end(), eraser)); &#125; &#125;&#125; 123456void Action::ExecuteCommand(const Command&amp; command) const &#123; Timer t; //执行该command对应的处理函数 int result = command.InvokeFunc(); ........&#125; 从代码可以看出，当while循环不断调用ExecuteOneCommand函数时，将按照trigger表的顺序，依次取出action链表中与trigger匹配的action。每次均执行一个action中的一个command对应函数（一个action可能携带多个command）。当一个action所有的command均执行完毕后，再执行下一个action。当一个trigger对应的action均执行完毕后，再执行下一个trigger对应action。 restart_processes函数负责按需重启service，代码如下图所示。 12345678static void restart_processes() &#123; process_needs_restart = 0; ServiceManager::GetInstance().ForEachServiceWithFlags( SVC_RESTARTING, [] (Service* s) &#123; s-&gt;RestartIfNeeded(process_needs_restart); &#125;);&#125; 从上面可以看出，该函数轮询service对应的链表，对于有SVC_RESTARING标志的service执行RestartIfNeeded（如上文所述，当子进程终止时，init进程会将可被重启进程的服务标志位置为SVC_RESTARTING）。 如下面代码所示，restart_service_if_needed可以重新启动服务。 12345678910111213141516171819void Service::RestartIfNeeded(time_t&amp; process_needs_restart)(struct service *svc)&#123; time_t next_start_time = svc-&gt;time_started + 5; //两次服务启动时间的间隔要大于5s if (next_start_time &lt;= gettime()) &#123; svc-&gt;flags &amp;= (~SVC_RESTARTING); //满足时间间隔的要求后，重启服务 //Start将会重新fork服务进程，并做相应的配置 Start(svc, NULL); return; &#125; //更新main函数中，while循环需要等待的时间 if ((next_start_time &lt; process_needs_restart) || (process_needs_restart == 0)) &#123; process_needs_restart = next_start_time; &#125;&#125; 查阅资料发现：Bootchart 是一个能对 GNU/Linux boot 过程进行性能分析并把结果直观化的工具。它在 boot 过程中搜集资源利用情况及进程信息然后以PNG, SVG或EPS格式来显示结果。BootChart 包含数据收集工具和图像产生工具。数据收集工具在原始的BootChart中是独立的shell程序，但在Android中，数据收集工具被集成到了init 程序中。资料与代码基本吻合。 （2）、启动Zygote进程4.2.1、概述Zygote是由init进程通过解析init.zygote.rc文件而创建的，zygote所对应的可执行程序app_process，所对应的源文件是App_main.cpp，进程名为zygote。 12345678910111213141516service zygote /system/bin/app_process32 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd writepid /dev/cpuset/foreground/tasksservice zygote_secondary /system/bin/app_process64 -Xzygote /system/bin --zygote --socket-name=zygote_secondary class main socket zygote_secondary stream 660 root system onrestart restart zygote writepid /dev/cpuset/foreground/tasks Zygote进程能够重启的地方: servicemanager进程被杀; (onresart)surfaceflinger进程被杀; (onresart)Zygote进程自己被杀; (oneshot=false)system_server进程被杀; (waitpid)从App_main()开始，Zygote启动过程的函数调用类大致流程如下： 4.2.2、Zygote启动过程4.2.2.1、App_main.main()[-&gt; App_main.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113int main(int argc, char* const argv[])&#123; if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) &lt; 0) &#123; // Older kernels don't understand PR_SET_NO_NEW_PRIVS and return // EINVAL. Don't die on such kernels. if (errno != EINVAL) &#123; LOG_ALWAYS_FATAL(\"PR_SET_NO_NEW_PRIVS failed: %s\", strerror(errno)); return 12; &#125; &#125; //传到的参数argv为“-Xzygote /system/bin --zygote --start-system-server” AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // Process command line arguments // ignore argv[0] //忽略第一个参数 argc--; argv++; int i; for (i = 0; i &lt; argc; i++) &#123; if (argv[i][0] != '-') &#123; break; &#125; if (argv[i][1] == '-' &amp;&amp; argv[i][2] == 0) &#123; ++i; // Skip --. break; &#125; runtime.addOption(strdup(argv[i])); &#125; // Parse runtime arguments. Stop at first unrecognized option. //参数解析 bool zygote = false; bool startSystemServer = false; bool application = false; String8 niceName; String8 className; ++i; // Skip unused \"parent dir\" argument. while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, \"--zygote\") == 0) &#123; zygote = true; niceName = ZYGOTE_NICE_NAME; &#125; else if (strcmp(arg, \"--start-system-server\") == 0) &#123; startSystemServer = true; &#125; else if (strcmp(arg, \"--application\") == 0) &#123; application = true; &#125; else if (strncmp(arg, \"--nice-name=\", 12) == 0) &#123; niceName.setTo(arg + 12); &#125; else if (strncmp(arg, \"--\", 2) != 0) &#123; className.setTo(arg); break; &#125; else &#123; --i; break; &#125; &#125; Vector&lt;String8&gt; args; if (!className.isEmpty()) &#123; // We're not in zygote mode, the only argument we need to pass // to RuntimeInit is the application argument. // // The Remainder of args get passed to startup class main(). Make // copies of them before we overwrite them with the process name. // 运行application或tool程序 args.add(application ? String8(\"application\") : String8(\"tool\")); runtime.setClassNameAndArgs(className, argc - i, argv + i); &#125; else &#123; // We're in zygote mode. //进入zygote模式，创建 /data/dalvik-cache路径 maybeCreateDalvikCache(); if (startSystemServer) &#123; args.add(String8(\"start-system-server\")); &#125; char prop[PROP_VALUE_MAX]; if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123; LOG_ALWAYS_FATAL(\"app_process: Unable to determine ABI list from property %s.\", ABI_LIST_PROPERTY); return 11; &#125; String8 abiFlag(\"--abi-list=\"); abiFlag.append(prop); args.add(abiFlag); // In zygote mode, pass all remaining arguments to the zygote // main() method. for (; i &lt; argc; ++i) &#123; args.add(String8(argv[i])); &#125; &#125; //设置进程名 if (!niceName.isEmpty()) &#123; runtime.setArgv0(niceName.string()); set_process_name(niceName.string()); &#125; if (zygote) &#123; // 启动AppRuntime runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; //没有指定类名或zygote，参数错误 fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); return 10; &#125;&#125; 4.2.2.2、AndroidRuntime.start()[-&gt; AndroidRuntime.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123;ALOGD(\"&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\\n\", className != NULL ? className : \"(unknown)\", getuid());static const String8 startSystemServer(\"start-system-server\");/* * 'startSystemServer == true' means runtime is obsolete and not run from * init.rc anymore, so we print out the boot start event here. */for (size_t i = 0; i &lt; options.size(); ++i) &#123; if (options[i] == startSystemServer) &#123; /* track our progress through the boot sequence */ const int LOG_BOOT_PROGRESS_START = 3000; LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START, ns2ms(systemTime(SYSTEM_TIME_MONOTONIC))); &#125;&#125;const char* rootDir = getenv(\"ANDROID_ROOT\");if (rootDir == NULL) &#123; rootDir = \"/system\"; if (!hasDir(\"/system\")) &#123; LOG_FATAL(\"No root directory specified, and /android does not exist.\"); return; &#125; setenv(\"ANDROID_ROOT\", rootDir, 1);&#125;//const char* kernelHack = getenv(\"LD_ASSUME_KERNEL\");//ALOGD(\"Found LD_ASSUME_KERNEL='%s'\\n\", kernelHack);/* start the virtual machine */JniInvocation jni_invocation;jni_invocation.Init(NULL);JNIEnv* env;// 虚拟机创建if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; return;&#125;onVmCreated(env);/* * Register android functions. */ // JNI方法注册if (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return;&#125;/* * We want to call main() with a String array with arguments in it. * At present we have two arguments, the class name and an option string. * Create an array to hold them. */jclass stringClass;jobjectArray strArray;jstring classNameStr;//等价 strArray= new String[options.size() + 1];stringClass = env-&gt;FindClass(\"java/lang/String\");assert(stringClass != NULL);strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);assert(strArray != NULL);//等价 strArray[0] = \"com.android.internal.os.ZygoteInit\"classNameStr = env-&gt;NewStringUTF(className);assert(classNameStr != NULL);env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);//等价 strArray[1] = \"start-system-server\"；// strArray[2] = \"--abi-list=xxx\"；//其中xxx为系统响应的cpu架构类型，比如arm64-v8a.for (size_t i = 0; i &lt; options.size(); ++i) &#123; jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);&#125;/* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ //将\"com.android.internal.os.ZygoteInit\"转换为\"com/android/internal/os/ZygoteInit\"char* slashClassName = toSlashClassName(className);jclass startClass = env-&gt;FindClass(slashClassName);if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */&#125; else &#123; jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; // 调用ZygoteInit.main()方法 env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); #if 0 if (env-&gt;ExceptionCheck()) threadExitUncaughtException(env); #endif &#125;&#125;free(slashClassName);ALOGD(\"Shutting down VM\\n\");if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK) ALOGW(\"Warning: unable to detach main thread\\n\");if (mJavaVM-&gt;DestroyJavaVM() != 0) ALOGW(\"Warning: VM did not shut down cleanly\\n\"); &#125; 4.2.2.3、AndroidRuntime.startVm()[–&gt; AndroidRuntime.cpp] 12345678910111213141516171819202122232425262728293031323334353637383940414243int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote)&#123;// JNI检测功能，用于native层调用jni函数时进行常规检测，比较弱字符串格式是否符合要求，资源是否正确释放。该功能一般用于早期系统调试或手机Eng版，对于User版往往不会开启，引用该功能比较消耗系统CPU资源，降低系统性能。 bool checkJni = false;property_get(\"dalvik.vm.checkjni\", propBuf, \"\");if (strcmp(propBuf, \"true\") == 0) &#123; checkJni = true;&#125; else if (strcmp(propBuf, \"false\") != 0) &#123; /* property is neither true nor false; fall back on kernel parameter */ property_get(\"ro.kernel.android.checkjni\", propBuf, \"\"); if (propBuf[0] == '1') &#123; checkJni = true; &#125;&#125;ALOGD(\"CheckJNI is %s\\n\", checkJni ? \"ON\" : \"OFF\");if (checkJni) &#123; addOption(\"-Xcheck:jni\")&#125;...... //虚拟机产生的trace文件，主要用于分析系统问题，路径默认为/data/anr/traces.txtparseRuntimeOption(\"dalvik.vm.stack-trace-file\", stackTraceFileBuf, \"-Xstacktracefile:\");//对于不同的软硬件环境，这些参数往往需要调整、优化，从而使系统达到最佳性能parseRuntimeOption(\"dalvik.vm.heapstartsize\", heapstartsizeOptsBuf, \"-Xms\", \"4m\");parseRuntimeOption(\"dalvik.vm.heapsize\", heapsizeOptsBuf, \"-Xmx\", \"16m\");parseRuntimeOption(\"dalvik.vm.heapgrowthlimit\", heapgrowthlimitOptsBuf, \"-XX:HeapGrowthLimit=\");parseRuntimeOption(\"dalvik.vm.heapminfree\", heapminfreeOptsBuf, \"-XX:HeapMinFree=\");parseRuntimeOption(\"dalvik.vm.heapmaxfree\", heapmaxfreeOptsBuf, \"-XX:HeapMaxFree=\");parseRuntimeOption(\"dalvik.vm.heaptargetutilization\", heaptargetutilizationOptsBuf, \"-XX:HeapTargetUtilization=\");...//preloaded-classes文件内容是由WritePreloadedClassFile.java生成的，//在ZygoteInit类中会预加载工作将其中的classes提前加载到内存，以提高系统性能if (!hasFile(\"/system/etc/preloaded-classes\")) &#123; return -1;&#125;//初始化虚拟机if (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; 0) &#123; ALOGE(\"JNI_CreateJavaVM failed\\n\"); return -1;&#125;&#125; 创建Java虚拟机方法的主要篇幅是关于虚拟机参数的设置，下面只列举部分在调试优化过程中常用参数。 4.2.2.4、AndroidRuntime.startReg()1234567891011121314int AndroidRuntime::startReg(JNIEnv* env)&#123; //设置线程创建方法为javaCreateThreadEtc androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); env-&gt;PushLocalFrame(200); //进程NI方法的注册 if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) &#123; env-&gt;PopLocalFrame(NULL); return -1; &#125; env-&gt;PopLocalFrame(NULL); return 0;&#125; 4.2.2.4.1、Threads.androidSetCreateThreadFunc()[-&gt; Threads.cpp] 1234void androidSetCreateThreadFunc(android_create_thread_fn func)&#123; gCreateThreadFn = func;&#125; 虚拟机启动后startReg()过程，会设置线程创建函数指针gCreateThreadFn指向javaCreateThreadEtc. 4.2.2.4.2、register_jni_procs()123456789static int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env)&#123; for (size_t i = 0; i &lt; count; i++) &#123; if (array[i].mProc(env) &lt; 0) &#123; return -1; &#125; &#125; return 0;&#125; #####4.2.2.4.3、gRegJNI.mProc 12345static const RegJNIRec gRegJNI[] = &#123; REG_JNI(register_com_android_internal_os_RuntimeInit), REG_JNI(register_android_os_Binder)， ...&#125;；* array[i]是指gRegJNI数组, 该数组有100多个成员。其中每一项成员都是通过REG_JNI宏定义的： 1234#define REG_JNI(name) &#123; name &#125;struct RegJNIRec &#123; int (*mProc)(JNIEnv*);&#125;; 可见，调用mProc，就等价于调用其参数名所指向的函数。 例如REG_JNI(register_com_android_internal_os_RuntimeInit).mProc也就是指进入register_com_android_internal_os_RuntimeInit方法，接下来就继续以此为例来说明： 12345int register_com_android_internal_os_RuntimeInit(JNIEnv* env)&#123; return jniRegisterNativeMethods(env, \"com/android/internal/os/RuntimeInit\", gMethods, NELEM(gMethods));&#125; //gMethods：java层方法名与jni层的方法的一一映射关系 12345678static JNINativeMethod gMethods[] = &#123; &#123; \"nativeFinishInit\", \"()V\", (void*) com_android_internal_os_RuntimeInit_nativeFinishInit &#125;, &#123; \"nativeZygoteInit\", \"()V\", (void*) com_android_internal_os_RuntimeInit_nativeZygoteInit &#125;, &#123; \"nativeSetExitWithoutCleanup\", \"(Z)V\", (void*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup &#125;,&#125;; 4.2.2.5、进入Java层AndroidRuntime.start()执行到最后通过反射调用到ZygoteInit.main(),见下文: 4.2.2.5.1、ZygoteInit.main()12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String argv[]) &#123;try &#123;Init\"); //开启DDMS功能 RuntimeInit.enableDdms(); SamplingProfilerIntegration.start(); boolean startSystemServer = false; String socketName = \"zygote\"; String abiList = null; for (int i = 1; i &lt; argv.length; i++) &#123; if (\"start-system-server\".equals(argv[i])) &#123; startSystemServer = true; &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123; abiList = argv[i].substring(ABI_LIST_ARG.length()); &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123; socketName = argv[i].substring(SOCKET_NAME_ARG.length()); &#125; else &#123; throw new RuntimeException(\"Unknown command line argument: \" + argv[i]); &#125; &#125; ...... //为Zygote注册socket registerZygoteSocket(socketName); preload();// 预加载类和资源 SamplingProfilerIntegration.writeZygoteSnapshot(); gcAndFinalize();//GC操作 Zygote.nativeUnmountStorageOnInit(); ZygoteHooks.stopZygoteNoThreadCreation(); if (startSystemServer) &#123;//启动system_server startSystemServer(abiList, socketName); &#125; runSelectLoop(abiList);//进入循环模式 closeServerSocket();&#125; catch (MethodAndArgsCaller caller) &#123; caller.run();&#125; catch (Throwable ex) &#123; closeServerSocket(); throw ex;&#125;&#125; 在异常捕获后调用的方法caller.run()，会在后续的system_server文章会讲到。 4.2.2.5.2、ZygoteInit.registerZygoteSocket()1234567891011121314151617181920private static void registerZygoteSocket(String socketName) &#123;if (sServerSocket == null) &#123; int fileDesc; final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try &#123; String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); &#125; catch (RuntimeException ex) &#123; ... &#125; try &#123; FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); //设置文件描述符 sServerSocket = new LocalServerSocket(fd); //创建Socket的本地服务端 &#125; catch (IOException ex) &#123; ... &#125;&#125;&#125; 4.2.2.5.2、ZygoteInit.preload()1234567891011121314151617181920static void preload() &#123; //预加载位于/system/etc/preloaded-classes文件中的类 preloadClasses(); //预加载资源，包含drawable和color资源 preloadResources(); //预加载OpenGL preloadOpenGL(); //通过System.loadLibrary()方法， //预加载\"android\",\"compiler_rt\",\"jnigraphics\"这3个共享库 preloadSharedLibraries(); //预加载 文本连接符资源 preloadTextResources(); //仅用于zygote进程，用于内存共享的进程 WebViewFactory.prepareWebViewInZygote();&#125; 执行Zygote进程的初始化,对于类加载，采用反射机制Class.forName()方法来加载。对于资源加载，主要是 com.android.internal.R.array.preloaded_drawables和com.android.internal.R.array.preloaded_color_state_lists，在应用程序中以com.android.internal.R.xxx开头的资源，便是此时由Zygote加载到内存的。 zygote进程内加载了preload()方法中的所有资源，当需要fork新进程时，采用copy on write技术，如下： 4.2.2.5.3、ZygoteInit.startSystemServer()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123; long capabilities = posixCapabilitiesAsBits( OsConstants.CAP_BLOCK_SUSPEND, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG ); //参数准备 String args[] = &#123; \"--setuid=1000\", \"--setgid=1000\", \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"com.android.server.SystemServer\", &#125;; ZygoteConnection.Arguments parsedArgs = null; int pid; try &#123; //用于解析参数，生成目标格式 parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); // fork子进程，用于运行system_server pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; //进入子进程system_server if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; // 完成system_server进程剩余的工作 handleSystemServerProcess(parsedArgs); &#125; return true;&#125; 准备参数并fork新进程，从上面可以看出system server进程参数信息为uid=1000,gid=1000,进程名为sytem_server，从zygote进程fork新进程后，需要关闭zygote原有的socket。另外，对于有两个zygote进程情况，需等待第2个zygote创建完成。 4.2.2.5.4、ZygoteInit.runSelectLoop()1234567891011121314151617181920212223242526272829303132333435363738394041424344private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); //sServerSocket是socket通信中的服务端，即zygote进程。保存到fds[0] fds.add(sServerSocket.getFileDescriptor()); peers.add(null); while (true) &#123; StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) &#123; pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; &#125; try &#123; //处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里 Os.poll(pollFds, -1); &#125; catch (ErrnoException ex) &#123; ... &#125; for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; //采用I/O多路复用机制，当接收到客户端发出连接请求 或者数据处理请求到来，则往下执行； // 否则进入continue，跳出本次循环。 if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123; //即fds[0]，代表的是sServerSocket，则意味着有客户端连接请求； // 则创建ZygoteConnection对象,并添加到fds。 ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); //添加到fds. &#125; else &#123; //i&gt;0，则代表通过socket接收来自对端的数据，并执行相应操作 boolean done = peers.get(i).runOnce(); if (done) &#123; peers.remove(i); fds.remove(i); //处理完则从fds中移除该文件描述符 &#125; &#125; &#125; &#125;&#125; Zygote采用高效的I/O多路复用机制，保证在没有客户端连接请求或数据处理时休眠，否则响应客户端的请求。 4.2.2.5.4、ZygoteConnection.runOnce()123456789101112131415161718192021222324252627282930313233343536373839404142434445boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;String args[];Arguments parsedArgs = null;FileDescriptor[] descriptors;try &#123; //读取socket客户端发送过来的参数列表 args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors();&#125; catch (IOException ex) &#123; ... return true;&#125;...try &#123; //将binder客户端传递过来的参数，解析成Arguments对象格式 parsedArgs = new Arguments(args); ... pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir);&#125; catch (Exception e) &#123; ...&#125;try &#123; if (pid == 0) &#123; //子进程执行 IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; //进入子进程流程 handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); return true; &#125; else &#123; //父进程执行 IoUtils.closeQuietly(childPipeFd); childPipeFd = null; return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); &#125;&#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd);&#125; 4.2.2.6、总结Zygote启动过程的调用流程图： 1、解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；2、 调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；3、通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；4、registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求；5、preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率；6、zygote完毕大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。7、 zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。 （3）、启动SystemServer上篇4.3.1、启动流程SystemServer的在Android体系中所处的地位，SystemServer由Zygote fork生成的，进程名为system_server，该进程承载着framework的核心服务。 Android系统启动-zygote篇中讲到Zygote启动过程中会调用startSystemServer()，可知startSystemServer()函数是system_server启动流程的起点， 启动流程图如下：图前4步骤（即颜色为紫色的流程）运行在是Zygote进程，从第5步（即颜色为蓝色的流程）ZygoteInit.handleSystemServerProcess开始是运行在新创建的system_server，这是fork机制实现的（fork会返回2次）。下面从startSystemServer()开始讲解详细启动流程。 4.3.2、ZygoteInit.startSystemServer()1234567891011121314151617181920212223242526272829303132333435363738394041424344private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123; ... //参数准备 String args[] = &#123; \"--setuid=1000\", \"--setgid=1000\", \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"com.android.server.SystemServer\", &#125;; ZygoteConnection.Arguments parsedArgs = null; int pid; try &#123; //用于解析参数，生成目标格式 parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); // fork子进程，该进程是system_server进程 pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; //进入子进程system_server if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; // 完成system_server进程剩余的工作 handleSystemServerProcess(parsedArgs); &#125; return true;&#125; 准备参数并fork新进程，从上面可以看出system server进程参数信息为uid=1000,gid=1000,进程名为sytem_server，从zygote进程fork新进程后，需要关闭zygote原有的socket。另外，对于有两个zygote进程情况，需等待第2个zygote创建完成。 4.3.3、Zygote. forkSystemServer()123456789101112public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags, int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123; VM_HOOKS.preFork(); // 调用native方法fork system_server进程 int pid = nativeForkSystemServer( uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities); if (pid == 0) &#123; Trace.setTracingEnabled(true); &#125; VM_HOOKS.postForkCommon(); return pid;&#125; nativeForkSystemServer()方法在AndroidRuntime.cpp中注册的，调用com_android_internal_os_Zygote.cpp中的register_com_android_internal_os_Zygote()方法建立native方法的映射关系，所以接下来进入如下方法。 4.3.4、com_android_internal_os_Zygote.nativeForkSystemServer()123456789101112131415161718192021static jint com_android_internal_os_Zygote_nativeForkSystemServer( JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids, jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities, jlong effectiveCapabilities) &#123; //fork子进程， pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags, rlimits, permittedCapabilities, effectiveCapabilities, MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL, NULL, NULL); if (pid &gt; 0) &#123; // zygote进程，检测system_server进程是否创建 gSystemServerPid = pid; int status; if (waitpid(pid, &amp;status, WNOHANG) == pid) &#123; //当system_server进程死亡后，重启zygote进程 RuntimeAbort(env); &#125; &#125; return pid;&#125; 当system_server进程创建失败时，将会重启zygote进程。这里需要注意，对于Android 5.0以上系统，有两个zygote进程，分别是zygote、zygote64两个进程，system_server的父进程，一般来说64位系统其父进程是zygote64进程 当kill system_server进程后，只重启zygote64和system_server，不重启zygote;当kill zygote64进程后，只重启zygote64和system_server，也不重启zygote；当kill zygote进程，则重启zygote、zygote64以及system_server。 4.3.5、com_android_internal_os_Zygote.ForkAndSpecializeCommon()12345678910111213141516171819202122232425262728293031323334353637383940414243444546static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids, jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities, jint mount_external, jstring java_se_info, jstring java_se_name, bool is_system_server, jintArray fdsToClose, jstring instructionSet, jstring dataDir) &#123; SetSigChldHandler(); //设置子进程的signal信号处理函数 pid_t pid = fork(); //fork子进程 if (pid == 0) &#123; //进入子进程 DetachDescriptors(env, fdsToClose); //关闭并清除文件描述符 if (!is_system_server) &#123; //对于非system_server子进程，则创建进程组 int rc = createProcessGroup(uid, getpid()); &#125; SetGids(env, javaGids); //设置设置group SetRLimits(env, javaRlimits); //设置资源limit int rc = setresgid(gid, gid, gid); rc = setresuid(uid, uid, uid); SetCapabilities(env, permittedCapabilities, effectiveCapabilities); SetSchedulerPolicy(env); //设置调度策略 //selinux上下文 rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str); if (se_info_c_str == NULL &amp;&amp; is_system_server) &#123; se_name_c_str = \"system_server\"; &#125; if (se_info_c_str != NULL) &#123; SetThreadName(se_name_c_str); //设置线程名为system_server，方便调试 &#125; UnsetSigChldHandler(); //设置子进程的signal信号处理函数为默认函数 //等价于调用zygote.callPostForkChildHooks() env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags, is_system_server ? NULL : instructionSet); ... &#125; else if (pid &gt; 0) &#123; //进入父进程，即zygote进程 &#125; return pid;&#125; fork()创建新进程，采用copy on write方式，这是linux创建进程的标准方法，会有两次return,对于pid==0为子进程的返回，对于pid&gt;0为父进程的返回。 到此system_server进程已完成了创建的所有工作，接下来开始了system_server进程的真正工作。在前面startSystemServer()方法中，zygote进程执行完forkSystemServer()后，新创建出来的system_server进程便进入handleSystemServerProcess()方法。 4.3.5、ZygoteInit.handleSystemServerProcess()123456789101112131415161718192021222324252627282930313233343536373839404142434445private static void handleSystemServerProcess( ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123; closeServerSocket(); //关闭父进程zygote复制而来的Socket Os.umask(S_IRWXG | S_IRWXO); if (parsedArgs.niceName != null) &#123; Process.setArgV0(parsedArgs.niceName); //设置当前进程名为\"system_server\" &#125; final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\"); if (systemServerClasspath != null) &#123; //执行dex优化操作 performSystemServerDexOpt(systemServerClasspath); &#125; if (parsedArgs.invokeWith != null) &#123; String[] args = parsedArgs.remainingArgs; if (systemServerClasspath != null) &#123; String[] amendedArgs = new String[args.length + 2]; amendedArgs[0] = \"-cp\"; amendedArgs[1] = systemServerClasspath; System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length); &#125; //启动应用进程 WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), null, args); &#125; else &#123; ClassLoader cl = null; if (systemServerClasspath != null) &#123; 创建类加载器，并赋予当前线程 cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader()); Thread.currentThread().setContextClassLoader(cl); &#125; //system_server故进入此分支 RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl); &#125; /* should never reach here */&#125; 此处systemServerClasspath环境变量主要有/system/framework/目录下的services.jar，ethernet-service.jar, wifi-service.jar这3个文件 4.3.6、ZygoteInit.performSystemServerDexOpt()123456789101112131415161718192021222324private static void performSystemServerDexOpt(String classPath) &#123; final String[] classPathElements = classPath.split(\":\"); //创建一个与installd的建立socket连接 final InstallerConnection installer = new InstallerConnection(); //执行ping操作，直到与installd服务端连通为止 installer.waitForConnection(); final String instructionSet = VMRuntime.getRuntime().vmInstructionSet(); try &#123; for (String classPathElement : classPathElements) &#123; final int dexoptNeeded = DexFile.getDexOptNeeded( classPathElement, \"*\", instructionSet, false /* defer */); if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123; //以system权限，执行dex文件优化 installer.dexopt(classPathElement, Process.SYSTEM_UID, false, instructionSet, dexoptNeeded); &#125; &#125; &#125; catch (IOException ioe) &#123; throw new RuntimeException(\"Error starting system_server\", ioe); &#125; finally &#123; installer.disconnect(); //断开与installd的socket连接 &#125;&#125; 将classPath字符串中的apk，分别进行dex优化操作。真正执行优化工作通过socket通信将相应的命令参数，发送给installd来完成。 4.3.7、RuntimeInit.zygoteInit()12345678910public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); redirectLogStreams(); //重定向log输出 commonInit(); // 通用的一些初始化 nativeZygoteInit(); // zygote初始化 applicationInit(targetSdkVersion, argv, classLoader); // 应用初始化&#125; 4.3.8、RuntimeInit.commonInit()123456789101112131415161718192021222324private static final void commonInit() &#123; // 设置默认的未捕捉异常处理方法 Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler()); // 设置市区，中国时区为\"Asia/Shanghai\" TimezoneGetter.setInstance(new TimezoneGetter() &#123; @Override public String getId() &#123; return SystemProperties.get(\"persist.sys.timezone\"); &#125; &#125;); TimeZone.setDefault(null); //重置log配置 LogManager.getLogManager().reset(); new AndroidConfig(); // 设置默认的HTTP User-agent格式,用于 HttpURLConnection。 String userAgent = getDefaultUserAgent(); System.setProperty(\"http.agent\", userAgent); // 设置socket的tag，用于网络流量统计 NetworkManagementSocketTagger.install();&#125; 默认的HTTP User-agent格式，例如： “Dalvik/1.1.0 (Linux; U; Android 6.0.1；LenovoX3c70 Build/LMY47V)”. 4.3.9、AndroidRuntime.nativeZygoteInit()nativeZygoteInit()方法在AndroidRuntime.cpp中，进行了jni映射，对应下面的方法。 12345static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)&#123; //此处的gCurRuntime为AppRuntime，是在AndroidRuntime.cpp中定义的 gCurRuntime-&gt;onZygoteInit();&#125; 1234567[–&gt;app_main.cpp]virtual void onZygoteInit()&#123; sp&lt;ProcessState&gt; proc = ProcessState::self(); proc-&gt;startThreadPool(); //启动新binder线程&#125; ProcessState::self()是单例模式，主要工作是调用open()打开/dev/binder驱动设备，再利用mmap()映射内核的地址空间，将Binder驱动的fd赋值ProcessState对象中的变量mDriverFD，用于交互操作。startThreadPool()是创建一个新的binder线程，不断进行talkWithDriver()，在binder系列文章中的注册服务(addService)详细这两个方法的执行原理。 4.3.10、RuntimeInit.applicationInit()123456789101112131415161718192021private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; //true代表应用程序退出时不调用AppRuntime.onExit()，否则会在退出前调用 nativeSetExitWithoutCleanup(true); //设置虚拟机的内存利用率参数值为0.75 VMRuntime.getRuntime().setTargetHeapUtilization(0.75f); VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); final Arguments args; try &#123; args = new Arguments(argv); //解析参数 &#125; catch (IllegalArgumentException ex) &#123; return; &#125; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); //调用startClass的static方法 main() invokeStaticMain(args.startClass, args.startArgs, classLoader);&#125; 在startSystemServer()方法中通过硬编码初始化参数，可知此处args.startClass为”com.android.server.SystemServer”。 4.3.11、RuntimeInit.invokeStaticMain()12345678910111213141516171819202122private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl = Class.forName(className, true, classLoader); ... Method m; try &#123; m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; ... &#125; catch (SecurityException ex) &#123; ... &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; ... &#125; //通过抛出异常，回到ZygoteInit.main()。这样做好处是能清空栈帧，提高栈帧利用率。 throw new ZygoteInit.MethodAndArgsCaller(m, argv);&#125; 4.3.12、MethodAndArgsCaller.run()在Zygote中遗留了一个问题没有讲解，如下： [–&gt;ZygoteInit.java] 1234567891011public static void main(String argv[]) &#123; try &#123; startSystemServer(abiList, socketName);//启动system_server .... &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; catch (RuntimeException ex) &#123; closeServerSocket(); throw ex; &#125;&#125; 现在已经很明显了，是invokeStaticMain()方法中抛出的异常MethodAndArgsCaller，从而进入caller.run()方法。 [–&gt;ZygoteInit.java] 1234567891011121314151617181920public static class MethodAndArgsCaller extends Exception implements Runnable &#123; public void run() &#123; try &#123; //根据传递过来的参数，可知此处通过反射机制调用的是SystemServer.main()方法 mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) &#123; throw (RuntimeException) cause; &#125; else if (cause instanceof Error) &#123; throw (Error) cause; &#125; throw new RuntimeException(ex); &#125; &#125;&#125; 到此，总算是进入到了SystemServer类的main()方法， 在文章Android系统启动-SystemServer下篇中会紧接着这里开始讲述。 （4）、启动SystemServer下篇上篇文章Android系统启动-systemServer上篇 从Zygote一路启动到SystemServer的过程。 简单回顾下，在RuntimeInit.java中invokeStaticMain方法通过创建并抛出异常ZygoteInit.MethodAndArgsCaller，在ZygoteInit.java中的main()方法会捕捉该异常，并调用caller.run()，再通过反射便会调用到SystemServer.main()方法，该方法主要执行流程： 1234567SystemServer.main SystemServer.run createSystemContext startBootstrapServices(); startCoreServices(); startOtherServices(); Looper.loop(); 接下来，从其main方法说起。 4.4.1、SystemServer.main()1234567public final class SystemServer &#123; ... public static void main(String[] args) &#123; //先初始化SystemServer对象，再调用对象的run()方法 new SystemServer().run(); &#125;&#125; 4.4.2、SystemServer.run()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private void run() &#123; //当系统时间比1970年更早，就设置当前系统时间为1970年 if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123; SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); &#125; //变更虚拟机的库文件，对于Android 6.0默认采用的是libart.so SystemProperties.set(\"persist.sys.dalvik.vm.lib.2\", VMRuntime.getRuntime().vmLibrary()); if (SamplingProfilerIntegration.isEnabled()) &#123; ... &#125; //清除vm内存增长上限，由于启动过程需要较多的虚拟机内存空间 VMRuntime.getRuntime().clearGrowthLimit(); //设置内存的可能有效使用率为0.8 VMRuntime.getRuntime().setTargetHeapUtilization(0.8f); // 针对部分设备依赖于运行时就产生指纹信息，因此需要在开机完成前已经定义 Build.ensureFingerprintProperty(); //访问环境变量前，需要明确地指定用户 Environment.setUserRequired(true); //确保当前系统进程的binder调用，总是运行在前台优先级(foreground priority) BinderInternal.disableBackgroundScheduling(true); android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); // 主线程looper就在当前线程运行 Looper.prepareMainLooper(); //加载android_servers.so库，该库包含的源码在frameworks/base/services/目录下 System.loadLibrary(\"android_servers\"); //检测上次关机过程是否失败，该方法可能不会返回 performPendingShutdown(); //初始化系统上下文 createSystemContext(); //创建系统服务管理 mSystemServiceManager = new SystemServiceManager(mSystemContext); //将mSystemServiceManager添加到本地服务的成员sLocalServiceObjects LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); //启动各种系统服务 try &#123; startBootstrapServices(); // 启动引导服务 startCoreServices(); // 启动核心服务 startOtherServices(); // 启动其他服务 &#125; catch (Throwable ex) &#123; Slog.e(\"System\", \"************ Failure starting system services\", ex); throw ex; &#125; //用于debug版本，将log事件不断循环地输出到dropbox（用于分析） if (StrictMode.conditionallyEnableDebugLogging()) &#123; Slog.i(TAG, \"Enabled StrictMode for system server main thread.\"); &#125; //一直循环执行 Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; LocalServices通过用静态Map变量sLocalServiceObjects，来保存以服务类名为key，以具体服务对象为value的Map结构。 4.4.3、SystemServer.performPendingShutdown()12345678910111213141516private void performPendingShutdown() &#123; final String shutdownAction = SystemProperties.get( ShutdownThread.SHUTDOWN_ACTION_PROPERTY, \"\"); if (shutdownAction != null &amp;&amp; shutdownAction.length() &gt; 0) &#123; boolean reboot = (shutdownAction.charAt(0) == '1'); final String reason; if (shutdownAction.length() &gt; 1) &#123; reason = shutdownAction.substring(1, shutdownAction.length()); &#125; else &#123; reason = null; &#125; // 当\"sys.shutdown.requested\"值不为空,则会重启或者关机 ShutdownThread.rebootOrShutdown(null, reboot, reason); &#125;&#125; 4.4.4、SystemServer.createSystemContext()1234567private void createSystemContext() &#123; //创建system_server进程的上下文信息 ActivityThread activityThread = ActivityThread.systemMain(); mSystemContext = activityThread.getSystemContext(); //设置主题 mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);&#125; 理解Application创建过程已介绍过createSystemContext()过程， 该过程会创建对象有ActivityThread，Instrumentation, ContextImpl，LoadedApk，Application。 4.4.5、SystemServer.startBootstrapServices()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void startBootstrapServices() &#123; //阻塞等待与installd建立socket通道 Installer installer = mSystemServiceManager.startService(Installer.class); //启动服务ActivityManagerService mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); //启动服务PowerManagerService mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); //初始化power management mActivityManagerService.initPowerManagement(); //启动服务LightsService mSystemServiceManager.startService(LightsService.class); //启动服务DisplayManagerService mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); //Phase100: 在初始化package manager之前，需要默认的显示. mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); //当设备正在加密时，仅运行核心 String cryptState = SystemProperties.get(\"vold.decrypt\"); if (ENCRYPTING_STATE.equals(cryptState)) &#123; mOnlyCore = true; &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123; mOnlyCore = true; &#125; //启动服务PackageManagerService mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); //启动服务UserManagerService，新建目录/data/user/ ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance()); AttributeCache.init(mSystemContext); //设置AMS mActivityManagerService.setSystemProcess(); //启动传感器服务 startSensorService();&#125; 该方法所创建的服务：ActivityManagerService, PowerManagerService, LightsService, DisplayManagerService， PackageManagerService， UserManagerService， sensor服务. 4.4.5、SystemServer.startCoreServices()1234567891011121314private void startCoreServices() &#123; //启动服务BatteryService，用于统计电池电量，需要LightService. mSystemServiceManager.startService(BatteryService.class); //启动服务UsageStatsService，用于统计应用使用情况 mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); mPackageManagerService.getUsageStatsIfNoPackageUsageInfo(); //启动服务WebViewUpdateService mSystemServiceManager.startService(WebViewUpdateService.class);&#125; 启动服务BatteryService，UsageStatsService，WebViewUpdateService。 ####4.4.6 SystemServer.startOtherServices()该方法比较长，有近千行代码，逻辑很简单，主要是启动一系列的服务，这里就不具体列举源码了，在第四节直接对其中的服务进行一个简单分类。 123456789101112131415161718192021222324252627282930313233343536373839404142private void startOtherServices() &#123; ... SystemConfig.getInstance(); mContentResolver = context.getContentResolver(); // resolver ... mActivityManagerService.installSystemProviders(); //provider mSystemServiceManager.startService(AlarmManagerService.class); // alarm // watchdog watchdog.init(context, mActivityManagerService); inputManager = new InputManagerService(context); // input wm = WindowManagerService.main(...); // window inputManager.start(); //启动input mDisplayManagerService.windowManagerAndInputReady(); ... mSystemServiceManager.startService(MOUNT_SERVICE_CLASS); // mount mPackageManagerService.performBootDexOpt(); // dexopt操作 ActivityManagerNative.getDefault().showBootMessage(...); //显示启动界面 ... statusBar = new StatusBarManagerService(context, wm); //statusBar //dropbox ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File(\"/data/system/dropbox\"))); mSystemServiceManager.startService(JobSchedulerService.class); //JobScheduler lockSettings.systemReady(); //lockSettings //phase480 和phase500 mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY); mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY); ... // 准备好window, power, package, display服务 wm.systemReady(); mPowerManagerService.systemReady(...); mPackageManagerService.systemReady(); mDisplayManagerService.systemReady(...); //重头戏 mActivityManagerService.systemReady(new Runnable() &#123; public void run() &#123; ... &#125; &#125;); &#125; 4.4.7、服务启动阶段SystemServiceManager的startBootPhase()贯穿system_server进程的整个启动过程： 其中PHASE_BOOT_COMPLETED=1000，该阶段是发生在Boot完成和home应用启动完毕。系统服务更倾向于监听该阶段，而不是注册广播ACTION_BOOT_COMPLETED，从而降低系统延迟。 各个启动阶段所在源码的大致位置： 123456789101112131415161718192021222324252627282930313233public final class SystemServer &#123;private void startBootstrapServices() &#123; ... //phase100 mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); ...&#125;private void startCoreServices() &#123; ...&#125;private void startOtherServices() &#123; ... //phase480 &amp;&amp; 500 mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY); mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY); ... mActivityManagerService.systemReady(new Runnable() &#123; public void run() &#123; //phase550 mSystemServiceManager.startBootPhase( SystemService.PHASE_ACTIVITY_MANAGER_READY); ... //phase600 mSystemServiceManager.startBootPhase( SystemService.PHASE_THIRD_PARTY_APPS_CAN_START); &#125; &#125;&#125;&#125; 接下来再说说简单每个阶段的大概完成的工作： 4.4.7.1、Phase0创建四大引导服务: 1234ActivityManagerServicePowerManagerServiceLightsServiceDisplayManagerService 4.4.7.1.2、Phase100进入阶段PHASE_WAIT_FOR_DEFAULT_DISPLAY=100回调服务 123onBootPhase(100)DisplayManagerService 然后创建大量服务下面列举部分: 12345678PackageManagerServiceWindowManagerServiceInputManagerServiceNetworkManagerServiceDropBoxManagerServiceFingerprintServiceLauncherAppsService… 4.4.7.1.3、Phase480进入阶段PHASE_LOCK_SETTINGS_READY=480回调服务 123onBootPhase(480)DevicePolicyManagerService 阶段480后马上就进入阶段500. 4.4.7.1.4、Phase500PHASE_SYSTEM_SERVICES_READY=500，进入该阶段服务能安全地调用核心系统服务. 1234567891011121314151617onBootPhase(500)AlarmManagerServiceJobSchedulerServiceNotificationManagerServiceBackupManagerServiceUsageStatsServiceDeviceIdleControllerTrustManagerServiceUiModeManagerServiceBluetoothServiceBluetoothManagerServiceEthernetServiceWifiP2pServiceWifiScanningServiceWifiServiceRttService 各大服务执行systemReady(): 1234WindowManagerService.systemReady():PowerManagerService.systemReady():PackageManagerService.systemReady():DisplayManagerService.systemReady(): 接下来就绪AMS.systemReady方法. 4.4.7.1.5、Phase550PHASE_ACTIVITY_MANAGER_READY=550， AMS.mSystemReady=true, 已准备就绪,进入该阶段服务能广播Intent;但是system_server主线程并没有就绪. 12345678onBootPhase(550)MountServiceTelecomLoaderServiceUsbServiceWebViewUpdateServiceDockObserverBatteryService 接下来执行: (AMS启动native crash监控, 加载WebView，启动SystemUI等),如下 12345678910mActivityManagerService.startObservingNativeCrashes();WebViewFactory.prepareWebViewInSystemServer();startSystemUi(context);networkScoreF.systemReady();networkManagementF.systemReady();networkStatsF.systemReady();networkPolicyF.systemReady();connectivityF.systemReady();audioServiceF.systemReady();Watchdog.getInstance().start(); 4.4.7.1.6、Phase600PHASE_THIRD_PARTY_APPS_CAN_START=600 onBootPhase(600) JobSchedulerService NotificationManagerService BackupManagerServiceAppWidgetService GestureLauncherService DreamManagerServiceTrustManagerService VoiceInteractionManagerService 接下来,各种服务的systemRunning过程: WallpaperManagerService、InputMethodManagerService、LocationManagerService、CountryDetectorService、NetworkTimeUpdateService、CommonTimeManagementService、TextServicesManagerService、AssetAtlasService、InputManagerService、TelephonyRegistry、MediaRouterService、MmsServiceBroker这些服务依次执行其systemRunning()方法。 4.4.7.1.7、Phase1000在经过一系列流程，再调用AMS.finishBooting()时，则进入阶段Phase1000。 到此，系统服务启动阶段完成就绪，system_server进程启动完成则进入Looper.loop()状态，随时待命，等待消息队列MessageQueue中的消息到来，则马上进入执行状态。 4.4.8、服务类别system_server进程，从源码角度划分为引导服务、核心服务、其他服务3类。 以下这些系统服务的注册过程, 见Android系统服务的注册方式 引导服务(7个)：ActivityManagerService、PowerManagerService、LightsService、DisplayManagerService、PackageManagerService、UserManagerService、SensorService；核心服务(3个)：BatteryService、UsageStatsService、WebViewUpdateService；其他服务(70个+)：AlarmManagerService、VibratorService等。合计总大约80个系统服务： ActivityManagerService PackageManagerService WindowManagerServicePowerManagerService BatteryService BatteryStatsServiceDreamManagerService DropBoxManagerService SamplingProfilerServiceUsageStatsService DiskStatsService DeviceStorageMonitorServiceSchedulingPolicyService AlarmManagerService DeviceIdleControllerThermalObserver JobSchedulerService AccessibilityManagerServiceDisplayManagerService LightsService GraphicsStatsServiceStatusBarManagerService NotificationManagerService WallpaperManagerServiceUiModeManagerService AppWidgetService LauncherAppsServiceTextServicesManagerService ContentService LockSettingsServiceInputMethodManagerService InputManagerService MountServiceFingerprintService TvInputManagerService DockObserverNetworkManagementService NetworkScoreService NetworkStatsServiceNetworkPolicyManagerService ConnectivityService BluetoothServiceWifiP2pService WifiService WifiScanningServiceAudioService MediaRouterService VoiceInteractionManagerServiceMediaProjectionManagerService MediaSessionServiceDevicePolicyManagerService PrintManagerService BackupManagerServiceUserManagerService AccountManagerService TrustManagerServiceSensorService LocationManagerService VibratorServiceCountryDetectorService GestureLauncherService PersistentDataBlockServiceEthernetService WebViewUpdateService ClipboardServiceTelephonyRegistry TelecomLoaderService NsdServiceUpdateLockService SerialService SearchManagerServiceCommonTimeManagementService AssetAtlasService ConsumerIrServiceMidiServiceCameraService TwilightService RestrictionsManagerServiceMmsServiceBroker RttService UsbService Service类别众多，其中表中加粗项是指博主挑选的较重要或者较常见的Service，并且在本博客中已经展开或者计划展开讲解的Service，当然如果有精力会讲解更多service，后续再更新。 （5）、启动ActivityManagerService4.5.1、概述ActivityManagerService(AMS)是Android中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用程序的管理和调度等工作。 AMS通信结构如下图所示：system_server进程中AMS服务的启动过程，以startBootstrapServices()方法为起点，紧跟着startCoreServices(), startOtherServices()共3个方法。 4.5.2、SystemServer.startBootstrapServices()1234567891011121314151617private void startBootstrapServices() &#123;...//启动AMS服务mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService();//设置AMS的系统服务管理器mActivityManagerService.setSystemServiceManager(mSystemServiceManager);//设置AMS的APP安装器mActivityManagerService.setInstaller(installer);//初始化AMS相关的PMSmActivityManagerService.initPowerManagement();...//设置SystemServermActivityManagerService.setSystemProcess();&#125; 4.5.3、启动AMS服务SystemServiceManager.startService(ActivityManagerService.Lifecycle.class) 功能主要： 创建ActivityManagerService.Lifecycle对象；调用Lifecycle.onStart()方法。 4.5.4、启动AMS服务4.5.4.1 AMS.Lifecycle[-&gt; ActivityManagerService.java] 123456789101112131415161718public static final class Lifecycle extends SystemService &#123;private final ActivityManagerService mService;public Lifecycle(Context context) &#123; super(context); //创建ActivityManagerService mService = new ActivityManagerService(context);&#125;@Overridepublic void onStart() &#123; mService.start(); &#125;public ActivityManagerService getService() &#123; return mService;&#125;&#125; 该过程：创建AMS内部类的Lifecycle，已经创建AMS对象，并调用AMS.start(); 4.5.4.2 AMS创建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public ActivityManagerService(Context systemContext) &#123;mContext = systemContext;mFactoryTest = FactoryTest.getMode();//默认为FACTORY_TEST_OFFmSystemThread = ActivityThread.currentActivityThread();//创建名为\"ActivityManager\"的前台线程，并获取mHandlermHandlerThread = new ServiceThread(TAG, android.os.Process.THREAD_PRIORITY_FOREGROUND, false);mHandlerThread.start();mHandler = new MainHandler(mHandlerThread.getLooper());//通过UiThread类，创建名为\"android.ui\"的线程mUiHandler = new UiHandler();//前台广播接收器，在运行超过10s将放弃执行mFgBroadcastQueue = new BroadcastQueue(this, mHandler, \"foreground\", BROADCAST_FG_TIMEOUT, false);//后台广播接收器，在运行超过60s将放弃执行mBgBroadcastQueue = new BroadcastQueue(this, mHandler, \"background\", BROADCAST_BG_TIMEOUT, true);mBroadcastQueues[0] = mFgBroadcastQueue;mBroadcastQueues[1] = mBgBroadcastQueue;//创建ActiveServices，其中非低内存手机mMaxStartingBackground为8mServices = new ActiveServices(this);mProviderMap = new ProviderMap(this);//创建目录/data/systemFile dataDir = Environment.getDataDirectory();File systemDir = new File(dataDir, \"system\");systemDir.mkdirs();//创建服务BatteryStatsServicemBatteryStatsService = new BatteryStatsService(systemDir, mHandler);mBatteryStatsService.getActiveStatistics().readLocked();...//创建进程统计服务，信息保存在目录/data/system/procstats，mProcessStats = new ProcessStatsService(this, new File(systemDir, \"procstats\"));mAppOpsService = new AppOpsService(new File(systemDir, \"appops.xml\"), mHandler);mGrantFile = new AtomicFile(new File(systemDir, \"urigrants.xml\"));// User 0是第一个，也是唯一的一个开机过程中运行的用户mStartedUsers.put(UserHandle.USER_OWNER, new UserState(UserHandle.OWNER, true));mUserLru.add(UserHandle.USER_OWNER);updateStartedUserArrayLocked();...//CPU使用情况的追踪器执行初始化mProcessCpuTracker.init();...mRecentTasks = new RecentTasks(this);// 创建ActivityStackSupervisor对象mStackSupervisor = new ActivityStackSupervisor(this, mRecentTasks);mTaskPersister = new TaskPersister(systemDir, mStackSupervisor, mRecentTasks);//创建名为\"CpuTracker\"的线程mProcessCpuThread = new Thread(\"CpuTracker\") &#123; public void run() &#123; while (true) &#123; try &#123; try &#123; synchronized(this) &#123; final long now = SystemClock.uptimeMillis(); long nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now; long nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now; if (nextWriteDelay &lt; nextCpuDelay) &#123; nextCpuDelay = nextWriteDelay; &#125; if (nextCpuDelay &gt; 0) &#123; mProcessCpuMutexFree.set(true); this.wait(nextCpuDelay); &#125; &#125; &#125; catch (InterruptedException e) &#123; &#125; updateCpuStatsNow(); //更新CPU状态 &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125;;...&#125; 4.5.4.3、AMS的start函数 123456789101112private void start() &#123; //完成统计前的复位工作 Process.removeAllProcessGroups(); //开始监控进程的CPU使用情况 mProcessCpuThread.start(); //注册服务 mBatteryStatsService.publish(mContext); mAppOpsService.publish(mContext); Slog.d(\"AppOps\", \"AppOpsService published\"); LocalServices.addService(ActivityManagerInternal.class, new LocalService()); AMS的start函数比较简单，主要是：1、启动CPU监控线程。该线程将会开始统计不同进程使用CPU的情况。2、发布一些服务，如BatteryStatsService、AppOpsService(权限管理相关)和本地实现的继承ActivityManagerInternal的服务。 4.5.5 AMS.setSystemProcess() 123456789101112131415161718192021222324252627282930313233public void setSystemProcess() &#123; try &#123; ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true); ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats); ServiceManager.addService(\"meminfo\", new MemBinder(this)); ServiceManager.addService(\"gfxinfo\", new GraphicsBinder(this)); ServiceManager.addService(\"dbinfo\", new DbBinder(this)); if (MONITOR_CPU_USAGE) &#123; ServiceManager.addService(\"cpuinfo\", new CpuBinder(this)); &#125; ServiceManager.addService(\"permission\", new PermissionController(this)); ServiceManager.addService(\"processinfo\", new ProcessInfoService(this)); ApplicationInfo info = mContext.getPackageManager().getApplicationInfo( \"android\", STOCK_PM_FLAGS); mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader()); synchronized (this) &#123; //创建ProcessRecord对象 ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0); app.persistent = true; //设置为persistent进程 app.pid = MY_PID; app.maxAdj = ProcessList.SYSTEM_ADJ; app.makeActive(mSystemThread.getApplicationThread(), mProcessStats); synchronized (mPidsSelfLocked) &#123; mPidsSelfLocked.put(app.pid, app); &#125; updateLruProcessLocked(app, false, null);//维护进程lru updateOomAdjLocked(); //更新adj &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; throw new RuntimeException(\"\", e); &#125;&#125; 该方法主要工作是注册各种服务。 4.5.5.1 AT.installSystemApplicationInfo() 12345678public void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) &#123; synchronized (this) &#123; // getSystemContext().installSystemApplicationInfo(info, classLoader); //创建用于性能统计的Profiler对象 mProfiler = new Profiler(); &#125;&#125; 该方法调用ContextImpl的nstallSystemApplicationInfo()方法，最终调用LoadedApk的installSystemApplicationInfo，加载名为“android”的package 4.5.5.2 installSystemApplicationInfo()[-&gt; LoadedApk.java] 12345void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) &#123; assert info.packageName.equals(\"android\"); mApplicationInfo = info; //将包名为\"android\"的应用信息保存到mApplicationInfo mClassLoader = classLoader;&#125; 4.5.6 startOtherServices() 123456789101112131415161718192021222324private void startOtherServices() &#123; ... //安装系统Provider mActivityManagerService.installSystemProviders(); ... //phase480 &amp;&amp; 500 mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY); mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY); ... mActivityManagerService.systemReady(new Runnable() &#123; public void run() &#123; //phase550 mSystemServiceManager.startBootPhase( SystemService.PHASE_ACTIVITY_MANAGER_READY); ... //phase600 mSystemServiceManager.startBootPhase( SystemService.PHASE_THIRD_PARTY_APPS_CAN_START); ... &#125; &#125;&#125; 4.5.6.1 AMS.installSystemProviders() 1234567891011121314151617181920212223public final void installSystemProviders() &#123; List&lt;ProviderInfo&gt; providers; synchronized (this) &#123; ProcessRecord app = mProcessNames.get(\"system\", Process.SYSTEM_UID); providers = generateApplicationProvidersLocked(app); if (providers != null) &#123; for (int i=providers.size()-1; i&gt;=0; i--) &#123; ProviderInfo pi = (ProviderInfo)providers.get(i); //移除非系统的provider if ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) == 0) &#123; providers.remove(i); &#125; &#125; &#125; &#125; if (providers != null) &#123; //安装所有的系统provider mSystemThread.installSystemProviders(providers); &#125; // 创建核心Settings Observer，用于监控Settings的改变。 mCoreSettingsObserver = new CoreSettingsObserver(this);&#125; 4.5.7、AMS.systemReady()4.5.7.1、阶段一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void systemReady(final Runnable goingCallback) &#123; synchronized(this) &#123; .......... //这一部分主要是调用一些关键服务SystemReady相关的函数， //进行一些等待AMS初始完，才能进行的工作 // Make sure we have the current profile info, since it is needed for security checks. mUserController.onSystemReady(); mRecentTasks.onSystemReadyLocked(); mAppOpsService.systemReady(); mSystemReady = true; &#125; ArrayList&lt;ProcessRecord&gt; procsToKill = null; synchronized(mPidsSelfLocked) &#123; //mPidsSelfLocked中保存当前正在运行的所有进程的信息 for (int i=mPidsSelfLocked.size()-1; i&gt;=0; i--) &#123; ProcessRecord proc = mPidsSelfLocked.valueAt(i); //在AMS启动完成前，如果没有FLAG_PERSISTENT标志的进程已经启动了， //就将这个进程加入到procsToKill中 if (!isAllowedWhileBooting(proc.info))&#123; if (procsToKill == null) &#123; procsToKill = new ArrayList&lt;ProcessRecord&gt;(); &#125; procsToKill.add(proc); &#125; &#125; &#125; synchronized(this) &#123; //利用removeProcessLocked关闭procsToKill中的进程 if (procsToKill != null) &#123; for (int i=procsToKill.size()-1; i&gt;=0; i--) &#123; ProcessRecord proc = procsToKill.get(i); Slog.i(TAG, \"Removing system update proc: \" + proc); removeProcessLocked(proc, true, false, \"system update done\"); &#125; &#125; // Now that we have cleaned up any update processes, we // are ready to start launching real processes and know that // we won't trample on them any more. //至此系统准备完毕 mProcessesReady = true; &#125; ............ //根据数据库和资源文件，获取一些配置参数 retrieveSettings(); final int currentUserId; synchronized (this) &#123; //得到当前的用户ID currentUserId = mUserController.getCurrentUserIdLocked(); //读取urigrants.xml，为其中定义的ContentProvider配置对指定Uri数据的访问/修改权限 //原生代码中，似乎没有urigrants.xml文件 //实际使用的grant-uri-permission是分布式定义的 readGrantedUriPermissionsLocked(); &#125; .......... 这一部分的工作主要是调用一些关键服务的初始化函数，然后杀死那些没有FLAG_PERSISTENT却在AMS启动完成前已经存在的进程，同时获取一些配置参数。需要注意的是，由于只有Java进程才会向AMS注册，而一般的Native进程不会向AMS注册，因此此处杀死的进程是Java进程。 4.5.7.2、阶段二1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//1、调用参数传入的runnable对象，SystemServer中有具体的定义if (goingCallback != null) goingCallback.run();..............//调用所有系统服务的onStartUser接口mSystemServiceManager.startUser(currentUserId);.............synchronized (this) &#123; // Only start up encryption-aware persistent apps; once user is // unlocked we'll come back around and start unaware apps 2、启动persistent为1的application所在的进程 startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE); // Start up initial activity. mBooting = true; // Enable home activity for system user, so that the system can always boot //当isSplitSystemUser返回true时，意味者system user和primary user是分离的 //这里应该是让system user也有启动home activity的权限吧 if (UserManager.isSplitSystemUser()) &#123; ComponentName cName = new ComponentName(mContext, SystemUserHomeActivity.class); try &#123; AppGlobals.getPackageManager().setComponentEnabledSetting(cName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, 0, UserHandle.USER_SYSTEM); &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; &#125; //3、启动Home startHomeActivityLocked(currentUserId, \"systemReady\"); try &#123; //发送消息，触发处理Uid错误的Application if (AppGlobals.getPackageManager().hasSystemUidErrors()) &#123; .......... mUiHandler.obtainMessage(SHOW_UID_ERROR_UI_MSG).sendToTarget(); &#125; &#125; catch (RemoteException e) &#123; &#125; //发送一些广播信息 ............ //这里暂时先不深入，等进一步了解Activity的启动过程后，再做了解 mStackSupervisor.resumeFocusedStackTopActivityLocked(); ............&#125;............. 从部分代码来看，主要的工作就是通知一些服务可以进行systemReady相关的工作，并进行启动服务或应用进程的工作。 2.1、调用回调接口回调接口的具体内容定义与SystemServer.java中，其中会调用大量服务的onBootPhase函数、一些对象的systemReady函数或systemRunning函数。此处，我们仅截取一些比较特别的内容： 123456789101112131415161718192021public void run() &#123; ............ try &#123; //启动NativeCrashListener监听\"/data/system/ndebugsocket\"中的信息 //实际上是监听debuggerd传入的信息 mActivityManagerService.startObservingNativeCrashes(); &#125; catch (Throwable e) &#123; reportWtf(\"observing native crashes\", e); &#125; ............ try &#123; //启动SystemUi startSystemUi(context); &#125; catch (Throwable e) &#123; reportWtf(\"starting System UI\", e); &#125; ............ //这个以前分析过，启动Watchdog Watchdog.getInstance().start(); ....................&#125; 回调接口中的内容较多，不做一一分析。 2.2、启动persistent标志的进程我们看看startPersistentApps对应的内容： 12345678910111213141516171819private void startPersistentApps(int matchFlags) &#123; ............. synchronized (this) &#123; try &#123; //从PKMS中得到persistent为1的ApplicationInfo final List&lt;ApplicationInfo&gt; apps = AppGlobals.getPackageManager() .getPersistentApplications(STOCK_PM_FLAGS | matchFlags).getList(); for (ApplicationInfo app : apps) &#123; //由于framework-res.apk已经由系统启动，所以此处不再启动它 if (!\"android\".equals(app.packageName)) &#123; //addAppLocked中将启动application所在进程 addAppLocked(app, false, null /* ABI override */); &#125; &#125; &#125; catch (RemoteException ex) &#123; &#125; &#125;&#125; 跟进一下addAppLocked函数： 1234567891011121314151617181920212223242526272829303132333435363738394041final ProcessRecord addAppLocked(ApplicationInfo info, boolean isolated, String abiOverride) &#123; //以下是取出或构造出ApplicationInfo对应的ProcessRecord ProcessRecord app; if (!isolated) &#123; app = getProcessRecordLocked(info.processName, info.uid, true); &#125; else &#123; app = null; &#125; if (app == null) &#123; app = newProcessRecordLocked(info, null, isolated, 0); updateLruProcessLocked(app, false, null); updateOomAdjLocked(); &#125; ........... // This package really, really can not be stopped. try &#123; //通过PKMS将package对应数据结构的StoppedState置为fasle AppGlobals.getPackageManager().setPackageStoppedState( info.packageName, false, UserHandle.getUserId(app.uid)); &#125; catch (RemoteException e) &#123; &#125; catch (IllegalArgumentException e) &#123; Slog.w(TAG, \"Failed trying to unstop package \" + info.packageName + \": \" + e); &#125; if ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123; app.persistent = true; app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ; &#125; if (app.thread == null &amp;&amp; mPersistentStartingProcesses.indexOf(app) &lt; 0) &#123; mPersistentStartingProcesses.add(app); //启动应用所在进程，将发送消息给zygote，后者fork出进程 startProcessLocked(app, \"added application\", app.processName, abiOverride, null /* entryPoint */, null /* entryPointArgs */); &#125; return app;&#125; 这里最终将通过startProcessLocked函数，启动实际的应用进程。正如之前分析zygote进程时，提过的一样，zygote中的server socket将接收消息，然后为应用fork出进程。 总结对于整个AMS启动过程而言，博客中涉及的内容可能只是极小的一部分。但即使我们尽可能的简化，整个过程的内容还是非常多。 不过我们回头看看整个过程，还是能比较清晰地将AMS的启动过程分为四步，如上图所示：1、创建出SystemServer进程的Android运行环境。在这一部分，SystemServer进程主要创建出对应的ActivityThread和ContextImpl，构成Android运行环境。AMS的后续工作依赖于SystemServer在此创建出的运行环境。 2、完成AMS的初始化和启动。在这一部分，单纯地调用AMS的构造函数和start函数，完成AMS的一些初始化工作。 3、将SystemServer进程纳入到AMS的管理体系中。AMS作为Java世界的进程管理和调度中心，要对所有Java进程一视同仁，因此SystemServer进程也必须被AMS管理。在这个过程中，AMS加载了SystemServer中framework-res.apk的信息，并启动和注册了SettingsProvider.apk。 4、开始执行AMS启动完毕后才能进行的工作。系统中的一些服务和进程，必须等待AMS完成启动后，才能展开后续工作。在这一部分，AMS通过调用systemReady函数，通知系统中的其它服务和进程，可以进行对应工作了。在这个过程中，值得我们关注的是：Home Activity被启动了。当该Activity被加载完成后，最终会触发ACTION_BOOT_COMPLETED广播。 （6）、启动Launcher(Activity)看看启动Home Activity对应的startHomeActivityLocked函数： 1234567891011121314151617181920212223boolean startHomeActivityLocked(int userId, String reason) &#123; .............. Intent intent = getHomeIntent(); //根据intent中携带的ComponentName，利用PKMS得到ActivityInfo ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) &#123; intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name)); aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); //此时home对应进程应该还没启动，app为null ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) &#123; intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); //启动home mActivityStarter.startHomeActivityLocked(intent, aInfo, reason); &#125; &#125; else &#123; .......... &#125; return true;&#125; 这里暂时先不深究Home Activity启动的具体过程。从手头的资料来看，当Home Activity启动后，ActivityStackSupervisor中的activityIdleInternalLocked函数将被调用： 12345678final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) &#123; ........... if (isFocusedStack(r.task.stack) || fromTimeout) &#123; booting = checkFinishBootingLocked(); &#125; ............&#125; 在checkFinishBootingLocked函数中： 123456789101112131415private boolean checkFinishBootingLocked() &#123; //mService为AMS，mBooting变量在AMS回调SystemServer中定义的Runnable时，置为了true final boolean booting = mService.mBooting; boolean enableScreen = false; mService.mBooting = false; if (!mService.mBooted) &#123; mService.mBooted = true; enableScreen = true; &#125; if (booting || enableScreen) &#123;、 //调用AMS的接口，发送消息 mService.postFinishBooting(booting, enableScreen); &#125; return booting;&#125; 最终，AMS的finishBooting函数将被调用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061final void finishBooting() &#123; ......... //以下是注册广播接收器，用于处理需要重启的package IntentFilter pkgFilter = new IntentFilter(); pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART); pkgFilter.addDataScheme(\"package\"); mContext.registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; String[] pkgs = intent.getStringArrayExtra(Intent.EXTRA_PACKAGES); if (pkgs != null) &#123; for (String pkg : pkgs) &#123; synchronized (ActivityManagerService.this) &#123; if (forceStopPackageLocked(pkg, -1, false, false, false, false, false, 0, \"query restart\")) &#123; setResultCode(Activity.RESULT_OK); return; &#125; &#125; &#125; &#125; &#125; &#125;, pkgFilter); ........... // Let system services know. mSystemServiceManager.startBootPhase(SystemService.PHASE_BOOT_COMPLETED); //以下是启动那些等待启动的进程 synchronized (this) &#123; // Ensure that any processes we had put on hold are now started // up. final int NP = mProcessesOnHold.size(); if (NP &gt; 0) &#123; ArrayList&lt;ProcessRecord&gt; procs = new ArrayList&lt;ProcessRecord&gt;(mProcessesOnHold); for (int ip=0; ip&lt;NP; ip++) &#123; ................. startProcessLocked(procs.get(ip), \"on-hold\", null); &#125; &#125; &#125; &#125; .............. if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; // Start looking for apps that are abusing wake locks. //每15min检查一次系统各应用进程使用电量的情况，如果某个进程使用WakeLock的时间过长 //AMS将关闭该进程 Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG); mHandler.sendMessageDelayed(nmsg, POWER_CHECK_DELAY); // Tell anyone interested that we are done booting! SystemProperties.set(\"sys.boot_completed\", \"1\"); ................. //此处从代码来看发送的是ACTION_LOCKED_BOOT_COMPLETED广播 //在进行unlock相关的工作后，mUserController将调用finishUserUnlocking，发送SYSTEM_USER_UNLOCK_MSG消息给AMS //AMS收到消息后，调用mUserController的finishUserUnlocked函数，经过相应的处理后， //在mUserController的finishUserUnlockedCompleted中，最终将会发送ACTION_BOOT_COMPLETED广播 mUserController.sendBootCompletedLocked(.........); ................. &#125;&#125; 最终，当AMS启动Home Activity结束，并发送ACTION_BOOT_COMPLETED广播时，AMS的启动过程告一段落。 具体启动流程请参考：【Android 7.1.2 (Android N) Activity启动流程分析】 ###参考文档：Android 7.0 ActivityManagerService 1 - 10 Android Init进程源码分析(1) - jay_richardAndroid Init进程源码分析(2) - jay_richardAndroid Zygote进程分析 - jay_richardAndroid Init进程源码分析 - 深入剖析Android系统 - CSDN博客图解Android - Zygote, System Server 启动分析 - 漫天尘沙 - 博客园Android7.0 init进程源码分析 - ZhangJian的博客 - CSDN博客Android系统启动-Init篇 - Gityuan博客 | 袁辉辉博客Android系统启动-zygote篇 - Gityuan博客 | 袁辉辉博客Android系统启动-SystemServer上篇 - Gityuan博客 | 袁辉辉博客Android系统启动-SystemServer下篇 - Gityuan博客 | 袁辉辉博客ActivityManagerService启动过程 - Gityuan博客 | 袁辉辉博客","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Android消息处理机制分析（从JAVA层到NATIVE层）– Handler、Looper、Message","slug":"Android-7-1-2-Android-N-Android消息机制–Handler、Looper、Message","date":"2017-07-31T16:00:00.000Z","updated":"2018-03-23T07:18:22.000Z","comments":true,"path":"2017/08/01/Android-7-1-2-Android-N-Android消息机制–Handler、Looper、Message/","link":"","permalink":"http://zhoujinjian.cc/2017/08/01/Android-7-1-2-Android-N-Android消息机制–Handler、Looper、Message/","excerpt":"Android消息处理机制概述：Android应用程序是通过消息来驱动的，系统为每一个应用程序维护一个消息队例，应用程序的主线程不断地从这个消息队例中获取消息（Looper），然后对这些消息进行处理（Handler），这样就实现了通过消息来驱动应用程序的执行，本文将详细分析Android应用程序的消息处理机制。","text":"Android消息处理机制概述：Android应用程序是通过消息来驱动的，系统为每一个应用程序维护一个消息队例，应用程序的主线程不断地从这个消息队例中获取消息（Looper），然后对这些消息进行处理（Handler），这样就实现了通过消息来驱动应用程序的执行，本文将详细分析Android应用程序的消息处理机制。 ● framework/base/core/java/andorid/os/Handler.java ● framework/base/core/java/andorid/os/Looper.java ● framework/base/core/java/andorid/os/Message.java ● framework/base/core/java/andorid/os/MessageQueue.java ● framework/base/core/java/andorid/os/MessageQueue.java ● framework/base/core/jni/android_os_MessageQueue.cpp ● framework/base/core/java/andorid/os/Looper.java (Java层） ● system/core/libutils/Looper.cpp ( Native层) ● framework/base/native/android/looper.cpp (ALoop对象) ● framework/native/include/android/looper.h 博客原图链接Ⅰ、Android消息机制(Java层)一、Android消息机制相关类、概念（Java层）主线程（UI线程）定义：当程序第一次启动时，Android会同时启动一条主线程（Main Thread）作用：主线程主要负责处理与UI相关的事件 Message（消息）定义：Handler接收和处理的消息对象（Bean对象）作用：通信时相关信息的存放和传递 ThreadLocal定义：线程内部的数据存储类作用：负责存储和获取本线程的Looper MessageQueue（消息队列）定义：采用单链表的数据结构来存储消息列表作用：用来存放通过Handler发过来的Message，按照先进先出执行 Handler（处理者）定义：Message的主要处理者作用：负责发送Message到消息队列&amp;处理Looper分派过来的Message Looper（循环器）定义：扮演Message Queue和Handler之间桥梁的角色作用：消息循环：循环取出Message Queue的Message消息派发：将取出的Message交付给相应的Handler 二、类关系图（Java层） ● Looper有一个MessageQueue消息队列；● MessageQueue有一组待处理的Message；●Message中有一个用于处理消息的Handler；● Handler中有Looper和MessageQueue。 典型实例:先展示一个典型的关于Handler/Looper的线程 123456789101112131415class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; //TODO 定义消息处理逻辑. &#125; &#125;; Looper.loop(); &#125;&#125; 接下来，围绕着这个实例展开详细分析。 三、Looper源码分析（Java层）对于无参的情况，默认调用prepare(true)，表示的是这个Looper运行退出，而对于false的情况则表示当前Looper不运行退出。 12345678private static void prepare(boolean quitAllowed) &#123; //每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常。 if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; //创建Looper对象，并保存到当前线程的TLS区域 sThreadLocal.set(new Looper(quitAllowed));&#125; 3.1 知识：ThreadLocal介绍这里的sThreadLocal是ThreadLocal类型，下面，先说说ThreadLocal。 ThreadLocal： 线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。TLS常用的操作方法： 123456789101112ThreadLocal.set(T value)：将value存储到当前线程的TLS区域，源码如下： public void set(T value) &#123; Thread currentThread = Thread.currentThread(); //获取当前线程 Values values = values(currentThread); //查找当前线程的本地储存区 if (values == null) &#123; //当线程本地存储区，尚未存储该线程相关信息时，则创建Values对象 values = initializeValues(currentThread); &#125; //保存数据value到当前线程this values.put(this, value); &#125; ThreadLocal.get()：获取当前线程TLS区域的数据，源码如下： 123456789101112131415public T get() &#123; Thread currentThread = Thread.currentThread(); //获取当前线程 Values values = values(currentThread); //查找当前线程的本地储存区 if (values != null) &#123; Object[] table = values.table; int index = hash &amp; values.mask; if (this.reference == table[index]) &#123; return (T) table[index + 1]; //返回当前线程储存区中的数据 &#125; &#125; else &#123; //创建Values对象 values = initializeValues(currentThread); &#125; return (T) values.getAfterMiss(this); //从目标线程存储区没有查询是则返回null&#125; ThreadLocal的get()和set()方法操作的类型都是泛型，接着回到前面提到的sThreadLocal变量，其定义如下： 1static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;() 可见sThreadLocal的get()和set()操作的类型都是Looper类型。 (1) Looper.prepare()Looper.prepare()在每个线程只允许执行一次，该方法会创建Looper对象，Looper的构造方法中会创建一个MessageQueue对象，再将Looper对象保存到当前线程TLS。 对于Looper类型的构造方法如下： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); //创建MessageQueue对象. mThread = Thread.currentThread(); //记录当前线程.&#125; 另外，与prepare()相近功能的，还有一个prepareMainLooper()方法，该方法主要在ActivityThread类中使用。 12345678910public static void prepareMainLooper() &#123; prepare(false); //设置不允许退出的Looper synchronized (Looper.class) &#123; //将当前的Looper保存为主Looper，每个线程只允许执行一次。 if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125;&#125; Looper.prepare()在每个线程只允许执行一次，该方法会创建Looper对象，Looper的构造方法中会创建一个MessageQueue对象，再将Looper对象保存到当前线程TLS。 对于Looper类型的构造方法如下： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); //创建MessageQueue对象.稍后详细介绍 mThread = Thread.currentThread(); //记录当前线程.&#125; 另外，与prepare()相近功能的，还有一个prepareMainLooper()方法，该方法主要在主线程（UI线程）ActivityThread类中使用。 12345678910public static void prepareMainLooper() &#123; prepare(false); //设置不允许退出的Looper synchronized (Looper.class) &#123; //将当前的Looper保存为主Looper，每个线程只允许执行一次。 if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125;&#125; （2）创建MessageQueue()MessageQueue是消息机制的Java层和C++层的连接纽带，大部分核心方法都交给native层来处理，其中MessageQueue类中涉及的native方法如下： 123private native static long nativeInit();private native void nativePollOnce(long ptr, int timeoutMillis);private native static void nativeWake(long ptr); 关于这些native方法的介绍，见第二节：Android消息机制(native篇)。 12345MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; //通过native方法初始化消息队列，其中mPtr是供native代码使用 mPtr = nativeInit();&#125; MessageQueue创建过程总结： 1、Looper的prepare或者prepareMainLooper静态方法被调用，将一个Looper对象保存在ThreadLocal里面。2、Looper对象的初始化方法里，首先会新建一个MessageQueue对象。3、MessageQueue对象的初始化方法通过JNI初始化C++层的NativeMessageQueue对象。4、NativeMessageQueue对象在创建过程中，会初始化一个C++层的Looper对象。5、C++层的Looper对象在创建的过程中，会在内部创建一个管道（pipe），并将这个管道的读写fd都保存在 mWakeReadPipeFd和mWakeWritePipeFd中。然后新建一个epoll实例，并将两个fd注册进去。6、利用epoll的机制，可以做到当管道没有消息时，线程睡眠在读端的fd上，当其他线程往管道写数据时，本线程便会被唤醒以进行消息处理。 (3) Looper.loop()12345678910111213141516171819202122232425262728293031323334public static void loop() &#123; final Looper me = myLooper(); //获取TLS存储的Looper对象 if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; //获取Looper对象中的消息队列 Binder.clearCallingIdentity(); //确保在权限检查时基于本地进程，而不是基于最初调用进程。 final long ident = Binder.clearCallingIdentity(); for (;;) &#123; //进入loop的主循环方法 Message msg = queue.next(); //可能会阻塞 May be block if (msg == null) &#123; //没有消息，则退出循环 return; &#125; Printer logging = me.mLogging; //默认为null，可通过setMessageLogging()方法来指定输出，用于debug功能 if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; msg.target.dispatchMessage(msg); //用于分发Message if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; final long newIdent = Binder.clearCallingIdentity(); //确保分发过程中identity不会损坏 if (ident != newIdent) &#123; //打印identity改变的log，在分发消息过程中是不希望身份被改变的。 &#125; msg.recycleUnchecked(); //将Message放入消息池 &#125;&#125; loop()进入循环模式，不断重复下面的操作，直到没有消息时退出循环 读取MessageQueue的下一条Message；把Message分发给相应的target；A1：Looper.loop()循环中的msg.target是什么时候被赋值的？handler.sendMessage()最终会进入MessageQueue.enqueueMessage()，就是在这里面复制的。稍后再handler.sendMessage()详细介绍。再把分发后的Message回收到消息池，以便重复利用。Looper.loop()是消息处理的核心部分。 3.1 MessageQueue.next()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; //当消息循环已经退出，则直接返回 return null; &#125; int pendingIdleHandlerCount = -1; // 循环迭代的首次为-1 int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; //阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; //当消息Handler为空时，查询MessageQueue中的下一条异步消息msg，则退出循环。 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; //当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 获取一条消息，并返回 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; //设置消息的使用状态，即flags |= FLAG_IN_USE msg.markInUse(); return msg; //成功地获取MessageQueue中的下一条即将要执行的消息 &#125; &#125; else &#123; //没有消息 nextPollTimeoutMillis = -1; &#125; //消息正在退出，返回null if (mQuitting) &#123; dispose(); return null; &#125; //当消息队列为空，或者是消息队列的第一个消息时 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; //没有idle handlers 需要运行，则循环并等待。 mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; //只有第一次循环时，会运行idle handlers，执行完成后，重置pendingIdleHandlerCount为0. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; //去掉handler的引用 boolean keep = false; try &#123; keep = idler.queueIdle(); //idle时执行的方法 &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; //重置idle handler个数为0，以保证不会再次重复运行 pendingIdleHandlerCount = 0; //当调用一个空闲handler时，一个新message能够被分发，因此无需等待可以直接查询pending message. nextPollTimeoutMillis = 0; &#125;&#125; nativePollOnce()在native做了大量的工作，Android消息机制(native篇)稍后详细分析。 消息循环Looper.loop()总结： 首先通过调用Looper的loop方法开始消息监听。loop方法里会调用MessageQueue的next方法。next方法会堵塞线程直到有消息到来为止。 next方法通过调用nativePollOnce方法来监听事件。next方法内部逻辑如下所示(简化)： a.进入死循环，以参数timout=0调用nativePollOnce方法。 b.如果消息队列中有消息，nativePollOnce方法会将消息保存在mMessage成员中。nativePollOnce方法返回后立刻检查mMessage成员是否为空。 c.如果mMessage不为空，那么检查它指定的运行时间。如果比当前时间要前，那么马上返回这个mMessage，否则设置&gt; timeout为两者之差，进入下一次循环。 d. 如果mMessage为空，那么设置timeout为-1，即下次循环nativePollOnce永久堵塞。 nativePollOnce方法内部利用epoll机制在之前建立的管道上等待数据写入。接收到数据后马上读取并返回结果。 这里先提一下为什么会阻塞，稍后再Android消息处理(Native层)分析，主要是底层使用了Linux epoll：Linux IO模式及 select、poll、epoll详解 3.2 Looper.quit()1234567public void quit() &#123; mQueue.quit(false); //消息移除&#125;public void quitSafely() &#123; mQueue.quit(true); //安全地消息移除&#125; Looper.quit()方法的实现最终调用的是MessageQueue.quit()方法 123456789101112131415161718192021MessageQueue.quit()void quit(boolean safe) &#123; // 当mQuitAllowed为false，表示不运行退出，强行调用quit()会抛出异常 if (!mQuitAllowed) &#123; throw new IllegalStateException(\"Main thread not allowed to quit.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; //防止多次执行退出操作 return; &#125; mQuitting = true; if (safe) &#123; removeAllFutureMessagesLocked(); //移除尚未触发的所有消息 &#125; else &#123; removeAllMessagesLocked(); //移除所有的消息 &#125; //mQuitting=false，那么认定为 mPtr != 0 nativeWake(mPtr); &#125; &#125; 消息退出的方式： 当safe =true时，只移除尚未触发的所有消息，对于正在触发的消息并不移除；当safe =flase时，移除所有的消息 前面构造了Looper 、MessageQueue，假设此时没有message处理，Looper.loop()会阻塞在MessageQueue.next()。接下来讲一下Handler如何发送和处理消息。 四、异步处理大师 Handler()(1) 构造Handler()1.1 无参构造Handler()12345678910111213141516171819202122public Handler() &#123; this(null, false);&#125;public Handler(Callback callback, boolean async) &#123; //匿名类、内部类或本地类都必须申明为static，否则会警告可能出现内存泄露 if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; //必须先执行Looper.prepare()，才能获取Looper对象，否则为null. mLooper = Looper.myLooper(); //从当前线程的TLS中获取Looper对象 if (mLooper == null) &#123; throw new RuntimeException(\"\"); &#125; mQueue = mLooper.mQueue; //消息队列，来自Looper对象 mCallback = callback; //回调方法 mAsynchronous = async; //设置消息是否为异步处理方式&#125; 对于Handler的无参构造方法，默认采用当前线程TLS中的Looper对象，并且callback回调方法为null，且消息为同步处理方式。只要执行的Looper.prepare()方法，那么便可以获取有效的Looper对象。 1.2 有参构造Handler()12345678910public Handler(Looper looper) &#123; this(looper, null, false);&#125;public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; Handler类在构造方法中，可指定Looper，Callback回调方法以及消息的处理方式(同步或异步)，对于无参的handler，默认是当前线程的Looper。 (2) 使用 Handler发送消息Handler.sendMessage()、Handler.post(Ruunable r)第一种方式：sendMessage(Message msg) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//从这里开始public final boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what, 0);&#125;//往下追踪public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125;//往下追踪public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;//往下追踪public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; //直接获取MessageQueue MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;//调用sendMessage方法其实最后是调用了enqueueMessage方法private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; //为msg.target赋值为this，也就是把当前的handler作为msg的target属性 //如果大家还记得Looper的loop()方法会取出每个msg然后执行msg.target.dispatchMessage(msg)去处理消息，其实就是派发给相应的Handler msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; //最终调用queue的enqueueMessage的方法，也就是说handler发出的消息，最终会保存到消息队列中去 return queue.enqueueMessage(msg, uptimeMillis);&#125; enqueueMessage()方法中将msg.target赋值为this，也就是把当前的handler作为msg的target属性 //如果大家还记得Looper的loop()方法会取出每个msg然后执行msg.target.dispatchMessage(msg)去处理消息，其实就是派发给相应的Handler 2.1 MessageQueue.enqueueMessage() 添加一条消息到消息队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647boolean enqueueMessage(Message msg, long when) &#123; // 每一个普通Message必须有一个target if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; //正在退出时，回收msg，加入到消息池 msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; //p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支 msg.next = p; mMessages = msg; needWake = mBlocked; //当阻塞时需要唤醒 &#125; else &#123; //将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非 //消息队头存在barrier，并且同时Message是队列中最早的异步消息。 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; prev.next = msg; &#125; //消息没有退出，我们认为此时mPtr != 0 if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; MessageQueue是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。 第二种方式：post(Ruunable r) 1234public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125; 其实post()方法最终也会保存到消息队列中去，和上面不同的是它传进来的一个Runnable对象，执行了getPostMessage()方法，我们往下追踪 12345private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125; 实质上就是将这个Runnable保存在Message的变量中，这就导致了我们下面处理消息的时候有两种不同方案 Handler发送消息总结： 1、Handler对象在创建时会保存当前线程的looper和MessageQueue，如果传入Callback的话也会保存起来。2、用户调用handler对象的sendMessage方法，传入msg对象。handler通过调用MessageQueue的enqueueMessage方法将消息压入MessageQueue。3、enqueueMessage方法会将传入的消息对象根据触发时间（when）插入到message queue中。然后判断是否要唤醒等待中的队列。 a. 如果插在队列中间。说明该消息不需要马上处理，不需要由这个消息来唤醒队列。 b. 如果插在队列头部（或者when=0），则表明要马上处理这个消息。如果当前队列正在堵塞，则需要唤醒它进行处理。4、如果需要唤醒队列，则通过nativeWake方法，往前面提到的管道中写入一个”W”字符，令nativePollOnce方法返回。 (4) Handler处理消息在Looper.loop()中，当发现有消息时，调用消息的目标handler，执行dispatchMessage()方法来分发消息。 1234567891011121314151617181920212223public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; //1. post()方法的处理方法 handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; //2. sendMessage()方法的处理方法 handleMessage(msg); &#125;&#125;//1. post()方法的最终处理方法private static void handleCallback(Message message) &#123; message.callback.run();&#125;//2. sendMessage()方法的最终处理方法public void handleMessage(Message msg) &#123;&#125; 处理消息总结： Looper对象的loop方法里面的queue.next方法如果返回了message，那么handler的dispatchMessage会被调用。a. 如果新建Handler的时候传入了callback实例，那么callback的handleMessage方法会被调用。b.如果是通过post方法向handler传入runnable对象的，那么runnable对象的run方法会被调用。c.其他情况下，handler方法的handleMessage会被调用。 (五)总结（1）简洁总结图示： 图解： ● Handler通过sendMessage()发送Message到MessageQueue队列；● Looper通过loop()，不断提取出达到触发条件的Message，并将Message交给target来处理；● 经过dispatchMessage()后，交回给Handler的handleMessage()来进行相应地处理。● 将Message加入MessageQueue时，处往管道写入字符，可以会唤醒loop线程；如果MessageQueue中没有Message，并处于Idle状态，则会执行IdelHandler接口中的方法，往往用于做一些清理性地工作。 消息分发的优先级： 1、Message的回调方法：message.callback.run()，优先级最高；2、Handler的回调方法：Handler.mCallback.handleMessage(msg)，优先级仅次于1；3、Handler的默认方法：Handler.handleMessage(msg)，优先级最低。 详细总结图示： ● Looper调用prepare()进行初始化，创建了一个与当前线程对应的Looper对象（通过ThreadLocal实现），并且初始化了一个与当前Looper对应的MessageQueue对象。 ● Looper调用静态方法loop()开始消息循环，通过MessageQueue.next()方法获取Message对象。 ● 当获取到一个Message对象时，让Message的发送者（target）去处理它。 ● Message对象包括数据，发送者（Handler），可执行代码段（Runnable）三个部分组成。 ● Handler可以在一个已经Looper.prepare()的线程中初始化，如果线程没有初始化Looper，创建Handler对象会失败 ● 一个线程的执行流中可以构造多个Handler对象，它们都往同一个MessageQueue中发消息，消息也只会分发给对应的Handler处理。 ● Handler将消息发送到MessageQueue中，Message的target域会引用自己的发送者，Looper从MessageQueue中取出来后，再交给发送这个Message的Handler去处理。 ● Message可以直接添加一个Runnable对象，当这条消息被处理的时候，直接执行Runnable.run()方法。 Ⅱ、Android消息机制(Native层)在前面讲解了Java层的消息处理机制，其中MessageQueue类里面涉及到多个native方法，除了MessageQueue的native方法，native层本身也有一套完整的消息机制，用于处理native的消息。在整个消息机制中，而MessageQueue是连接Java层和Native层的纽带，换言之，Java层可以向MessageQueue消息队列中添加消息，Native层也可以向MessageQueue消息队列中添加消息。 Native层类的关系图： (一) MessageQueue 初始化（Native 层）接着从Java层MessageQueue初始化开始分析： Step 1：MessageQueue()12345MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; //通过native方法初始化消息队列，其中mPtr是供native代码使用 mPtr = nativeInit();&#125; Step 2：android_os_MessageQueue_nativeInit()12345678910==&gt; android_os_MessageQueue.cppstatic jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); //初始化native消息队列 【3】 if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return 0; &#125; nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);&#125; 在nativeInit中，new了一个Native层的MessageQueue的对象 Step 3：NativeMessageQueue()123456789==&gt; android_os_MessageQueue.cppNativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123; mLooper = Looper::getForThread(); //获取TLS中的Looper对象 if (mLooper == NULL) &#123; mLooper = new Looper(false); //创建native层的Looper Looper::setForThread(mLooper); //保存native层的Looper到TLS中 &#125;&#125; 在NativeMessageQueue的构造函数中获得了一个Native层的Looper对象，Native层的Looper也使用了线程本地存储，注意new Looper时传入了参数false。 Looper::getForThread()，功能类比于Java层的Looper.myLooper();Looper::setForThread(mLooper)，功能类比于Java层的ThreadLocal.set(); MessageQueue是在Java层与Native层有着紧密的联系，但是此次Native层的Looper与Java层的Looper没有任何的关系，可以发现native基本等价于用C++重写了Java的Looper逻辑，故可以发现很多功能类似的地方。 (二) Looper初始化（Native层）1234567891011121314151617181920212223242526272829303132Looper::Looper(bool allowNonCallbacks) : mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false), mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false), mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123; mWakeEventFd = eventfd(0, EFD_NONBLOCK); //构造唤醒事件的fd AutoMutex _l(mLock); rebuildEpollLocked(); //重建Epoll事件&#125;void Looper::rebuildEpollLocked() &#123; if (mEpollFd &gt;= 0) &#123; close(mEpollFd); //关闭旧的epoll实例 &#125; mEpollFd = epoll_create(EPOLL_SIZE_HINT); //创建新的epoll实例，并注册wake管道 struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); //把未使用的数据区域进行置0操作 eventItem.events = EPOLLIN; //可读事件 eventItem.data.fd = mWakeEventFd; //将唤醒事件(mWakeEventFd)添加到epoll实例(mEpollFd) int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem); for (size_t i = 0; i &lt; mRequests.size(); i++) &#123; const Request&amp; request = mRequests.valueAt(i); struct epoll_event eventItem; request.initEventItem(&amp;eventItem); //将request队列的事件，分别添加到epoll实例 int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem); if (epollResult &lt; 0) &#123; ALOGE(\"Error adding epoll events for fd %d while rebuilding epoll set, errno=%d\", request.fd, errno); &#125; &#125;&#125; 通过eventfd创建mWakeEventFd用于线程间通信去唤醒Looper的，当需要唤醒Looper时，就往里面写1创建用于监听epoll_event的mEpollFd，并初始化mEpollFd要监听的epoll_event类型通过epoll_ctl将mWakeEventFd注册到mEpollFd中，当mWakeEventFd有事件可读则唤醒Looper如果mRequests不为空的话，说明前面注册了有要监听的fd，则遍历mRequests中的Request，将它初始化为epoll_event并通过epoll_ctl注册到mEpollFd中，当有可读事件同样唤醒Looper (三) nativePollOnce()我们从前面分析知道，Looper.loop()方法被调用后，会启动一个无限循环，而在这个循环中，调用了MessageQueue的next()方法以获取下一条消息，而next()方法中会首先调用nativePollOnce()方法，这个方法的作用在之前说过是阻塞，达到超时时间或有新的消息到达时得到eventFd的通知再唤醒消息队列，其实这个方法也是native消息处理的开始。 nativePollOnce用于提取消息队列中的消息，提取消息的调用链，如下： 下面来进一步来看看调用链的过程： Step 1：MessageQueue.next()12345678910111213==&gt; MessageQueue.javaMessage next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; for (;;) &#123; ... nativePollOnce(ptr, nextPollTimeoutMillis); //阻塞操作 ... &#125; Step 2：android_os_MessageQueue_nativePollOnce()1234567==&gt; android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; //将Java层传递下来的mPtr转换为nativeMessageQueue NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125; Step 3：NativeMessageQueue::pollOnce()1234567891011121314==&gt; android_os_MessageQueue.cppvoid NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123; mPollEnv = env; mPollObj = pollObj; mLooper-&gt;pollOnce(timeoutMillis); mPollObj = NULL; mPollEnv = NULL; if (mExceptionObj) &#123; env-&gt;Throw(mExceptionObj); env-&gt;DeleteLocalRef(mExceptionObj); mExceptionObj = NULL; &#125;&#125; Step 4：Looper::pollOnce()1234567891011121314151617181920212223242526272829==&gt; Looper.cppint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123; int result = 0; for (;;) &#123; // 先处理没有Callback方法的 Response事件 while (mResponseIndex &lt; mResponses.size()) &#123; const Response&amp; response = mResponses.itemAt(mResponseIndex++); int ident = response.request.ident; if (ident &gt;= 0) &#123; //ident大于0，则表示没有callback, 因为POLL_CALLBACK = -2, int fd = response.request.fd; int events = response.events; void* data = response.request.data; if (outFd != NULL) *outFd = fd; if (outEvents != NULL) *outEvents = events; if (outData != NULL) *outData = data; return ident; &#125; &#125; if (result != 0) &#123; if (outFd != NULL) *outFd = 0; if (outEvents != NULL) *outEvents = 0; if (outData != NULL) *outData = NULL; return result; &#125; // 再处理内部轮询 result = pollInner(timeoutMillis); &#125;&#125; Step 5 ：Looper::pollInner()：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102==&gt; Looper.cppvoid Looper::awoken() &#123; uint64_t counter; //不断读取管道数据，目的就是为了清空管道内容 TEMP_FAILURE_RETRY(read(mWakeEventFd, &amp;counter, sizeof(uint64_t)));&#125;int Looper::pollInner(int timeoutMillis) &#123; ... int result = POLL_WAKE; mResponses.clear(); mResponseIndex = 0; mPolling = true; //即将处于idle状态 struct epoll_event eventItems[EPOLL_MAX_EVENTS]; //fd最大个数为16 //等待事件发生或者超时，在nativeWake()方法，向管道写端写入字符，则该方法会返回； int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); mPolling = false; //不再处于idle状态 mLock.lock(); //请求锁 if (mEpollRebuildRequired) &#123; mEpollRebuildRequired = false; rebuildEpollLocked(); // epoll重建，直接跳转Done; goto Done; &#125; if (eventCount &lt; 0) &#123; if (errno == EINTR) &#123; goto Done; &#125; result = POLL_ERROR; // epoll事件个数小于0，发生错误，直接跳转Done; goto Done; &#125; if (eventCount == 0) &#123; //epoll事件个数等于0，发生超时，直接跳转Done; result = POLL_TIMEOUT; goto Done; &#125; //循环遍历，处理所有的事件 for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; awoken(); //已经唤醒了，则读取并清空管道数据 &#125; &#125; else &#123; ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) &#123; int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; //处理request，生成对应的reponse对象，push到响应数组 pushResponse(events, mRequests.valueAt(requestIndex)); &#125; &#125; &#125;Done: ; //再处理Native的Message，调用相应回调方法 mNextMessageUptime = LLONG_MAX; while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); if (messageEnvelope.uptime &lt;= now) &#123; &#123; sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock(); //释放锁 handler-&gt;handleMessage(message); // 处理消息事件 &#125; mLock.lock(); //请求锁 mSendingMessage = false; result = POLL_CALLBACK; // 发生回调 &#125; else &#123; mNextMessageUptime = messageEnvelope.uptime; break; &#125; &#125; mLock.unlock(); //释放锁 //处理带有Callback()方法的Response事件，执行Reponse相应的回调方法 for (size_t i = 0; i &lt; mResponses.size(); i++) &#123; Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; // 处理请求的回调方法 int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) &#123; removeFd(fd, response.request.seq); //移除fd &#125; response.request.callback.clear(); //清除reponse引用的回调方法 result = POLL_CALLBACK; // 发生回调 &#125; &#125; return result;&#125; pollInner()方法比较长也是native消息机制的核心，我们拆成几个部分看。 5.1 Request 与 Response12345678910111213141516171819202122232425262728293031323334int result = POLL_WAKE;mResponses.clear();mResponseIndex = 0;mPolling = true;struct epoll_event eventItems[EPOLL_MAX_EVENTS];int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);// 第7行mPolling = false;mLock.lock();...for (int i = 0; i &lt; eventCount; i++) &#123;//第11行 int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; awoken(); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on wake event fd.\", epollEvents); &#125; &#125; else &#123; ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) &#123; int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; pushResponse(events, mRequests.valueAt(requestIndex));// 第28行 &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on fd %d that is \" \"no longer registered.\", epollEvents, fd); &#125; &#125;&#125; 当第7行系统调用epoll_wait()返回时，说明因注册的fd有消息或达到超时，在第11行就对收到的唤醒events进行遍历，首先判断有消息的fd是不是用于唤醒的mWakeEventFd，如果不是的话，说明是系统调用addFd()方法设置的自定义fd（后面会讲）。那么我们需要对这个事件作出响应。 第21到28行就对这个event做处理，首先，我们以这个fd为key从mRequests中找到他的索引，这个mRequests是我们在addFd()方法一并注册的以fd为key，Request为value的映射表。找到request之后，28行调用pushResponse()方法去建立response： 123456void Looper::pushResponse(int events, const Request&amp; request) &#123; Response response; response.events = events; response.request = request; mResponses.push(response);&#125; 现在我们要处理的任务已经被封装成了一个Response对象，等待被处理，那么真正的处理在哪里呢？ 在上面的代码与处理response的代码中间夹着的是处理MessageEnvelope的代码，我们后面再讲这段，现在到处理response的代码： 1234567891011121314 for (size_t i = 0; i &lt; mResponses.size(); i++) &#123; Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) &#123; removeFd(fd, response.request.seq); &#125; response.request.callback.clear(); result = POLL_CALLBACK; &#125;&#125; 遍历所有response对象，取出之前注册的request对象的信息，然后调用了request.callback-&gt;handleEvent()方法进行回调，如果该回调返回0，则调用removeFd()方法取消这个fd的注册。 再梳理一遍这个过程：注册的自定义fd被消息唤醒，从mRequests中以fd为key找到对应的注册好的request对象然后生成response对象，在MessageEnvelop处理完毕之后处理response，调用request中的callback的handleEvent()方法。 那么addFd()注册自定义fd与removeFd()取消注册是如何实现的呢？ 5.2 addFd()12345678910111213141516171819202122232425262728293031323334353637383940414243444546int Looper::addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data) &#123;...&#123; // acquire lock AutoMutex _l(mLock); Request request;//第6-13行 request.fd = fd; request.ident = ident; request.events = events; request.seq = mNextRequestSeq++; request.callback = callback; request.data = data; // 第6-13行 end if (mNextRequestSeq == -1) mNextRequestSeq = 0; // reserve sequence number -1 struct epoll_event eventItem; request.initEventItem(&amp;eventItem); ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &lt; 0) &#123; // 第19行 int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem); //第20行 if (epollResult &lt; 0) &#123; ALOGE(\"Error adding epoll events for fd %d: %s\", fd, strerror(errno)); return -1; &#125; mRequests.add(fd, request); //第25行 &#125; else &#123; int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem); // 第27行 if (epollResult &lt; 0) &#123; if (errno == ENOENT) &#123; epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem); if (epollResult &lt; 0) &#123; ALOGE(\"Error modifying or adding epoll events for fd %d: %s\", fd, strerror(errno)); return -1; &#125; scheduleEpollRebuildLocked(); &#125; else &#123; ALOGE(\"Error modifying epoll events for fd %d: %s\", fd, strerror(errno)); return -1; &#125; &#125; mRequests.replaceValueAt(requestIndex, request); &#125;&#125; // release lockreturn 1;&#125; 第6-13行使用传入的参数初始化了request对象，然后16行由request来初始化注册epoll使用的event。19行根据mRequests.indexOfKey()方法取出的值来判断fd是否已经注册，如果未注册，则在20行进行系统调用epoll_ctl()注册新监听并在25行将fd与request存入mRequest，如果已注册，则在27行更新注册并在42行更新request。 这就是自定义fd设置的过程：保存request并使用epoll_ctl系统调用注册fd的监听。 5.3 removeFd()12345678910111213141516171819202122232425int Looper::removeFd(int fd, int seq) &#123; &#123; // acquire lock AutoMutex _l(mLock); ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &lt; 0) &#123; return 0; &#125; if (seq != -1 &amp;&amp; mRequests.valueAt(requestIndex).seq != seq) &#123; return 0; &#125; mRequests.removeItemsAt(requestIndex); int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_DEL, fd, NULL); if (epollResult &lt; 0) &#123; if (seq != -1 &amp;&amp; (errno == EBADF || errno == ENOENT)) &#123; scheduleEpollRebuildLocked(); &#125; else &#123; ALOGE(\"Error removing epoll events for fd %d: %s\", fd, strerror(errno)); scheduleEpollRebuildLocked(); return -1; &#125; &#125; &#125; // release lock return 1;&#125; 解除的过程相反，在第11行删除mRequests中的键值对，然后在第13行系统调用epoll_ctl()解除fd的epoll注册。 MessageEnvelope消息处理之前说到，在request生成response到response的处理中间有一段代码执行了MessageEnvelop消息的处理，这个顺序保证了MessageEnvelop优先于fd引起的request的处理。 现在我们来看这段代码： 12345678910111213141516171819202122mNextMessageUptime = LLONG_MAX;while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); // 第4行 if (messageEnvelope.uptime &lt;= now) &#123; &#123; // obtain handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock(); handler-&gt;handleMessage(message); &#125; // release handler mLock.lock(); mSendingMessage = false; result = POLL_CALLBACK; &#125; else &#123; mNextMessageUptime = messageEnvelope.uptime; break; &#125;&#125; 可以看到mMessageEnvelopes容器中存储了所有的消息，第4行从首位置取出一条消息，随后进行时间判断，如果时间到达，先移出容器，与java层比较相似都是调用了handler的handleMessage()来进行消息的处理。 那么MessageEnvelope是如何添加的呢？ Native Looper提供了一套与java层MessageQueue类似的方法，用于添加MessageEnvelope： 12345678910111213141516171819202122void Looper::sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) &#123; size_t i = 0; &#123; // acquire lock AutoMutex _l(mLock); size_t messageCount = mMessageEnvelopes.size(); while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123; i += 1; &#125; MessageEnvelope messageEnvelope(uptime, handler, message); mMessageEnvelopes.insertAt(messageEnvelope, i, 1); if (mSendingMessage) &#123; return; &#125; &#125; // release lock if (i == 0) &#123; wake(); &#125;&#125; 小结:现在我们看到，其实Native中的消息机制有两个方面，一方面是通过addFd()注册的自定义fd触发消息处理，通过mRequests保存的request对象中的callback进行消息处理。另一方面是通过与java层类似的MessageEnvelop消息对象进行处理，调用的是该对象handler域的handleMessage()方法，与java层非常类似。优先级是先处理MessageEnvelop再处理request。 一些思考现在消息机制全部内容分析下来，我们可以看到android的消息机制不算复杂，分为native与java两个部分，这两个部分分别有自己的消息处理机制，其中关键的超时与唤醒部分是借助了linux系统epoll机制来实现的。 连接java与native层消息处理过程的是next()方法中的nativePollOnce()，java层消息循环先调用它，自身阻塞，进入native的消息处理，在native消息处理完毕后返回，再进行java层的消息处理，正是因为如此，如果我们在处理java层消息的时候执行了耗时或阻塞的任务（甚至阻塞了整个主线程），整个java层的消息循环就会阻塞，也无法进一步进入native层的消息处理，也就无法响应例如触摸事件这样的消息，导致ANR的发生。这也就是我们不应在主线程中执行这类任务的原因。 (四) 唤醒 nativeWake()在添加消息到消息队列enqueueMessage(), 或者把消息从消息队列中全部移除quit()，再有需要时都会调用 nativeWake方法。包含唤醒过程的添加消息的调用链，nativeWake用于唤醒功能，如下： 下面来进一步来看看调用链的过程： Step 1 ：MessageQueue.enqueueMessage()12345678==&gt; MessageQueue.javaboolean enqueueMessage(Message msg, long when) &#123; ... //将Message按时间顺序插入MessageQueue if (needWake) &#123; nativeWake(mPtr); &#125;&#125; 往消息队列添加Message时，需要根据mBlocked情况来决定是否需要调用nativeWake。 Step 2 ：android_os_MessageQueue_nativeWake()123456==&gt; android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;wake();&#125; Step 3 ：NativeMessageQueue::wake()12345==&gt; android_os_MessageQueue.cppvoid NativeMessageQueue::wake() &#123; mLooper-&gt;wake(); &#125; Step 4 ：Looper::wake()12345678910111213==&gt; Looper.cppvoid Looper::wake() &#123; uint64_t inc = 1; // 向管道mWakeEventFd写入字符1 ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t))); if (nWrite != sizeof(uint64_t)) &#123; if (errno != EAGAIN) &#123; ALOGW(\"Could not write wake signal, errno=%d\", errno); &#125; &#125;&#125;其中TEMP_FAILURE_RETRY 是一个宏定义， 当执行write失败后，会不断重复执行，直到执行成功为止。 (五) 发送消息sendMessage（Native层）在前面Android消息机制(Java层)文中，讲述了Java层如何向MessageQueue类中添加消息，那么接下来讲讲Native层如何向MessageQueue发送消息。 Step 1 ：sendMessage()1234void Looper::sendMessage(const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); sendMessageAtTime(now, handler, message);&#125; Step 2 ：sendMessageDelayed()12345void Looper::sendMessageDelayed(nsecs_t uptimeDelay, const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); sendMessageAtTime(now + uptimeDelay, handler, message);&#125; sendMessage(),sendMessageDelayed() 都是调用sendMessageAtTime()来完成消息插入。 Step 3 ：sendMessageAtTime()12345678910111213141516171819202122void Looper::sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) &#123; size_t i = 0; &#123; //请求锁 AutoMutex _l(mLock); size_t messageCount = mMessageEnvelopes.size(); //找到message应该插入的位置i while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123; i += 1; &#125; MessageEnvelope messageEnvelope(uptime, handler, message); mMessageEnvelopes.insertAt(messageEnvelope, i, 1); //如果当前正在发送消息，那么不再调用wake()，直接返回。 if (mSendingMessage) &#123; return; &#125; &#125; //释放锁 //当把消息加入到消息队列的头部时，需要唤醒poll循环。 if (i == 0) &#123; wake(); &#125;&#125; (六) 处理消息MessageHandler.handleMessage() &amp;&amp; LooperCallback.handleEvent()（Native层）其实Native中的消息机制有两个方面，一方面是通过addFd()注册的自定义fd触发消息处理，通过mRequests保存的request对象中的callback进行消息处理。即调用LooperCallback的handleEvent()处理 另一方面是通过与java层类似的MessageEnvelop消息对象进行处理，调用的是该对象handler域的handleMessage()方法，与java层非常类似。优先级是先处理MessageEnvelop再处理request。即调用MessageHandler类的handleMessage()处理 6.1 MessageHandler类：调用MessageHandler类的handleMessage()处理消息 123456class MessageHandler : public virtual RefBase &#123;protected: virtual ~MessageHandler() &#123; &#125;public: virtual void handleMessage(const Message&amp; message) = 0;&#125;; 6.2 LooperCallback.handleEvent)：用于处理指定的文件描述符的poll事件 12345678LooperCallback类class LooperCallback : public virtual RefBase &#123;protected:virtual ~LooperCallback() &#123; &#125;public://用于处理指定的文件描述符的poll事件virtual int handleEvent(int fd, int events, void* data) = 0;&#125;; (七) Native消息机制使用实例：SurfaceFlinger Native消息处理在 【Android 7.1.2(Android N) Activity-Window加载显示流程】中讲到App请求创建Surface创建过程中，SurfaceFlinger会处理Native消息，此处便是Native消息机制使用的一个具体实例。12345678910111213141516171819202122232425262728293031323334353637383940414243status_t Client::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123; /* * createSurface must be called from the GL thread so that it can * have access to the GL context. */ class MessageCreateLayer : public MessageBase &#123; SurfaceFlinger* flinger; Client* client; sp&lt;IBinder&gt;* handle; sp&lt;IGraphicBufferProducer&gt;* gbp; status_t result; const String8&amp; name; uint32_t w, h; PixelFormat format; uint32_t flags; public: MessageCreateLayer(SurfaceFlinger* flinger, const String8&amp; name, Client* client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) : flinger(flinger), client(client), handle(handle), gbp(gbp), result(NO_ERROR), name(name), w(w), h(h), format(format), flags(flags) &#123; &#125; status_t getResult() const &#123; return result; &#125; virtual bool handler() &#123; result = flinger-&gt;createLayer(name, client, w, h, format, flags, handle, gbp); return true; &#125; &#125;; sp&lt;MessageBase&gt; msg = new MessageCreateLayer(mFlinger.get(), name, this, w, h, format, flags, handle, gbp); mFlinger-&gt;postMessageSync(msg); return static_cast&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult(); &#125; Client将应用程序创建Surface的请求转换为异步消息投递到SurfaceFlinger的消息队列中，将创建Surface的任务转交给SurfaceFlinger。函数首先将请求创建的Surface参数封装为MessageCreateSurface对象，然后调用SurfaceFlinger的postMessageSync函数往SurfaceFlinger的消息队列中发送一个同步消息，当消息处理完后，通过调用消息msg的getResult()函数来得到创建的Surface。 1234567891011121314151617181920212223status_t SurfaceFlinger::postMessageSync(const sp&lt;MessageBase&gt;&amp; msg, nsecs_t reltime, uint32_t flags) &#123; //往消息队列中发送一个消息 status_t res = mEventQueue.postMessage(msg, reltime); //消息发送成功后，当前线程等待消息处理 if (res == NO_ERROR) &#123; msg-&gt;wait(); &#125; return res; &#125; status_t MessageQueue::postMessage( const sp&lt;MessageBase&gt;&amp; messageHandler, nsecs_t relTime) &#123;const Message dummyMessage;//将messageHandler对象和dummyMessage消息对象发送到消息循环Looper对象中if (relTime &gt; 0) &#123; mLooper-&gt;sendMessageDelayed(relTime, messageHandler, dummyMessage);&#125; else &#123; mLooper-&gt;sendMessage(messageHandler, dummyMessage);&#125;return NO_ERROR;&#125; 关于消息循环Looper对象的消息发送函数sendMessage的调用流程请看前面讲解。这里再次贴上关于消息插入代码： 1234567891011121314151617181920212223void Looper::sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) &#123; size_t i = 0; &#123; // acquire lock AutoMutex _l(mLock); //获取消息队列中保存的消息个数 size_t messageCount = mMessageEnvelopes.size(); //按时间排序，查找当前消息应该插入的位置 while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123; i += 1; &#125; //将Message消息及消息处理Handler封装为MessageEnvelope对象，并插入到消息队列mMessageEnvelopes中 MessageEnvelope messageEnvelope(uptime, handler, message); mMessageEnvelopes.insertAt(messageEnvelope, i, 1); if (mSendingMessage) &#123; return; &#125; &#125; // release lock //唤醒消息循环线程以及时处理消息 if (i == 0) &#123; wake(); &#125; &#125; 到此消息发送就完成了，由于发送的是一个同步消息，因此消息发送线程此刻进入睡眠等待状态，而消息循环线程被唤醒起来处理消息，消息处理过程如下： 12345678910111213141516171819202122232425262728//所有C++层的消息都封装为MessageEnvelope类型的变量并保存到mMessageEnvelopes链表中 while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); //处理当前时刻之前的所有消息 if (messageEnvelope.uptime &lt;= now) &#123; &#123; //取出处理该消息的Hanlder sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; //取出该消息描述符 Message message = messageEnvelope.message; //从mMessageEnvelopes链表中移除该消息 mMessageEnvelopes.removeAt(0); //表示当前消息循环线程正在处理消息，处于唤醒状态，因此消息发送线程无需唤醒消息循环线程 mSendingMessage = true; mLock.unlock(); //调用该消息Handler对象的handleMessage函数来处理该消息 handler-&gt;handleMessage(message); &#125; // release handler mLock.lock(); mSendingMessage = false; result = ALOOPER_POLL_CALLBACK; &#125; else &#123; // The last message left at the head of the queue determines the next wakeup time. mNextMessageUptime = messageEnvelope.uptime; break; &#125; &#125; 消息处理过程就是调用该消息的Handler对象的handleMessage函数来完成，由于创建Surface时，往消息队列中发送的Handler对象类型为MessageCreateSurface，因此必定会调用该类的handleMessage函数来处理Surface创建消息。但该类并未实现handleMessage函数，同时该类继承于MessageBase，由此可见其父类MessageBase必定实现了handleMessage函数： 1234void MessageBase::handleMessage(const Message&amp;) &#123; this-&gt;handler(); barrier.open(); &#125;; 该函数首先调用其子类的handler()函数处理消息，然后唤醒消息发送线程，表明发往消息队列中的消息已得到处理，消息发送线程可以往下执行了。由于MessageCreateSurface是MessageBase的子类，因此该类必定实现了handler()函数来处理Surface创建消息： 123456789101112131415161718192021222324252627class MessageCreateSurface : public MessageBase &#123; sp&lt;ISurface&gt; result; SurfaceFlinger* flinger; ISurfaceComposerClient::surface_data_t* params; Client* client; const String8&amp; name; DisplayID display; uint32_t w, h; PixelFormat format; uint32_t flags; public: MessageCreateSurface(SurfaceFlinger* flinger, ISurfaceComposerClient::surface_data_t* params, const String8&amp; name, Client* client, DisplayID display, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags) : flinger(flinger), params(params), client(client), name(name), display(display), w(w), h(h), format(format), flags(flags) &#123; &#125; sp&lt;ISurface&gt; getResult() const &#123; return result; &#125; virtual bool handler() &#123; result = flinger-&gt;createSurface(params, name, client,display, w, h, format, flags); return true; &#125; &#125;; 这里又调用SurfaceFlinger的createSurface函数来创建Surface。绕了一圈又回到SurfaceFlinger，为什么要这么做呢？因为在同一时刻可以有多个应用程序请求SurfaceFlinger为其创建Surface，通过消息队列可以实现请求排队，然后SurfaceFlinger依次为应用程序创建Surface。图解： 红色虚线关系：Java层和Native层的MessageQueue通过JNI建立关联，彼此之间能相互调用，搞明白这个互调关系，也就搞明白了Java如何调用C++代码，C++代码又是如何调用Java代码。蓝色虚线关系：Handler/Looper/Message这三大类Java层与Native层并没有任何的真正关联，只是分别在Java层和Native层的handler消息模型中具有相似的功能。都是彼此独立的，各自实现相应的逻辑。WeakMessageHandler继承于MessageHandler类，NativeMessageQueue继承于MessageQueue类另外，消息处理流程是先处理Native Message，再处理Native Request，最后处理Java Message。理解了该流程，也就明白有时上层消息很少，但响应时间却较长的真正原因。 总结： 参考文档（特别感谢）：Android消息处理机制(Handler、Looper、MessageQueue与Message)android的消息处理机制（图+源码分析）——Looper,Handler,MessageAndroid进阶——Android消息机制之Looper、Handler、MessageQueenHandler、Looper、Message、MessageQueue 基础流程分析图解Android 中线程间通信原理分析：Looper, MessageQueue, HandlerAndroid消息机制1-Handler(Java层)Android消息机制2-Handler(Native层)ANDROID消息机制，从JAVA层到NATIVE层剖析Android应用程序消息处理机制Android 消息机制（三）Native层消息机制","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Hexo - Hello World","slug":"hello-world","date":"2015-06-30T16:00:00.000Z","updated":"2018-03-27T10:19:26.000Z","comments":true,"path":"2015/07/01/hello-world/","link":"","permalink":"http://zhoujinjian.cc/2015/07/01/hello-world/","excerpt":"Melody：A simple &amp; beautiful &amp; fast theme for Hexo. hexo-theme-melodyhexo-theme-melody-documentation","text":"Melody：A simple &amp; beautiful &amp; fast theme for Hexo. hexo-theme-melodyhexo-theme-melody-documentation Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo Deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://zhoujinjian.cc/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://zhoujinjian.cc/tags/Hexo/"}]}]}