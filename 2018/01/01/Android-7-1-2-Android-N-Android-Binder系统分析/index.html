<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android 7.1.2 (Android N) Android Binder 系统 分析"><meta name="keywords" content="Android"><meta name="author" content="๑Charles✦ˑ̫✦Vincent๑,undefined"><meta name="copyright" content="๑Charles✦ˑ̫✦Vincent๑"><title>Android 7.1.2 (Android N) Android Binder 系统 分析 | ๑Charles✦ˑ̫✦Vincent๑</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=undefined"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL = { 
  root: '/',
  algolia: {"appId":"JENF3KX428","apiKey":"e3788e36a05c74aee98a14de07ccc417","indexName":"zhoujinjian.cc","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#博客原图链接"><span class="toc-number">1.</span> <span class="toc-text">博客原图链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、Android-Binder系统C程序示例"><span class="toc-number">1.1.</span> <span class="toc-text">一、Android Binder系统C程序示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）、简述Binder跨进程机制"><span class="toc-number">1.1.1.</span> <span class="toc-text">（1）、简述Binder跨进程机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1、Server进程向ServiceManager注册服务"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1、Server进程向ServiceManager注册服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2、分析Android-binder原生示例程序bctest-c："><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.2、分析Android binder原生示例程序bctest.c：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3、示例程序（bctest-c）注册服务、获取服务过程"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.3、示例程序（bctest.c）注册服务、获取服务过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）、Android-Binder系统-ServiceManager"><span class="toc-number">1.1.2.</span> <span class="toc-text">（2）、Android Binder系统_ServiceManager</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1、ServiceManager中service句柄如何管理"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">2.1、ServiceManager中service句柄如何管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2、解析Binder上传数据-binder-parse函数"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2.2、解析Binder上传数据-(binder_parse函数)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3、数据转换binder-transaction-data-gt-binder-io"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">2.3、数据转换binder_transaction_data-&gt;binder_io</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4、如何添加服务SVC-MGR-ADD-SERVICE"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">2.4、如何添加服务SVC_MGR_ADD_SERVICE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5、如何获取服务SVC-MGR-CHECK-SERVICE"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">2.5、如何获取服务SVC_MGR_CHECK_SERVICE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6、ServiceManager回复数据"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">2.6、ServiceManager回复数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7、总结："><span class="toc-number">1.1.2.7.</span> <span class="toc-text">2.7、总结：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）、Android-Binder系统C程序"><span class="toc-number">1.1.3.</span> <span class="toc-text">（3）、Android Binder系统C程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1、Android-Binder系统C程序-框架"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">3.1、Android Binder系统C程序_框架</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2、Android-Binder系统C程序-编码"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">3.2、Android Binder系统C程序_编码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3、Android-Binder系统C程序-测试"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">3.3、Android Binder系统C程序_测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、Android-Binder系统-Driver层"><span class="toc-number">1.2.</span> <span class="toc-text">二、Android Binder系统-Driver层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）、Binder驱动概述"><span class="toc-number">1.2.1.</span> <span class="toc-text">（1）、Binder驱动概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-概述"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.1 概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-系统调用"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">1.2 系统调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）、Binder核心方法"><span class="toc-number">1.2.2.</span> <span class="toc-text">（2）、Binder核心方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1、binder-init"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.1、binder_init()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2、主要结构"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2、主要结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3、Binder协议"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.3、Binder协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4、binder-open"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.4、binder_open()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5、binder-mmap"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">2.5、binder_mmap()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6、binder-ioctl-内存管理"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">2.6、binder_ioctl()内存管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7、Binder中的“面向对象”"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">2.7、Binder中的“面向对象”</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-8、驱动层的线程管理"><span class="toc-number">1.2.2.8.</span> <span class="toc-text">2.8、驱动层的线程管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-9、再聊ServiceManager"><span class="toc-number">1.2.2.9.</span> <span class="toc-text">2.9、再聊ServiceManager</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-10、binder-node等重要结构体"><span class="toc-number">1.2.2.10.</span> <span class="toc-text">2.10、binder_node等重要结构体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、Android-Binder系统驱动情景分析"><span class="toc-number">1.3.</span> <span class="toc-text">三、Android Binder系统驱动情景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）、Binder系统驱动情景分析—服务“Hello”注册过程"><span class="toc-number">1.3.1.</span> <span class="toc-text">（1）、Binder系统驱动情景分析—服务“Hello”注册过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1、ServiceManager休眠等待"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1.1、ServiceManager休眠等待</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2、Clent（此处为Test-server）请求SM添加服务"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">1.2、Clent（此处为Test_server）请求SM添加服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3、唤醒ServiceManager执行添加“hello”服务"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">1.3、唤醒ServiceManager执行添加“hello”服务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）、Binder系统驱动情景分析—TestClent获取“Hello”服务过程"><span class="toc-number">1.3.2.</span> <span class="toc-text">（2）、Binder系统驱动情景分析—TestClent获取“Hello”服务过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-0、构造数据"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">2.0、构造数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1、发送数据给ServiceManager"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2.1、发送数据给ServiceManager</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2、binder-thread-write-处理数据"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">2.2、binder_thread_write()处理数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3、Binder驱动中binder-transaction-的源码"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">2.3、Binder驱动中binder_transaction()的源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4、Binder驱动中binder-thread-read-的源码"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">2.4、Binder驱动中binder_thread_read()的源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5、ServiceManager处理getService请求"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">2.5、ServiceManager处理getService请求</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-6、Binder驱动中处理ServiceManager返回数据"><span class="toc-number">1.3.2.6.1.</span> <span class="toc-text">2.6、Binder驱动中处理ServiceManager返回数据</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-Testclient获取handle"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">2.7. Testclient获取handle</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）、Binder系统驱动情景分析—TestClent使用“Hello”服务过程"><span class="toc-number">1.3.3.</span> <span class="toc-text">（3）、Binder系统驱动情景分析—TestClent使用“Hello”服务过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、Android-Binder系统-Native层"><span class="toc-number">1.4.</span> <span class="toc-text">四、Android Binder系统-Native层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-、ServiceManager类图-Native层"><span class="toc-number">1.4.1.</span> <span class="toc-text">(1)、ServiceManager类图(Native层)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-、Binder框架Native层"><span class="toc-number">1.4.2.</span> <span class="toc-text">(2)、Binder框架Native层</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1、Binder的初始化ProcessState"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">2.1、Binder的初始化ProcessState</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2、关于Binder传递数据的大小限制"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">2.2、关于Binder传递数据的大小限制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3、与驱动的通信IPCThreadState"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">2.3、与驱动的通信IPCThreadState</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4、Framework层的线程管理"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">2.4、Framework层的线程管理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）、Android-Binder系统-Native层添加hello服务"><span class="toc-number">1.4.3.</span> <span class="toc-text">（3）、Android Binder系统-Native层添加hello服务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1、Client构造数据，发送数据给驱动"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">3.1、Client构造数据，发送数据给驱动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1、-writeStrongBinder"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">3.2.1、* writeStrongBinder()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2、flatten-binder"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">3.2.2、flatten_binder()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3、finish-flatten-binder"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">3.2.3、finish_flatten_binder()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-4-、waitForResponse"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">3.2.4 、waitForResponse()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-5、-IPCThreadState-talkWithDriver"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">3.2.5、  IPCThreadState::talkWithDriver</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-6、Client获取服务、处理回复数据过程"><span class="toc-number">1.4.3.7.</span> <span class="toc-text">3.2.6、Client获取服务、处理回复数据过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-7、Parcel-ipcSetDataReference"><span class="toc-number">1.4.3.8.</span> <span class="toc-text">3.2.7、Parcel::ipcSetDataReference</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-8、readStrongBinder"><span class="toc-number">1.4.3.9.</span> <span class="toc-text">3.2.8、readStrongBinder()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-9、readStrongBinder-C"><span class="toc-number">1.4.3.10.</span> <span class="toc-text">3.2.9、readStrongBinder(C++)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-10、unflatten-binder"><span class="toc-number">1.4.3.11.</span> <span class="toc-text">3.2.10、unflatten_binder()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-11、getStrongProxyForHandle"><span class="toc-number">1.4.3.12.</span> <span class="toc-text">3.2.11、getStrongProxyForHandle()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（4）、Android-Binder系统-Native层获取hello服务"><span class="toc-number">1.4.4.</span> <span class="toc-text">（4）、Android Binder系统-Native层获取hello服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、Android-Binder系统-Framwork-Java层"><span class="toc-number">1.5.</span> <span class="toc-text">五、Android Binder系统-Framwork-Java层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）、Android-Binder系统Java层"><span class="toc-number">1.5.1.</span> <span class="toc-text">（1）、Android Binder系统Java层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）、JNI的衔接"><span class="toc-number">1.5.2.</span> <span class="toc-text">（2）、JNI的衔接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）、Java层的ServiceManager"><span class="toc-number">1.5.3.</span> <span class="toc-text">（3）、Java层的ServiceManager</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、Android-Binder系统-AIDL"><span class="toc-number">1.6.</span> <span class="toc-text">六、Android Binder系统-AIDL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#七、参考文档-特别感谢各位前辈的分析和图示-："><span class="toc-number">1.7.</span> <span class="toc-text">七、参考文档(特别感谢各位前辈的分析和图示)：</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s19.postimg.org/l6oufd5cj/Dream_Works_2016_Stacked-_MI-512x512.png"></div><div class="author-info__name text-center">๑Charles✦ˑ̫✦Vincent๑</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">2</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://bing.ioliu.cn/v1?p=1&amp;d=2&amp;w=1920&amp;h=1200);"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">๑Charles✦ˑ̫✦Vincent๑</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Android 7.1.2 (Android N) Android Binder 系统 分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><p>Android Binder系统概述：<br>Binder是Android系统中大量使用的IPC（Inter-process communication，进程间通讯）机制。无论是应用程序对系统服务的请求，还是应用程序自身提供对外服务，都需要使用到Binder。因此，Binder机制在Android系统中的地位非常重要，可以说，理解Binder是理解Android系统的绝对必要前提。</p>
<a id="more"></a>
<blockquote>
<p><strong>framework/base/core/java/               (Java)</strong><br><strong>framework/base/core/jni/                (JNI)</strong><br><strong>framework/native/libs/binder            (Native)</strong><br><strong>framework/native/cmds/servicemanager/   (Native)</strong><br><strong>kernel/drivers/staging/android          (Driver)</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>Java framework</strong></p>
</blockquote>
<p><strong>framework/base/core/java/android/os/</strong><br>● IInterface.java<br>● IBinder.java<br>● Parcel.java<br>● IServiceManager.java<br>● ServiceManager.java<br>● ServiceManagerNative.java<br>● Binder.java  </p>
<p><strong>framework/base/core/jni/</strong><br>● android_os_Parcel.cpp<br>● AndroidRuntime.cpp<br>● android_util_Binder.cpp (核心类)</p>
<hr>
<blockquote>
<p><strong>Native framework</strong></p>
</blockquote>
<p><strong>framework/native/libs/binder</strong><br>● IServiceManager.cpp<br>● BpBinder.cpp<br>● Binder.cpp<br>● IPCThreadState.cpp (核心类)<br>● ProcessState.cpp  (核心类)</p>
<p><strong>framework/native/include/binder/</strong><br>● IServiceManager.h<br>● IInterface.h</p>
<p><strong>framework/native/cmds/servicemanager/</strong><br>● bctest.c<br>● binder.h<br>● binder.c<br>● service_manager.c<br>● servicemanager.rc</p>
<hr>
<blockquote>
<p><strong>Kernel</strong></p>
</blockquote>
<p><strong>kernel/drivers/staging/android/</strong></p>
<p>● binder.c<br>● binder.h</p>
<h2 id="博客原图链接"><a href="#博客原图链接" class="headerlink" title="博客原图链接"></a><a href="https://postimg.org/gallery/19zp83pbk/" target="_blank" rel="noopener">博客原图链接</a></h2><h3 id="一、Android-Binder系统C程序示例"><a href="#一、Android-Binder系统C程序示例" class="headerlink" title="一、Android Binder系统C程序示例"></a>一、Android Binder系统C程序示例</h3><h4 id="（1）、简述Binder跨进程机制"><a href="#（1）、简述Binder跨进程机制" class="headerlink" title="（1）、简述Binder跨进程机制"></a>（1）、简述Binder跨进程机制</h4><p>Android系统中，每个应用程序是由Android的Activity，Service，Broadcast，ContentProvider这四组件的中一个或多个组合而成，这四组件所涉及的多进程间的通信底层都是依赖于Binder IPC机制。</p>
<p>从进程角度来看IPC机制<br><a href="https://postimg.org/image/e8vcapihb/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/brjl3fykz/01-_Android-binder-binder_interprocess_communication.png" alt="01-_Android-binder-binder_interprocess_communication.png"></a></p>
<p><a href="https://postimg.org/image/brjl3hw0v/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/n3w6la4pv/02-_Android-binder-_IPC-_Binder.jpg" alt="02-_Android-binder-_IPC-_Binder.jpg"></a></p>
<p>现在Client进程需要访问Server进程中的服务，会经过以下步骤：<br>1、Server进程首先向ServiceManager注册服务（ServiceManager先于Server启动）<br>2、Client进程向ServiceManager查询服务得到一个句柄Handle（Server进程可能不止一个服务，用Handle区分是哪一个服务）<br>3、Client进程 封装数据Buffer通过Binder驱动发送给Server进程，Server进程取得数据后解析数据，使用Server进程的Handle服务对应的函数处理数据，处理完成后通过Binder驱动传输给Client进程</p>
<h5 id="1-1、Server进程向ServiceManager注册服务"><a href="#1-1、Server进程向ServiceManager注册服务" class="headerlink" title="1.1、Server进程向ServiceManager注册服务"></a>1.1、Server进程向ServiceManager注册服务</h5><p>ServiceManager是一个守护进程。它的main()函数源码如下：</p>
<blockquote>
<p>ServiceManager是如何启动的？<br>这里简要介绍一下ServiceManager的启动方式。当Kernel启动加载完驱动之后，会启动Android的init进程，init进程会解析servicemanager.rc，进而启动servicemanager.rc中定义的守护进程。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ServiceManager.c]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</span><br><span class="line"></span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    svcmgr_handle = svcmgr;</span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_loop</span><span class="params">(struct binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉Kernel，ServiceManager进程进入了消息循环状态。</span></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向Kernel中发送消息(先写后读)。</span></span><br><span class="line">        <span class="comment">// 先将消息传递给Kernel，然后再从Kernel读取消息反馈</span></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析读取的消息反馈</span></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>binder_loop()主要工作：<br>(1)、通过ioctl(,BINDER_WRITE_READ,)进入消息循环，休眠等待Client请求<br>(2)、当Client通过驱动请求服务时，binder驱动会唤醒ServiceManager，通过binder_parse()解析处理数据，回复信息</p>
<p>代码调用关系图：<br><a href="https://postimg.org/image/iurgj1wan/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/kmkfdyfnn/03-_Android-binder-_Service_Manager-main.jpg" alt="03-_Android-binder-_Service_Manager-main.jpg"></a></p>
<p>时序流程图：<br><a href="https://postimg.org/image/63dacjesv/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/5133tzvzn/04-_Android-binder-_Service_Manager-main-flow.jpg" alt="04-_Android-binder-_Service_Manager-main-flow.jpg"></a></p>
<p>main()主要进行了三项工作：<br>(1) 、通过binder_open()打开”/dev/binder”文件，即打开Binder设备文件。<br>(2) 、调用binder_become_context_manager()，通过ioctl()告诉Binder驱动程序自己是Binder上下文管理者。<br>(3) 、调用binder_loop()进入消息循环，等待Client的请求。如果没有Client请求，则进入睡眠等待状态；当有Client请求时，就被唤醒，然后读取并处理Client请求。</p>
<h5 id="1-2、分析Android-binder原生示例程序bctest-c："><a href="#1-2、分析Android-binder原生示例程序bctest-c：" class="headerlink" title="1.2、分析Android binder原生示例程序bctest.c："></a>1.2、分析Android binder原生示例程序bctest.c：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> svcmgr = BINDER_SERVICE_MANAGER;</span><br><span class="line">    <span class="keyword">uint32_t</span> handle;</span><br><span class="line"></span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (argc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//svcmgr_lookup方法调用binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_ADD_SERVICE)</span></span><br><span class="line">            handle = svcmgr_lookup(bs, svcmgr, <span class="string">"alt_svc_mgr"</span>);</span><br><span class="line">            <span class="comment">//svcmgr_publish方法调用binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_CHECK_SERVICE)</span></span><br><span class="line">            svcmgr_publish(bs, svcmgr, argv[<span class="number">1</span>], &amp;token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-3、示例程序（bctest-c）注册服务、获取服务过程"><a href="#1-3、示例程序（bctest-c）注册服务、获取服务过程" class="headerlink" title="1.3、示例程序（bctest.c）注册服务、获取服务过程"></a>1.3、示例程序（bctest.c）注册服务、获取服务过程</h5><p>注册服务的过程（bctest.c）:<br><a href="https://postimg.org/image/sfb35y8rz/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/tucnuo9v7/06-_Android-binder-_Service_Manager-main-_SM-_Publish.png" alt="06-_Android-binder-_Service_Manager-main-_SM-_Publish.png"></a></p>
<p>(1) 、bs = binder_open(128*1024)<br>(2) 、binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_ADD_SERVICE)<br>参数说明：<br>                   // msg含有服务的名字<br>                         // reply它会含有servicemanager回复的数据<br>                                 // target为0表示servicemanager<br>                                    // code: 表示要调用servicemanager中的”addservice函数”</p>
<p>获取服务的过程（bctest.c）:<br><a href="https://postimg.org/image/ii02cvtgf/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/5dui071er/05-_Android-binder-_Service_Manager-_Look_Up.png" alt="05-_Android-binder-_Service_Manager-_Look_Up.png"></a></p>
<p>(1) 、bs = binder_open(128*1024)<br>(2) 、binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_CHECK_SERVICE)<br>参数说明：<br>                   // msg含有服务的名字<br>                         // reply它会含有servicemanager回复的数据, 表示提供服务的进程<br>                                 // target为0表示servicemanager<br>                                    // code: 表示要调用servicemanager中的”getservice函数”</p>
<p>binder_call远程实现：<br>根据msg、target、code就知道需要调用哪个服务的哪一个函数。<br><a href="https://postimg.org/image/ap9ekykxb/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/pl7xsjwc3/07-_Android-binder-_Binder_call.png" alt="07-_Android-binder-_Binder_call.png"></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_call</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_io *msg, struct binder_io *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">uint32_t</span> target, <span class="keyword">uint32_t</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">txn</span>;</span></span><br><span class="line">    &#125; __attribute__((packed)) writebuf;</span><br><span class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    writebuf.cmd = BC_TRANSACTION;</span><br><span class="line">    writebuf.txn.target.handle = target;</span><br><span class="line">    writebuf.txn.code = code;</span><br><span class="line">    writebuf.txn.flags = <span class="number">0</span>;</span><br><span class="line">    writebuf.txn.data_size = msg-&gt;data - msg-&gt;data0;</span><br><span class="line">    writebuf.txn.offsets_size = ((<span class="keyword">char</span>*) msg-&gt;offs) - ((<span class="keyword">char</span>*) msg-&gt;offs0);</span><br><span class="line">    writebuf.txn.data.ptr.buffer = (<span class="keyword">uintptr_t</span>)msg-&gt;data0;</span><br><span class="line">    writebuf.txn.data.ptr.offsets = (<span class="keyword">uintptr_t</span>)msg-&gt;offs0;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="keyword">sizeof</span>(writebuf);</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>) &amp;writebuf;</span><br><span class="line"></span><br><span class="line">    hexdump(msg-&gt;data0, msg-&gt;data - msg-&gt;data0);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">        </span><br><span class="line">        res = binder_parse(bs, reply, (<span class="keyword">uintptr_t</span>) readbuf, bwr.read_consumed, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： 结构体简介<br>binder_io  封装一次发送的数据<br>binder_write_read    存储一次读写操作的数据<br>binder_transaction_data    存储一次事务的数据<br><a href="https://postimg.org/image/3m1j5axhb/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/63dackhdv/08-_Android-binder-binder_io_struct.png" alt="08-_Android-binder-binder_io_struct.png"></a><br><a href="https://postimg.org/image/vyx0vse2n/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/9zqm8kx8j/09-_Android-binder-binder_write_read.png" alt="09-_Android-binder-binder_write_read.png"></a><br><a href="https://postimg.org/image/b20sr48bz/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/9zqm8kpir/10-_Android-binder-binder_transaction_data.jpg" alt="10-_Android-binder-binder_transaction_data.jpg | 245x390"></a></p>
</blockquote>
<p>（1）构造参数，使用binder_io 描述<br>（2）数据转换binder_io -&gt; binder_write_read；首先根据binder_io 、target、code三者构造binder_transaction_data，然后将binder_write_read.write_buffer指向binder_transaction_data<br>（3）调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);发送数据<br><a href="https://postimg.org/image/j7iupaz5r/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/vyx0vt8xv/11-_Android-_Binder-binder_call.png" alt="11-_Android-_Binder-binder_call.png"></a></p>
<h4 id="（2）、Android-Binder系统-ServiceManager"><a href="#（2）、Android-Binder系统-ServiceManager" class="headerlink" title="（2）、Android Binder系统_ServiceManager"></a>（2）、Android Binder系统_ServiceManager</h4><p>我们先跳过ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)所涉及的内核知识和流程，稍后再Android Binder系统-Driver层详细介绍。</p>
<h5 id="2-1、ServiceManager中service句柄如何管理"><a href="#2-1、ServiceManager中service句柄如何管理" class="headerlink" title="2.1、ServiceManager中service句柄如何管理"></a>2.1、ServiceManager中service句柄如何管理</h5><p>前面分析过，ServiceManager开机初始会启动成为一个守护进程， ServiceManager是如何管理service句柄的？<br>进程里有一个全局性的svclist变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">svclist</span> = 0;</span></span><br></pre></td></tr></table></figure>
<p>它记录着所有添加进系统的“Service”信息，这些信息被组织成一条单向链表，我们不妨称这条链表为“Service向量表”。示意图如下：<br><a href="https://postimg.org/image/63dackwtb/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/63dackwtf/12-_Android-_Binder-_SM-svclist.jpg" alt="12-_Android-_Binder-_SM-svclist.jpg"></a></p>
<p>链表节点类型为svcinfo</p>
<p><a href="https://postimg.org/image/v9e8jfl8v/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/h2yho7adv/13-_Android-_Binder-_SM-svcinfo.png" alt="13-_Android-_Binder-_SM-svcinfo.png"></a></p>
<p>添加服务简单理解就是 新建svcinfo节点插入到单链表中，查询服务就是看单链表是否有此服务。</p>
<h5 id="2-2、解析Binder上传数据-binder-parse函数"><a href="#2-2、解析Binder上传数据-binder-parse函数" class="headerlink" title="2.2、解析Binder上传数据-(binder_parse函数)"></a>2.2、解析Binder上传数据-(binder_parse函数)</h5><p>回到ServiceManager的main()函数。binder_loop()会先向binder驱动发出了BC_ENTER_LOOPER命令，接着进入一个for循环不断调用ioctl()读取发来的数据，接着解析这些数据。假设现在Client有请求，Binder驱动就通过会上传数据。读取数据后会交由binder_parse()解析。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binder_loop(bs, svcmgr_handler);</span><br></pre></td></tr></table></figure>
<p>注意binder_loop()的参数svcmgr_handler()函数指针。而且这个参数会进一步传递给binder_parse()。binder_parse()负责解析从binder驱动读来的数据，其代码截选如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_parse</span><span class="params">(struct binder_state *bs, struct binder_io *bio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">uintptr_t</span> ptr, <span class="keyword">size_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end = ptr + (<span class="keyword">uintptr_t</span>) size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd = *(<span class="keyword">uint32_t</span> *) ptr;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//驱动有数据后会返回次cmd</span></span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">txn</span> = (<span class="title">struct</span> <span class="title">binder_transaction_data</span> *) <span class="title">ptr</span>;</span></span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                <span class="keyword">if</span> (txn-&gt;flags &amp; TF_ONE_WAY) &#123;</span><br><span class="line">                    binder_free_buffer(bs, txn-&gt;data.ptr.buffer);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</span><br><span class="line">                &#125;              </span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从前文的代码我们可以看到，binder_loop()声明了一个128节的buffer（即uint32_t readbuf[32]），每次用BINDER_WRITE_READ命令从驱动读取一些内容，并传入binder_parse()。<br> binder_parse()在合适的时机，会回调其func参数（binder_handler func）指代的回调函数，即前文说到的svcmgr_handler()函数。</p>
<p> binder_loop()就这样一直循环下去，完成了整个ServiceManager的工作。</p>
<h5 id="2-3、数据转换binder-transaction-data-gt-binder-io"><a href="#2-3、数据转换binder-transaction-data-gt-binder-io" class="headerlink" title="2.3、数据转换binder_transaction_data-&gt;binder_io"></a>2.3、数据转换binder_transaction_data-&gt;binder_io</h5><p>初始化reply；根据txt(Binder驱动反馈的信息)初始化msg<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">bio_init_from_txn(&amp;msg, txn);</span><br></pre></td></tr></table></figure></p>
<h5 id="2-4、如何添加服务SVC-MGR-ADD-SERVICE"><a href="#2-4、如何添加服务SVC-MGR-ADD-SERVICE" class="headerlink" title="2.4、如何添加服务SVC_MGR_ADD_SERVICE"></a>2.4、如何添加服务SVC_MGR_ADD_SERVICE</h5><p>前面讲过 binder_parse()在合适的时机，会回调其func参数（binder_handler func）指代的回调函数，即前文说到的svcmgr_handler()函数。并且会根据binder_transaction_data的code判断具体调用哪一个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svcmgr_handler</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *txn,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> *s;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">uint32_t</span> handle;</span><br><span class="line">    <span class="keyword">uint32_t</span> strict_policy;</span><br><span class="line">    <span class="keyword">int</span> allow_isolated;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_GET_SERVICE:</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_CHECK_SERVICE:</span><br><span class="line">        s = bio_get_string16(msg, &amp;len);</span><br><span class="line">        handle = do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);</span><br><span class="line">        bio_put_ref(reply, handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_ADD_SERVICE:</span><br><span class="line">        s = bio_get_string16(msg, &amp;len);</span><br><span class="line">        handle = bio_get_ref(msg);</span><br><span class="line">        allow_isolated = bio_get_uint32(msg) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (do_add_service(bs, s, len, handle, txn-&gt;sender_euid,</span><br><span class="line">            allow_isolated, txn-&gt;sender_pid))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    bio_put_uint32(reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知code = SVC_MGR_ADD_SERVICE 会调用do_add_service()函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">uint16_t</span> *s, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint32_t</span> handle, <span class="keyword">uid_t</span> uid, <span class="keyword">int</span> allow_isolated,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">pid_t</span> spid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line">    <span class="keyword">if</span> (si) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        ...</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">        si-&gt;len = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        si-&gt;name[len] = <span class="string">'\0'</span>;</span><br><span class="line">        si-&gt;death.func = (<span class="keyword">void</span>*) svcinfo_death;</span><br><span class="line">        si-&gt;death.ptr = si;</span><br><span class="line">        si-&gt;allow_isolated = allow_isolated;</span><br><span class="line">        si-&gt;next = svclist;</span><br><span class="line">        svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_acquire(bs, handle);</span><br><span class="line">    binder_link_to_death(bs, handle, &amp;si-&gt;death);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见添加Service只是新建了一个svcinfo然后插入到前面所说的“Service向量表”中。</p>
<h5 id="2-5、如何获取服务SVC-MGR-CHECK-SERVICE"><a href="#2-5、如何获取服务SVC-MGR-CHECK-SERVICE" class="headerlink" title="2.5、如何获取服务SVC_MGR_CHECK_SERVICE"></a>2.5、如何获取服务SVC_MGR_CHECK_SERVICE</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> do_find_service(<span class="keyword">const</span> <span class="keyword">uint16_t</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">uid_t</span> uid, <span class="keyword">pid_t</span> spid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span> = <span class="title">find_svc</span>(<span class="title">s</span>, <span class="title">len</span>);</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> si-&gt;handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取服务会查询“Service向量表”是否有此服务，然后返回Service的句柄handle。</p>
<h5 id="2-6、ServiceManager回复数据"><a href="#2-6、ServiceManager回复数据" class="headerlink" title="2.6、ServiceManager回复数据"></a>2.6、ServiceManager回复数据</h5><p>前面分析回调svcmgr_handler()函数处理数据后，会调用binder_send_reply()函数<br>回复消息给驱动。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res)</span><br></pre></td></tr></table></figure></p>
<h5 id="2-7、总结："><a href="#2-7、总结：" class="headerlink" title="2.7、总结："></a>2.7、总结：</h5><p>示例程序（bctest.c）注册、获取服务一般分以下步骤：<br>（1）源进程通过binder_open()打开”/dev/binder”文件，即打开Binder设备文件。<br>（2）源进程构造数据：[a].构造binder_io [b].转为binder_transaction_data [c].放入binder_write_read<br>（3）源进程调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);发送数据给驱动<br>（4）驱动上报数据到目的进程ServiceManager<br>（5）目的进程ServiceManager处理完数据，重新构造数据，通过调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);发送数据给驱动<br>（6）驱动然后将数据反馈到源进程</p>
<h4 id="（3）、Android-Binder系统C程序"><a href="#（3）、Android-Binder系统C程序" class="headerlink" title="（3）、Android Binder系统C程序"></a>（3）、Android Binder系统C程序</h4><h5 id="3-1、Android-Binder系统C程序-框架"><a href="#3-1、Android-Binder系统C程序-框架" class="headerlink" title="3.1、Android Binder系统C程序_框架"></a>3.1、Android Binder系统C程序_框架</h5><p>总结bctest.c注册服务获取服务的一般流程框架：<br><a href="https://postimg.org/image/mfnc1s8en/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/rr28mhuhf/14-_Android-_Binder-binder_C_app_client_server_Arc.png" alt="14-_Android-_Binder-binder_C_app_client_server_Arc.png"></a></p>
<h5 id="3-2、Android-Binder系统C程序-编码"><a href="#3-2、Android-Binder系统C程序-编码" class="headerlink" title="3.2、Android Binder系统C程序_编码"></a>3.2、Android Binder系统C程序_编码</h5><p>参考bctest.c编码：<br>test_server：向ServiceManager添加服务”hello” &amp;&amp; “goodbye” Service<br>test_client ：查询获取服务(ServiceManager)<br><a href="https://github.com/weidongshan/APP_0003_Binder_C_App" target="_blank" rel="noopener">链接：Binder_C_App</a><br><a href="https://postimg.org/image/8yqdiwqdb/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/64n85go77/15-_Android-binder-_C-_Test-_App.png" alt="15-_Android-binder-_C-_Test-_App.png"></a></p>
<h5 id="3-3、Android-Binder系统C程序-测试"><a href="#3-3、Android-Binder系统C程序-测试" class="headerlink" title="3.3、Android Binder系统C程序_测试"></a>3.3、Android Binder系统C程序_测试</h5><p>./test_server &amp;<br>./test_client hello<br>./test_client hello 100ask.taobao.com<br>./test_client goodbye<br>./test_client goodbye 100ask.taobao.com</p>
<h3 id="二、Android-Binder系统-Driver层"><a href="#二、Android-Binder系统-Driver层" class="headerlink" title="二、Android Binder系统-Driver层"></a>二、Android Binder系统-Driver层</h3><p>前面打开驱动binder_open(128*1024)、ServiceManager启动是如何与驱动交互成为管理者的，以及添加服务获取服务<br>驱动部分都没有详细讲解，现在一起来看下。</p>
<h4 id="（1）、Binder驱动概述"><a href="#（1）、Binder驱动概述" class="headerlink" title="（1）、Binder驱动概述"></a>（1）、Binder驱动概述</h4><h5 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h5><p>Binder驱动是Android专用的，但底层的驱动架构与Linux驱动一样。binder驱动在以misc设备进行注册，作为虚拟字符设备，没有直接操作硬件，只是对设备内存的处理。主要是驱动设备的初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。如启动ServiceManager调用:<br><a href="https://postimg.org/image/cttrm21zj/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/63dacmetv/16-_Android-_Binder-start_service_manager.jpg" alt="16-_Android-_Binder-start_service_manager.jpg"></a></p>
<h5 id="1-2-系统调用"><a href="#1-2-系统调用" class="headerlink" title="1.2 系统调用"></a>1.2 系统调用</h5><p>用户态的程序调用Kernel层驱动是需要陷入内核态，进行系统调用(syscall)，比如打开Binder驱动方法的调用链为：<br> open-&gt; <strong>open() -&gt; binder_open()。 open()为用户空间的方法，</strong>open()便是系统调用中相应的处理方法，通过查找，对应调用到内核binder驱动的binder_open()方法，至于其他的从用户态陷入内核态的流程也基本一致。<br><a href="https://postimg.org/image/wcycuvilb/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/i6ilzn7qb/17-_Android-binder_driver_interface.png" alt="17-_Android-binder_driver_interface.png"></a></p>
<h4 id="（2）、Binder核心方法"><a href="#（2）、Binder核心方法" class="headerlink" title="（2）、Binder核心方法"></a>（2）、Binder核心方法</h4><h5 id="2-1、binder-init"><a href="#2-1、binder-init" class="headerlink" title="2.1、binder_init()"></a>2.1、binder_init()</h5><p>主要工作是为了注册misc设备<br>binder_init函数中最主要的工作其实下面这行：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = misc_register(&amp;binder_miscdev);</span><br></pre></td></tr></table></figure></p>
<p>该行代码真正向内核中注册了Binder设备。binder_miscdev的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">binder_miscdev</span> = &#123;</span></span><br><span class="line">	.minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">	.name = <span class="string">"binder"</span>,</span><br><span class="line">	.fops = &amp;binder_fops</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里指定了Binder设备的名称是“binder”。这样，在用户空间便可以通过对/dev/binder文件进行操作来使用Binder。<br>binder_miscdev同时也指定了该设备的fops。fops是另外一个结构体，这个结构中包含了一系列的函数指针，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> = &#123;</span></span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.poll = binder_poll,</span><br><span class="line">	.unlocked_ioctl = binder_ioctl,</span><br><span class="line">	.compat_ioctl = binder_ioctl,</span><br><span class="line">	.mmap = binder_mmap,</span><br><span class="line">	.open = binder_open,</span><br><span class="line">	.flush = binder_flush,</span><br><span class="line">	.release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="2-2、主要结构"><a href="#2-2、主要结构" class="headerlink" title="2.2、主要结构"></a>2.2、<strong>主要结构</strong></h5><p>Binder驱动中包含了很多的结构体。为了便于下文讲解，这里我们先对这些结构体做一些介绍。</p>
<p>驱动中的结构体可以分为两类：</p>
<p>一类是与用户空间共用的，这些结构体在Binder通信协议过程中会用到。因此，这些结构体定义在binder.h中，包括：</p>
<table>
<thead>
<tr>
<th style="text-align:left">结构体名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">flat_binder_object</td>
<td>描述在Binder IPC中传递的对象，见下文</td>
</tr>
<tr>
<td style="text-align:left"><strong>binder_write_read</strong></td>
<td>存储一次读写操作的数据</td>
</tr>
<tr>
<td style="text-align:left">binder_version</td>
<td>存储Binder的版本号</td>
</tr>
<tr>
<td style="text-align:left">transaction_flags</td>
<td>描述事务的flag，例如是否是异步请求，是否支持fd</td>
</tr>
<tr>
<td style="text-align:left"><strong>binder_transaction_data</strong></td>
<td>存储一次事务的数据</td>
</tr>
<tr>
<td style="text-align:left">binder_ptr_cookie</td>
<td>包含了一个指针和一个cookie</td>
</tr>
<tr>
<td style="text-align:left">binder_handle_cookie</td>
<td>包含了一个句柄和一个cookie</td>
</tr>
<tr>
<td style="text-align:left">binder_pri_desc</td>
<td>暂未用到</td>
</tr>
<tr>
<td style="text-align:left">binder_pri_ptr_cookie</td>
<td>暂未用到</td>
</tr>
</tbody>
</table>
<p>从前面Binder系统C程序框架分析，这其中，<strong>binder_write_read</strong>和<strong>binder_transaction_data</strong>这两个结构体最为重要，它们存储了IPC调用过程中的数据。关于这一点，我们在下文中会讲解。</p>
<p>Binder驱动中，还有一类结构体是仅仅Binder驱动内部实现过程中需要的，它们定义在binder.c中，包括：        </p>
<table>
<thead>
<tr>
<th style="text-align:left">结构体名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>binder_node</strong></td>
<td>描述Binder实体节点，即：对应了一个Server</td>
</tr>
<tr>
<td style="text-align:left"><strong>binder_ref</strong></td>
<td>描述对于Binder实体的引用</td>
</tr>
<tr>
<td style="text-align:left"><strong>binder_buffer</strong></td>
<td>描述Binder通信过程中存储数据的Buffer</td>
</tr>
<tr>
<td style="text-align:left"><strong>binder_proc</strong></td>
<td>描述使用Binder的进程</td>
</tr>
<tr>
<td style="text-align:left"><strong>binder_thread</strong></td>
<td>描述使用Binder的线程</td>
</tr>
<tr>
<td style="text-align:left">binder_work</td>
<td>描述通信过程中的一项任务</td>
</tr>
<tr>
<td style="text-align:left">binder_transaction</td>
<td>描述一次事务的相关信息</td>
</tr>
<tr>
<td style="text-align:left">binder_deferred_state</td>
<td>描述延迟任务</td>
</tr>
<tr>
<td style="text-align:left">binder_ref_death</td>
<td>描述Binder实体死亡的信息</td>
</tr>
<tr>
<td style="text-align:left">binder_transaction_log</td>
<td>debugfs日志</td>
</tr>
<tr>
<td style="text-align:left">binder_transaction_log_entry</td>
<td>debugfs日志条目</td>
</tr>
</tbody>
</table>
<p>这里需要读者关注的结构体已经用加粗做了标注。</p>
<h5 id="2-3、Binder协议"><a href="#2-3、Binder协议" class="headerlink" title="2.3、Binder协议"></a>2.3、<strong>Binder协议</strong></h5><p>Binder协议可以分为控制协议和驱动协议两类。</p>
<p>控制协议是进程通过ioctl(“/dev/binder”) 与Binder设备进行通讯的协议，该协议包含以下几种命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">结构体名称</th>
<th>说明</th>
<th style="text-align:center">参数类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>BINDER_WRITE_READ</strong></td>
<td>读写操作，最常用的命令。IPC过程就是通过这个命令进行数据传递</td>
<td style="text-align:center">binder_write_read</td>
</tr>
<tr>
<td style="text-align:left">BINDER_SET_MAX_THREADS</td>
<td>设置进程支持的最大线程数量</td>
<td style="text-align:center">size_t</td>
</tr>
<tr>
<td style="text-align:left">BINDER_SET_CONTEXT_MGR</td>
<td>设置自身为ServiceManager</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:left">BINDER_THREAD_EXIT</td>
<td>通知驱动Binder线程退出</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:left">BINDER_VERSION</td>
<td>获取Binder驱动的版本号</td>
<td style="text-align:center">binder_version</td>
</tr>
<tr>
<td style="text-align:left">BINDER_SET_IDLE_PRIORITY</td>
<td>暂未用到</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">BINDER_SET_IDLE_TIMEOUT</td>
<td>暂未用到</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>Binder的驱动协议描述了对于Binder驱动的具体使用过程。驱动协议又可以分为两类：</p>
<p>一类是binder_driver_command_protocol，描述了进程发送给Binder驱动的命令<br>一类是binder_driver_return_protocol，描述了Binder驱动发送给进程的命令<br>binder_driver_command_protocol共包含17个命令，分别是：</p>
<table>
<thead>
<tr>
<th style="text-align:left">结构体名称</th>
<th>说明</th>
<th style="text-align:center">参数类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">BC_TRANSACTION</td>
<td>Binder事务，即：Client对于Server的请求</td>
<td style="text-align:center">binder_transaction_data</td>
</tr>
<tr>
<td style="text-align:left">BC_REPLY</td>
<td>事务的应答，即：Server对于Client的回复</td>
<td style="text-align:center">binder_transaction_data</td>
</tr>
<tr>
<td style="text-align:left">BC_FREE_BUFFER</td>
<td>通知驱动释放Buffer</td>
<td style="text-align:center">binder_uintptr_t</td>
</tr>
<tr>
<td style="text-align:left">BC_ACQUIRE</td>
<td>强引用计数+1</td>
<td style="text-align:center">__u32</td>
</tr>
<tr>
<td style="text-align:left">BC_RELEASE</td>
<td>强引用计数-1</td>
<td style="text-align:center">__u32</td>
</tr>
<tr>
<td style="text-align:left">BC_INCREFS</td>
<td>弱引用计数+1</td>
<td style="text-align:center">__u32</td>
</tr>
<tr>
<td style="text-align:left">BC_DECREFS</td>
<td>弱引用计数-1    __u32</td>
</tr>
<tr>
<td style="text-align:left">BC_ACQUIRE_DONE</td>
<td>BR_ACQUIRE的回复</td>
<td style="text-align:center">binder_ptr_cookie</td>
</tr>
<tr>
<td style="text-align:left">BC_INCREFS_DONE</td>
<td>BR_INCREFS的回复</td>
<td style="text-align:center">binder_ptr_cookie</td>
</tr>
<tr>
<td style="text-align:left">BC_ENTER_LOOPER</td>
<td>通知驱动主线程ready</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:left">BC_REGISTER_LOOPER</td>
<td>通知驱动子线程ready</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:left">BC_EXIT_LOOPER</td>
<td>通知驱动线程已经退出</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:left">BC_REQUEST_DEATH_NOTIFICATION</td>
<td>请求接收死亡通知</td>
<td style="text-align:center">binder_handle_cookie</td>
</tr>
<tr>
<td style="text-align:left">BC_CLEAR_DEATH_NOTIFICATION</td>
<td>去除接收死亡通知</td>
<td style="text-align:center">binder_handle_cookie</td>
</tr>
<tr>
<td style="text-align:left">BC_DEAD_BINDER_DONE</td>
<td>已经处理完死亡通知</td>
<td style="text-align:center">binder_uintptr_t</td>
</tr>
<tr>
<td style="text-align:left">BC_ATTEMPT_ACQUIRE</td>
<td>暂未实现</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">BC_ACQUIRE_RESULT</td>
<td>暂未实现</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>binder_driver_return_protocol共包含18个命令，分别是：</p>
<table>
<thead>
<tr>
<th style="text-align:left">结构体名称</th>
<th>说明</th>
<th style="text-align:center">参数类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">BR_OK</td>
<td>操作完成</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:left">BR_NOOP</td>
<td>操作完成</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:left">BR_ERROR</td>
<td>发生错误</td>
<td style="text-align:center">__s32</td>
</tr>
<tr>
<td style="text-align:left">BR_TRANSACTION</td>
<td>通知进程收到一次Binder请求（Server端）</td>
<td style="text-align:center">binder_transaction_data</td>
</tr>
<tr>
<td style="text-align:left">BR_REPLY</td>
<td>通知进程收到Binder请求的回复（Client）</td>
<td style="text-align:center">binder_transaction_data</td>
</tr>
<tr>
<td style="text-align:left">BR_TRANSACTION_COMPLETE</td>
<td>驱动对于接受请求的确认回复</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:left">BR_FAILED_REPLY</td>
<td>告知发送方通信目标不存在</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:left">BR_SPAWN_LOOPER</td>
<td>通知Binder进程创建一个新的线程</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:left">BR_ACQUIRE</td>
<td>强引用计数+1请求</td>
<td style="text-align:center">binder_ptr_cookie</td>
</tr>
<tr>
<td style="text-align:left">BR_RELEASE</td>
<td>强引用计数-1请求</td>
<td style="text-align:center">binder_ptr_cookie</td>
</tr>
<tr>
<td style="text-align:left">BR_INCREFS</td>
<td>弱引用计数+1请求</td>
<td style="text-align:center">binder_ptr_cookie</td>
</tr>
<tr>
<td style="text-align:left">BR_DECREFS</td>
<td>若引用计数-1请求</td>
<td style="text-align:center">binder_ptr_cookie</td>
</tr>
<tr>
<td style="text-align:left">BR_DEAD_BINDER</td>
<td>发送死亡通知</td>
<td style="text-align:center">binder_uintptr_t</td>
</tr>
<tr>
<td style="text-align:left">BR_CLEAR_DEATH_NOTIFICATION_DONE</td>
<td>清理死亡通知完成</td>
<td style="text-align:center">binder_uintptr_t</td>
</tr>
<tr>
<td style="text-align:left">BR_DEAD_REPLY</td>
<td>告知发送方对方已经死亡</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:left">BR_ACQUIRE_RESULT</td>
<td>暂未实现</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">BR_ATTEMPT_ACQUIRE</td>
<td>暂未实现</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">BR_FINISHED</td>
<td>暂未实现</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>单独看上面的协议可能很难理解，这里我们以一次Binder请求过程来详细看一下Binder协议是如何通信的，就比较好理解了。</p>
<p>这幅图的说明如下：<br><a href="https://postimg.org/image/y3hdwwxpr/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/yt0699y9f/18-_Android-binder_transaction_ipc.jpg" alt="18-_Android-binder_transaction_ipc.jpg"></a></p>
<p>Binder是C/S架构的，通信过程牵涉到：Client，Server以及Binder驱动三个角色<br>Client对于Server的请求以及Server对于Client回复都需要通过Binder驱动来中转数据<br>BC_XXX命令是进程发送给驱动的命令<br>BR_XXX命令是驱动发送给进程的命令<br>整个通信过程由Binder驱动控制</p>
<h5 id="2-4、binder-open"><a href="#2-4、binder-open" class="headerlink" title="2.4、binder_open()"></a>2.4、binder_open()</h5><p>任何进程在使用Binder之前，都需要先通过open(“/dev/binder”)打开Binder设备。上文已经提到，用户空间的open系统调用对应了驱动中的binder_open函数。在这个函数，Binder驱动会为调用的进程做一些初始化工作。binder_open函数代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建进程对应的binder_proc对象</span></span><br><span class="line">	proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL); </span><br><span class="line">	<span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	get_task_struct(current);</span><br><span class="line">	proc-&gt;tsk = current;</span><br><span class="line">	<span class="comment">// 初始化binder_proc</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">	init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">	proc-&gt;default_priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁保护</span></span><br><span class="line">	binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">	binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">	<span class="comment">// 添加到全局列表binder_procs中</span></span><br><span class="line">	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">	proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">	filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">	binder_unlock(__func__);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Binder驱动中，通过binder_procs记录了所有使用Binder的进程。每个初次打开Binder设备的进程都会被添加到这个列表中的。</p>
<p>另外，请读者回顾一下上文介绍的Binder驱动中的几个关键结构体：</p>
<blockquote>
<p>binder_proc<br>binder_node<br>binder_thread<br>binder_ref<br>binder_buffer</p>
</blockquote>
<p>在实现过程中，为了便于查找，这些结构体互相之间都留有字段存储关联的结构。</p>
<p>下面这幅图描述了这里说到的这些内容：<br><a href="https://postimg.org/image/reaugcmi7/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/5f4ft55o3/19-_Android-binder_main_struct.png" alt="19-_Android-binder_main_struct.png"></a></p>
<h5 id="2-5、binder-mmap"><a href="#2-5、binder-mmap" class="headerlink" title="2.5、binder_mmap()"></a>2.5、binder_mmap()</h5><p>在打开Binder设备之后，进程还会通过mmap进行内存映射。mmap的作用有如下两个：</p>
<p>申请一块内存空间，用来接收Binder通信过程中的数据<br>对这块内存进行地址映射，以便将来访问<br>binder_mmap函数对应了mmap系统调用的处理，这个函数也是Binder驱动的精华所在（这里说的binder_mmap函数也包括其内部调用的binder_update_page_range函数，见下文）。</p>
<p>前文我们说到，使用Binder机制，数据只需要经历一次拷贝就可以了，其原理就在这个函数中。</p>
<p>binder_mmap这个函数中，会申请一块物理内存，然后在用户空间和内核空间同时对应到这块内存上。在这之后，当有Client要发送数据给Server的时候，只需一次，将Client发送过来的数据拷贝到Server端的内核空间指定的内存地址即可，由于这个内存地址在服务端已经同时映射到用户空间，因此无需再做一次复制，Server即可直接访问，整个过程如下图所示：<br><a href="https://postimg.org/image/h48fh2u1r/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/pmhvlf0kj/20-_Android-mmap_and_transaction.png" alt="20-_Android-mmap_and_transaction.png"></a></p>
<p>这幅图的说明如下：</p>
<p>Server在启动之后，调用对/dev/binder设备调用mmap<br>内核中的binder_mmap函数进行对应的处理：申请一块物理内存，然后在用户空间和内核空间同时进行映射<br>Client通过BINDER_WRITE_READ命令发送请求，这个请求将先到驱动中，同时需要将数据从Client进程的用户空间拷贝到内核空间<br>驱动通过BR_TRANSACTION通知Server有人发出请求，Server进行处理。由于这块内存也在用户空间进行了映射，因此Server进程的代码可以直接访问<br>了解原理之后，我们再来看一下Binder驱动的相关源码。这段代码有两个函数：</p>
<p>binder_mmap函数对应了mmap的系统调用的处理<br>binder_update_page_range函数真正实现了内存分配和地址映射</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">   <span class="comment">// 在内核空间获取一块地址范围</span></span><br><span class="line">	area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</span><br><span class="line">	<span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">"get_vm_area"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_get_vm_area_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	proc-&gt;buffer = area-&gt;addr;</span><br><span class="line">	<span class="comment">// 记录内核空间与用户空间的地址偏移</span></span><br><span class="line">	proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)proc-&gt;buffer;</span><br><span class="line">	mutex_unlock(&amp;binder_mmap_lock);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">	proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (proc-&gt;pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">"alloc page array"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_pages_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">	vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">	vma-&gt;vm_private_data = proc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* binder_update_page_range assumes preemption is disabled */</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	<span class="comment">// 通过下面这个函数真正完成内存的申请和地址的映射</span></span><br><span class="line">	<span class="comment">// 初次使用，先申请一个PAGE_SIZE大小的内存</span></span><br><span class="line">	ret = binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_update_page_range</span><span class="params">(struct binder_proc *proc, <span class="keyword">int</span> allocate,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">void</span> *start, <span class="keyword">void</span> *end,</span></span></span><br><span class="line"><span class="function"><span class="params">				    struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *page_addr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> user_page_addr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> <span class="title">tmp_area</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">		<span class="keyword">int</span> ret;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">page_array_ptr</span>;</span></span><br><span class="line">		page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</span><br><span class="line"></span><br><span class="line">		BUG_ON(*page);</span><br><span class="line">		<span class="comment">// 真正进行内存的分配</span></span><br><span class="line">		*page = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO);</span><br><span class="line">		<span class="keyword">if</span> (*page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			pr_err(<span class="string">"%d: binder_alloc_buf failed for page at %p\n"</span>,</span><br><span class="line">				proc-&gt;pid, page_addr);</span><br><span class="line">			<span class="keyword">goto</span> err_alloc_page_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp_area.addr = page_addr;</span><br><span class="line">		tmp_area.size = PAGE_SIZE + PAGE_SIZE <span class="comment">/* guard page? */</span>;</span><br><span class="line">		page_array_ptr = page;</span><br><span class="line">		<span class="comment">// 在内核空间进行内存映射</span></span><br><span class="line">		ret = map_vm_area(&amp;tmp_area, PAGE_KERNEL, &amp;page_array_ptr);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_err(<span class="string">"%d: binder_alloc_buf failed to map page at %p in kernel\n"</span>,</span><br><span class="line">			       proc-&gt;pid, page_addr);</span><br><span class="line">			<span class="keyword">goto</span> err_map_kernel_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		user_page_addr =</span><br><span class="line">			(<span class="keyword">uintptr_t</span>)page_addr + proc-&gt;user_buffer_offset;</span><br><span class="line">		<span class="comment">// 在用户空间进行内存映射</span></span><br><span class="line">		ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_err(<span class="string">"%d: binder_alloc_buf failed to map page at %lx in userspace\n"</span>,</span><br><span class="line">			       proc-&gt;pid, user_page_addr);</span><br><span class="line">			<span class="keyword">goto</span> err_vm_insert_page_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* vm_insert_page does not seem to increment the refcount */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mm) &#123;</span><br><span class="line">		up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		mmput(mm);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>binder_update_page_range主要完成工作：分配物理空间，将物理空间映射到内核空间，将物理空间映射到进程空间. 另外，不同参数下该方法也可以释放物理页面。<br><a href="https://postimg.org/image/dw3y4lsin/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/nteyxo04j/21-_Android-binder_mmap.png" alt="21-_Android-binder_mmap.png"></a></p>
<h5 id="2-6、binder-ioctl-内存管理"><a href="#2-6、binder-ioctl-内存管理" class="headerlink" title="2.6、binder_ioctl()内存管理"></a>2.6、binder_ioctl()内存管理</h5><p>上文中，我们看到binder_mmap的时候，会申请一个PAGE_SIZE(通常是4K)的内存。而实际使用过程中，一个PAGE_SIZE的大小通常是不够的。</p>
<p>在驱动中，会根据实际的使用情况进行内存的分配。有内存的分配，当然也需要内存的释放。这里我们就来看看Binder驱动中是如何进行内存的管理的。</p>
<p>首先，我们还是从一次IPC请求说起。</p>
<p>当一个Client想要对Server发出请求时，它首先将请求发送到Binder设备上，由Binder驱动根据请求的信息找到对应的目标节点，然后将请求数据传递过去。</p>
<p>进程通过ioctl系统调用来发出请求：ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)</p>
<p>这里的bs-&gt;fd对应了打开Binder设备时的fd。BINDER_WRITE_READ对应了具体要做的操作码，这个操作码将由Binder驱动解析。bwr存储了请求数据，其类型是binder_write_read。</p>
<p>binder_write_read其实是一个相对外层的数据结构，其内部会包含一个binder_transaction_data结构的数据。binder_transaction_data包含了发出请求者的标识，请求的目标对象以及请求所需要的参数。它们的关系如下图所示：<br><a href="https://postimg.org/image/emwo9whvz/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/jlk6ofloz/22-_Android-binder_write_read.png" alt="22-_Android-binder_write_read.png"></a></p>
<p>binder_ioctl函数对应了ioctl系统调用的处理。这个函数的逻辑比较简单，就是根据ioctl的命令来确定进一步处理的逻辑，具体如下:</p>
<p>● 如果命令是BINDER_WRITE_READ，并且<br>● 如果 bwr.write_size &gt; 0，则调用binder_thread_write<br>● 如果 bwr.read_size &gt; 0，则调用binder_thread_read<br>● 如果命令是BINDER_SET_MAX_THREADS，则设置进程的max_threads，即进程支持的最大线程数<br>● 如果命令是BINDER_SET_CONTEXT_MGR，则设置当前进程为ServiceManager，见下文<br>● 如果命令是BINDER_THREAD_EXIT，则调用binder_free_thread，释放binder_thread<br>● 如果命令是BINDER_VERSION，则返回当前的Binder版本号<br>这其中，最关键的就是binder_thread_write方法。当Client请求Server的时候，便会发送一个BINDER_WRITE_READ命令，同时框架会将将实际的数据包装好。此时，binder_transaction_data中的code将是BC_TRANSACTION，由此便会调用到binder_transaction方法，这个方法是对一次Binder事务的处理，这其中会调用binder_alloc_buf函数为此次事务申请一个缓存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="built_in">free</span>:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> allow_user_free:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> async_transaction:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> debug_id:<span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">transaction</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> data_size;</span><br><span class="line">	<span class="keyword">size_t</span> offsets_size;</span><br><span class="line">	<span class="keyword">uint8_t</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而在binder_proc（描述了使用Binder的进程）中，包含了几个字段用来管理进程在Binder IPC过程中缓存，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">buffers</span>;</span> <span class="comment">// 进程拥有的buffer列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">free_buffers</span>;</span> <span class="comment">// 空闲buffer列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">allocated_buffers</span>;</span> <span class="comment">// 已使用的buffer列表 </span></span><br><span class="line">	<span class="keyword">size_t</span> free_async_space; <span class="comment">// 剩余的异步调用的空间</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">size_t</span> buffer_size; <span class="comment">// 缓存的上限</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>进程在mmap时，会设定支持的总缓存大小的上限（下文会讲到）。而进程每当收到BC_TRANSACTION，就会判断已使用缓存加本次申请的和有没有超过上限。如果没有，就考虑进行内存的分配。</p>
<p>进程的空闲缓存记录在binder_proc的free_buffers中，这是一个以红黑树形式存储的结构。每次尝试分配缓存的时候，会从这里面按大小顺序进行查找，找到最接近需要的一块缓存。查找的逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line">	buffer = rb_entry(n, struct binder_buffer, rb_node);</span><br><span class="line">	BUG_ON(!buffer-&gt;<span class="built_in">free</span>);</span><br><span class="line">	buffer_size = binder_buffer_size(proc, buffer);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &lt; buffer_size) &#123;</span><br><span class="line">		best_fit = n;</span><br><span class="line">		n = n-&gt;rb_left;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; buffer_size)</span><br><span class="line">		n = n-&gt;rb_right;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		best_fit = n;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到之后，还需要对binder_proc中的字段进行相应的更新：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">rb_erase(best_fit, &amp;proc-&gt;free_buffers);</span><br><span class="line">buffer-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">binder_insert_allocated_buffer(proc, buffer);</span><br><span class="line"><span class="keyword">if</span> (buffer_size != size) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">new_buffer</span> = (<span class="title">void</span> *)<span class="title">buffer</span>-&gt;<span class="title">data</span> + <span class="title">size</span>;</span></span><br><span class="line">	list_add(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry);</span><br><span class="line">	new_buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">	binder_insert_free_buffer(proc, new_buffer);</span><br><span class="line">&#125;</span><br><span class="line">binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</span><br><span class="line">	     <span class="string">"%d: binder_alloc_buf size %zd got %p\n"</span>,</span><br><span class="line">	      proc-&gt;pid, size, buffer);</span><br><span class="line">buffer-&gt;data_size = data_size;</span><br><span class="line">buffer-&gt;offsets_size = offsets_size;</span><br><span class="line">buffer-&gt;async_transaction = is_async;</span><br><span class="line"><span class="keyword">if</span> (is_async) &#123;</span><br><span class="line">	proc-&gt;free_async_space -= size + <span class="keyword">sizeof</span>(struct binder_buffer);</span><br><span class="line">	binder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,</span><br><span class="line">		     <span class="string">"%d: binder_alloc_buf size %zd async free %zd\n"</span>,</span><br><span class="line">		      proc-&gt;pid, size, proc-&gt;free_async_space);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们再来看看内存的释放。</p>
<p>BC_FREE_BUFFER命令是通知驱动进行内存的释放，binder_free_buf函数是真正实现的逻辑，这个函数与binder_alloc_buf是刚好对应的。在这个函数中，所做的事情包括：</p>
<p>重新计算进程的空闲缓存大小<br>通过binder_update_page_range释放内存<br>更新binder_proc的buffers，free_buffers，allocated_buffers字段</p>
<h5 id="2-7、Binder中的“面向对象”"><a href="#2-7、Binder中的“面向对象”" class="headerlink" title="2.7、Binder中的“面向对象”"></a>2.7、<strong>Binder中的“面向对象”</strong></h5><p>Binder机制淡化了进程的边界，使得跨越进程也能够调用到指定服务的方法，其原因是因为Binder机制在底层处理了在进程间的“对象”传递。</p>
<p>在Binder驱动中，并不是真的将对象在进程间来回序列化，而是通过特定的标识来进行对象的传递。Binder驱动中，通过flat_binder_object来描述需要跨越进程传递的对象。其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span></span><br><span class="line">	__u32		type;</span><br><span class="line">	__u32		flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">binder_uintptr_t</span>	binder; <span class="comment">/* local object */</span></span><br><span class="line">		__u32			handle;	<span class="comment">/* remote object */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">binder_uintptr_t</span>	cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这其中，type有如下5种类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	BINDER_TYPE_BINDER	= B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_WEAK_BINDER	= B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_HANDLE	= B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_WEAK_HANDLE	= B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_FD		= B_PACK_CHARS(<span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当对象传递到Binder驱动中的时候，由驱动来进行翻译和解释，然后传递到接收的进程。</p>
<p>例如当Server把Binder实体传递给Client时，在发送数据流中，flat_binder_object中的type是BINDER_TYPE_BINDER，同时binder字段指向Server进程用户空间地址。但这个地址对于Client进程是没有意义的（Linux中，每个进程的地址空间是互相隔离的），驱动必须对数据流中的flat_binder_object做相应的翻译：将type该成BINDER_TYPE_HANDLE；为这个Binder在接收进程中创建位于内核中的引用并将引用号填入handle中。对于发生数据流中引用类型的Binder也要做同样转换。经过处理后接收进程从数据流中取得的Binder引用才是有效的，才可以将其填入数据包binder_transaction_data的target.handle域，向Binder实体发送请求。</p>
<p>由于每个请求和请求的返回都会经历内核的翻译，因此这个过程从进程的角度来看是完全透明的。进程完全不用感知这个过程，就好像对象真的在进程间来回传递一样。</p>
<h5 id="2-8、驱动层的线程管理"><a href="#2-8、驱动层的线程管理" class="headerlink" title="2.8、驱动层的线程管理"></a>2.8、<strong>驱动层的线程管理</strong></h5><p>上文多次提到，Binder本身是C/S架构。由Server提供服务，被Client使用。既然是C/S架构，就可能存在多个Client会同时访问Server的情况。 在这种情况下，如果Server只有一个线程处理响应，就会导致客户端的请求可能需要排队而导致响应过慢的现象发生。解决这个问题的方法就是引入多线程。</p>
<p>Binder机制的设计从最底层–驱动层，就考虑到了对于多线程的支持。具体内容如下：</p>
<p>使用Binder的进程在启动之后，通过BINDER_SET_MAX_THREADS告知驱动其支持的最大线程数量<br>驱动会对线程进行管理。在binder_proc结构中，这些字段记录了进程中线程的信息：max_threads，requested_threads，requested_threads_started，ready_threads<br>binder_thread结构对应了Binder进程中的线程<br>驱动通过BR_SPAWN_LOOPER命令告知进程需要创建一个新的线程<br>进程通过BC_ENTER_LOOPER命令告知驱动其主线程已经ready<br>进程通过BC_REGISTER_LOOPER命令告知驱动其子线程（非主线程）已经ready<br>进程通过BC_EXIT_LOOPER命令告知驱动其线程将要退出<br>在线程退出之后，通过BINDER_THREAD_EXIT告知Binder驱动。驱动将对应的binder_thread对象销毁</p>
<h5 id="2-9、再聊ServiceManager"><a href="#2-9、再聊ServiceManager" class="headerlink" title="2.9、再聊ServiceManager"></a>2.9、再聊ServiceManager</h5><p>上文已经说过，每一个Binder Server在驱动中会有一个binder_node进行对应。同时，Binder驱动会负责在进程间传递服务对象，并负责底层的转换。另外，我们也提到，每一个Binder服务都需要有一个唯一的名称。由ServiceManager来管理这些服务的注册和查找。</p>
<p>而实际上，为了便于使用，ServiceManager本身也实现为一个Server对象。任何进程在使用ServiceManager的时候，都需要先拿到指向它的标识。然后通过这个标识来使用ServiceManager。</p>
<p>这似乎形成了一个互相矛盾的现象：</p>
<p>通过ServiceManager我们才能拿到Server的标识<br>ServiceManager本身也是一个Server<br>解决这个矛盾的办法其实也很简单：Binder机制为ServiceManager预留了一个特殊的位置。这个位置是预先定好的，任何想要使用ServiceManager的进程只要通过这个特定的位置就可以访问到ServiceManager了（而不用再通过ServiceManager的接口）。</p>
<p>在Binder驱动中，有一个全局的binder_node 变量：</p>
<blockquote>
<p><strong>一般情况下，对于每一个Server驱动层会对应一个binder_node节点，然而binder_context_mgr_node比较特殊，它没有对应的应用层binder实体。在整个系统里，它是如此特殊，以至于系统规定，任何应用都必须使用句柄0来跨进程地访问它。</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">binder_context_mgr_node</span>;</span></span><br></pre></td></tr></table></figure>
<p>这个变量指向的就是ServiceManager。</p>
<p>当有进程通过ioctl并指定命令为BINDER_SET_CONTEXT_MGR的时候，驱动被认定这个进程是ServiceManager，binder_ioctl()函数中对应的处理如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">	<span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = security_binder_set_context_mgr(proc-&gt;tsk);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	binder_context_mgr_uid = current-&gt;cred-&gt;euid;</span><br><span class="line">	binder_context_mgr_node = binder_new_node(proc, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//在Binder驱动层创建binder_node结构体对象</span></span><br><span class="line">	binder_context_mgr_node-&gt;local_weak_refs++;</span><br><span class="line">	binder_context_mgr_node-&gt;local_strong_refs++;</span><br><span class="line">	binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">	binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>ServiceManager应当要先于所有Binder Server之前启动。在它启动完成并告知Binder驱动之后，驱动便设定好了这个特定的节点。</p>
<p>在这之后，当有其他模块想要使用ServerManager的时候，只要将请求指向ServiceManager所在的位置即可。</p>
<p>在Binder驱动中，通过handle = 0这个位置来访问ServiceManager。例如，binder_transaction中，判断如果target.handler为0，则认为这个请求是发送给ServiceManager的，相关代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">	ref = binder_get_ref(proc, tr-&gt;target.handle, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		binder_user_error(<span class="string">"%d:%d got transaction to invalid handle\n"</span>,</span><br><span class="line">			proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		<span class="keyword">goto</span> err_invalid_target_handle;</span><br><span class="line">	&#125;</span><br><span class="line">	target_node = ref-&gt;node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	target_node = binder_context_mgr_node;</span><br><span class="line">	<span class="keyword">if</span> (target_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return_error = BR_DEAD_REPLY;</span><br><span class="line">		<span class="keyword">goto</span> err_no_context_mgr_node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-10、binder-node等重要结构体"><a href="#2-10、binder-node等重要结构体" class="headerlink" title="2.10、binder_node等重要结构体"></a>2.10、binder_node等重要结构体</h5><blockquote>
<p>binder_proc<br>binder_node<br>binder_thread<br>binder_ref<br>binder_buffer</p>
</blockquote>
<p><strong>1. Binder实体binder_node </strong></p>
<p>Binder实体，是各个Server以及ServiceManager在内核中的存在形式。<br>Binder实体实际上是内核中binder_node结构体的对象，它的作用是在内核中保存Server和ServiceManager的信息(例如，Binder实体中保存了Server对象在用户空间的地址)。简言之，Binder实体是Server在Binder驱动中的存在形式，内核通过Binder实体可以找到用户空间的Server对象。<br>在上图中，Server和ServiceManager在Binder驱动中都对应的存在一个Binder实体。</p>
<p><a href="https://postimg.org/image/y4rbpru8f/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/xf8jdetoz/26-_Android-_Binder_node_struct.png" alt="26-_Android-_Binder_node_struct.png"></a></p>
<p><strong>2. Binder引用binder_ref </strong></p>
<p>说到Binder实体，就不得不说”Binder引用”。所谓Binder引用，实际上是内核中binder_ref结构体的对象，它的作用是在表示”Binder实体”的引用。换句话说，每一个Binder引用都是某一个Binder实体的引用，通过Binder引用可以在内核中找到它对应的Binder实体。<br>如果将Server看作是Binder实体的话，那么Client就好比Binder引用。Client要和Server通信，它就是通过保存一个Server对象的Binder引用，再通过该Binder引用在内核中找到对应的Binder实体，进而找到Server对象，然后将通信内容发送给Server对象。</p>
<p>Binder实体和Binder引用都是内核(即，Binder驱动)中的数据结构。每一个Server在内核中就表现为一个Binder实体，而每一个Client则表现为一个Binder引用。这样，每个Binder引用都对应一个Binder实体，而每个Binder实体则可以多个Binder引用。<br><a href="https://postimg.org/image/mseq7z63z/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/y4rbpresz/24-_Android-binder_ref.png" alt="24-_Android-binder_ref.png"></a></p>
<p><strong>3、Binder buffer：binder_buffer</strong><br><a href="https://postimg.org/image/stcf5al33/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/fp6uslt1f/99-_Android-_Binder-_IPCall.png" alt="99-_Android-_Binder-_IPCall.png"></a></p>
<p><strong>4、Binder进程binder_proc</strong> </p>
<p><a href="https://postimg.org/image/t63tb8ipr/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/64n85hj2b/25-_Android-binder_proc.png" alt="25-_Android-binder_proc.png"></a></p>
<p><strong>5、Binder线程binder_thread</strong><br><a href="https://postimg.org/image/emwo9vfb3/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/402v4g75v/27-_Android-binder_thread.png" alt="27-_Android-binder_thread.png"></a></p>
<p>binder机制到底是如何从Binder对象找到其对应的Binder实体呢？<br><a href="https://postimg.org/image/4plngscu7/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/jybkuk6ir/28-_Android-_Bp-_Bbinder.png" alt="28-_Android-_Bp-_Bbinder.png"></a></p>
<p>注意其中的那4个rb_root域，“rb”的意思是“red black”，可见binder_proc里搞出了4个红黑树。<br><a href="https://postimg.org/image/52d1mz2tr/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/r1jga6jo3/29-_Android-binder_proc_red_root.png" alt="29-_Android-binder_proc_red_root.png"></a></p>
<p>其中，nodes树用于记录binder实体，refs_by_desc树和refs_by_node树则用于记录binder代理。之所以会有两个代理树，是为了便于快速查找，我们暂时只关心其中之一就可以了。threads树用于记录执行传输动作的线程信息。</p>
<p>在一个进程中，有多少“被其他进程进行跨进程调用的”binder实体，就会在该进程对应的nodes树中生成多少个红黑树节点。另一方面，一个进程要访问多少其他进程的binder实体，则必须在其refs_by_desc树中拥有对应的引用节点。</p>
<p>这4棵树的节点类型是不同的，threads树的节点类型为binder_thread，nodes树的节点类型为binder_node，refs_by_desc树和refs_by_node树的节点类型相同，为binder_ref。这些节点内部都会包含rb_node子结构，该结构专门负责连接节点的工作，和前文的hlist_node有点儿异曲同工，这也是linux上一个常用的小技巧。我们以nodes树为例<br><a href="https://postimg.org/image/s3tmsqa73/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/52d1mzajn/30-_Android-binder_proc_hlist_node.png" alt="30-_Android-binder_proc_hlist_node.png"></a></p>
<p>nodes树是用于记录binder实体的，所以nodes树中的每个binder_node节点，必须能够记录下相应binder实体的信息。因此请大家注意binder_node的ptr域和cookie域。</p>
<p>另一方面，refs_by_desc树和refs_by_node树的每个binder_ref节点则和上层的一个BpBinder对应，而且更重要的是，它必须具有和“目标binder实体的binder_node”进行关联的信息。</p>
<p>请注意binder_ref的那个node域，它负责和binder_node关联。另外，binder_ref中有两个类型为rb_node的域：rb_node_desc域和rb_node_node域，它们分别用于连接refs_by_desc树和refs_by_node。也就是说虽然binder_proc中有两棵引用树，但这两棵树用到的具体binder_ref节点其实是复用的。</p>
<blockquote>
<p>binder_node.ptr对应于flat_binder_object.binder；<br>binder_node.cookie对应于flat_binder_object.cookie。</p>
</blockquote>
<p><a href="https://postimg.org/image/52d1mzxov/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/xrzxjn1oz/31-_Android-binder_ref-find-binder_node.png" alt="31-_Android-binder_ref-find-binder_node.png"></a><br>上图只表示了从进程1向进程2发起跨进程传输的意思，其实反过来也是可以的，即进程2也可以通过自己的“引用树”节点找到进程1的“实体树”节点，并进行跨进程传输。</p>
<p>OK，现在我们可以更深入地说明binder句柄的作用了，比如进程1的BpBinder在发起跨进程调用时，向binder驱动传入了自己记录的句柄值，binder驱动就会在“进程1对应的binder_proc结构”的引用树中查找和句柄值相符的binder_ref节点，一旦找到binder_ref节点，就可以通过该节点的node域找到对应的binder_node节点，这个目标binder_node当然是从属于进程2的binder_proc啦，不过不要紧，因为binder_ref和binder_node都处于binder驱动的地址空间中，所以是可以用指针直接指向的。目标binder_node节点的cookie域，记录的其实是进程2中BBinder的地址，binder驱动只需把这个值反映给应用层，应用层就可以直接拿到BBinder了。这就是Binder完成精确打击的大体过程。</p>
<p><a href="https://postimg.org/image/adry7prhb/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/9bhrp68o3/32-_Android-binder_relationship.jpg" alt="32-_Android-binder_relationship.jpg"></a></p>
<h3 id="三、Android-Binder系统驱动情景分析"><a href="#三、Android-Binder系统驱动情景分析" class="headerlink" title="三、Android Binder系统驱动情景分析"></a>三、Android Binder系统驱动情景分析</h3><p>为了更深刻的了解Binder系统 注册服务、获取服务、使用服务的过程，在Driver层(kernel/drivers/staging/android/binder.c)的binder_thread_read()函数、binder_transaction()函数入打印log，让前面编写的C程序示例与binder驱动交互打印更详细的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/weidongshan/DRV_0003_Binder/" target="_blank" rel="noopener">已添加好打印log的binder.c文件见GitHub（注：搜索[/* print] 关键字）</a><br>事先已经准备好打印log，现在结合log和Binder事务处理开始详细分析。注：log稍后分析再贴出。<br><a href="https://postimg.org/image/6hembpjcf/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/yhipvzmsz/33-_Android-binder_transaction_ipc.jpg" alt="33-_Android-binder_transaction_ipc.jpg"></a></p>
<h4 id="（1）、Binder系统驱动情景分析—服务“Hello”注册过程"><a href="#（1）、Binder系统驱动情景分析—服务“Hello”注册过程" class="headerlink" title="（1）、Binder系统驱动情景分析—服务“Hello”注册过程"></a>（1）、Binder系统驱动情景分析—服务“Hello”注册过程</h4><p><a href="https://postimg.org/image/8yqdj6t0v/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/7josugrxv/35-_Android-binder-add_service.png" alt="35-_Android-binder-add_service.png"></a></p>
<h5 id="1-1、ServiceManager休眠等待"><a href="#1-1、ServiceManager休眠等待" class="headerlink" title="1.1、ServiceManager休眠等待"></a>1.1、ServiceManager休眠等待</h5><p>回顾一下ServiceManager启动流程，ServiceManager进入binder_loop()后<br>会休眠等待响应client请求。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">binder_loop()&#123;</span><br><span class="line">    <span class="comment">// 告诉Kernel，ServiceManager进程进入了消息循环状态。</span></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line">   </span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向Kernel中发送消息(先写后读)。</span></span><br><span class="line">        <span class="comment">// 先将消息传递给Kernel，然后再从Kernel读取消息反馈</span></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">        <span class="comment">// 解析读取的消息反馈</span></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> binder_write(bs, readbuf, sizeof(unsigned));会调用ioctl向内核发送数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">binder_write</span><span class="params">(struct binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = len;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>) data;</span><br><span class="line">    bwr.read_size = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果 bwr.write_size &gt; 0，则调用binder_thread_write<br>如果 bwr.read_size &gt;0，则调用binder_thread_read</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">  <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中断等待函数。</span></span><br><span class="line">  ret = wait_event_interruptible(...);</span><br><span class="line">  <span class="comment">// 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。</span></span><br><span class="line">  thread = binder_get_thread(proc);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">  <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 将binder_write_read从"用户空间" 拷贝到 "内核空间"</span></span><br><span class="line">      <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果write_size&gt;0，则进行写操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果read_size&gt;0，则进行读操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bwr.write_size &gt; 0; 继续查看binder_thread_write()</p>
<blockquote>
<p> 注：只有BR_TRANSACTION、BR_REPLY、BC_TRANSACTION、BC_REPLY涉及两进程<br>其他所有BC_XXX、BR_XXX都只是App和驱动交互用于改变报告状态。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取binder_write_read.write_buffer中的内容。</span></span><br><span class="line">  <span class="comment">// 每次读取32bit(即4个字节)</span></span><br><span class="line">  <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">      <span class="comment">// 从用户空间读取32bit到内核中，并赋值给cmd。</span></span><br><span class="line">      <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">      <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:</span><br><span class="line">			thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">      *consumed = ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前线程进入BC_ENTER_LOOPER状态，等待请求。<br>继续binder_loop()中的for(;;;)循环，bwr.read_size &gt;0;会通过binder_thread_read()读操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line">  <span class="comment">// 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区</span></span><br><span class="line">  <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line">      <span class="comment">// 修改指针位置</span></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到驱动put_user(BR_NOOP, (uint32_t __user *)ptr)发送BR_NOOP到ServiceManager</p>
<blockquote>
<p>对于所有的读操作，数据头都是BR_NOOP，如BR_REPLY<br><a href="https://postimg.org/image/jlk6of69b/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/xf8jdgyur/36-_Android-binder-_BWR-read-_BR_NOOP.png" alt="36-_Android-binder-_BWR-read-_BR_NOOP.png"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ./service_manager &amp;</span><br><span class="line">[   32.566620] service_manager (1362, 1362), binder_thread_write : BC_ENTER_LOOPER</span><br><span class="line">[   32.566712] service_manager (1362, 1362), binder_thread_read : BR_NOOP</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="1-2、Clent（此处为Test-server）请求SM添加服务"><a href="#1-2、Clent（此处为Test-server）请求SM添加服务" class="headerlink" title="1.2、Clent（此处为Test_server）请求SM添加服务"></a>1.2、Clent（此处为Test_server）请求SM添加服务</h5><p><strong>构造数据发送给驱动</strong><br>我们执行Test_server时，打印了很多数据，我们首先看一下数据的构造过程 和 组织格式，这有助于加深我们对binder系统的理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svcmgr_publish</span><span class="params">(struct binder_state *bs, <span class="keyword">uint32_t</span> target, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">unsigned</span> iodata[<span class="number">512</span>/<span class="number">4</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>, <span class="title">reply</span>;</span></span><br><span class="line"></span><br><span class="line">    bio_init(&amp;msg, iodata, <span class="keyword">sizeof</span>(iodata), <span class="number">4</span>);</span><br><span class="line">    bio_put_uint32(&amp;msg, <span class="number">0</span>);  <span class="comment">// strict mode header</span></span><br><span class="line">    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);</span><br><span class="line">    bio_put_string16_x(&amp;msg, name);</span><br><span class="line">    bio_put_obj(&amp;msg, ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    status = bio_get_uint32(&amp;reply);</span><br><span class="line">    binder_done(bs, &amp;msg, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bio_init()、bio_put_uint32()、bio_put_string16_x()函数比较简洁。我们看下bio_put_obj()函数。<br>构建初始化flat_binder_object结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void bio_put_obj(struct binder_io *bio, void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    struct flat_binder_object *obj;</span><br><span class="line"></span><br><span class="line">    obj = bio_alloc_obj(bio);</span><br><span class="line">    if (!obj)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    obj-&gt;flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;//</span><br><span class="line">    obj-&gt;type = BINDER_TYPE_BINDER;//</span><br><span class="line">    obj-&gt;binder = (uintptr_t)ptr;//</span><br><span class="line">    obj-&gt;cookie = 0;//0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>数据结构示意图：</strong></p>
<p><a href="https://postimg.org/image/9o95vegnz/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/s3tmssusj/37-_Android-binder-_Binder-io-transaction-data.jpg" alt="37-_Android-binder-_Binder-io-transaction-data.jpg"></a></p>
<p>Clent（此处为Test_server），test_server.c调用流程：<br>-&gt;svcmgr_publish()<br>-&gt;binder_call()<br>-&gt;ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)<br>-&gt;binder_thread_write()<br>-&gt;binder_transaction()</p>
<p>现在数据构造好了，binder_call()会调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_call</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_io *msg, struct binder_io *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">uint32_t</span> target, <span class="keyword">uint32_t</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">txn</span>;</span></span><br><span class="line">    &#125; __attribute__((packed)) writebuf;</span><br><span class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line">    </span><br><span class="line">    writebuf.cmd = BC_TRANSACTION;</span><br><span class="line">    writebuf.txn.target.handle = target;</span><br><span class="line">    writebuf.txn.code = code;</span><br><span class="line">    writebuf.txn.flags = <span class="number">0</span>;</span><br><span class="line">    writebuf.txn.data_size = msg-&gt;data - msg-&gt;data0;</span><br><span class="line">    writebuf.txn.offsets_size = ((<span class="keyword">char</span>*) msg-&gt;offs) - ((<span class="keyword">char</span>*) msg-&gt;offs0);</span><br><span class="line">    writebuf.txn.data.ptr.buffer = (<span class="keyword">uintptr_t</span>)msg-&gt;data0;</span><br><span class="line">    writebuf.txn.data.ptr.offsets = (<span class="keyword">uintptr_t</span>)msg-&gt;offs0;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="keyword">sizeof</span>(writebuf);</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>) &amp;writebuf;</span><br><span class="line"></span><br><span class="line">    hexdump(msg-&gt;data0, msg-&gt;data - msg-&gt;data0);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">        ...</span><br><span class="line">        res = binder_parse(bs, reply, (<span class="keyword">uintptr_t</span>) readbuf, bwr.read_consumed, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[   38.320197] test_server (1363, 1363), binder_thread_write : BC_TRANSACTION<br>发送数据，进而会调用binder_thread_write()处理数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">binder_ioctl(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">  <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中断等待函数。</span></span><br><span class="line">  ret = wait_event_interruptible(...);</span><br><span class="line">  <span class="comment">// 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。</span></span><br><span class="line">  thread = binder_get_thread(proc);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">  <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 将binder_write_read从"用户空间" 拷贝到 "内核空间"</span></span><br><span class="line">      <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果write_size&gt;0，则进行写操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果read_size&gt;0，则进行读操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于write_size&gt;0，调用binder_thread_write()处理数据：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取binder_write_read.write_buffer中的内容。</span></span><br><span class="line">  <span class="comment">// 每次读取32bit(即4个字节)</span></span><br><span class="line">  <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">      <span class="comment">// 从用户空间读取32bit到内核中，并赋值给cmd。</span></span><br><span class="line">      <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">      ...</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">      *consumed = ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由之前binder_call()分析，writebuf.cmd = BC_TRANSACTION;会执行binder_transaction()函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">            target_node = ref-&gt;node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 事务目标对象是ServiceManager的binder实体</span></span><br><span class="line">            <span class="comment">// 即，该事务是交给Service Manager来处理的。</span></span><br><span class="line">            target_node = binder_context_mgr_node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置处理事务的目标进程</span></span><br><span class="line">        target_proc = target_node-&gt;proc;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target_list = &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待处理的事务t，t是binder事务(binder_transaction对象)</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    <span class="comment">// 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。</span></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务将交给target_proc进程进行处理</span></span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    <span class="comment">// 事务将交给target_thread线程进行处理</span></span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间,从目的进程映射的空间分配buf</span></span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 保存事务</span></span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    <span class="comment">// 保存事务的目标对象(即处理该事务的binder对象)</span></span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line"></span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将"用户空间的数据"拷贝到内核中</span></span><br><span class="line">    <span class="comment">// tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将"用户空间的数据中所含对象的偏移地址"拷贝到内核中</span></span><br><span class="line">    <span class="comment">// tr-&gt;data.ptr.offsets就是数据中的对象偏移地址数组，tr-&gt;offsets_size就数据中的对象个数</span></span><br><span class="line">    <span class="comment">// 拷贝之后，offp就是flat_binder_object对象数组在内核空间的偏移数组的起始地址</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// off_end就是flat_binder_object对象数组在内核空间的偏移地址的结束地址</span></span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line">    <span class="comment">// 将所有的flat_binder_object对象读取出来</span></span><br><span class="line">    <span class="comment">// 对TestServer而言，只有一个flat_binder_object对象。</span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line">        ...</span><br><span class="line">        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">            <span class="comment">// 在proc中查找binder实体对应的binder_node</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> = <span class="title">binder_get_node</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">binder</span>);</span></span><br><span class="line">            <span class="comment">// 若找不到，则新建一个binder_node；下次就可以直接使用了。</span></span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 在target_proc(即，ServiceManager的进程上下文)中查找是否包行"该Binder实体的引用"，</span></span><br><span class="line">            <span class="comment">// 如果没有找到的话，则将"该binder实体的引用"添加到target_proc-&gt;refs_by_node红黑树中。这样，就可以通过Service Manager对该</span></span><br><span class="line">Binder实体进行管理了。</span><br><span class="line">            ref = binder_get_ref_for_node(target_proc, node);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在修改目的进程type，表示ServiceManager持有TestServer引用，TestServer进程才能拥有实体。</span></span><br><span class="line">            <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</span><br><span class="line">                fp-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">            <span class="comment">// 修改handle。handle和binder是联合体，这里将handle设为引用的描述。</span></span><br><span class="line">            <span class="comment">// 根据该handle可以找到"该binder实体在target_proc中的binder引用"；</span></span><br><span class="line">            <span class="comment">// 即，可以根据该handle，可以从Service Manager找到对应的Binder实体的引用，从而获取Binder实体。</span></span><br><span class="line">            fp-&gt;handle = ref-&gt;desc;</span><br><span class="line">            <span class="comment">// 增加引用计数，防止"该binder实体"在使用过程中被销毁。</span></span><br><span class="line">            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,</span><br><span class="line">                       &amp;thread-&gt;todo);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ..</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">        t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">        <span class="comment">// 将当前事务添加到当前线程的事务栈中</span></span><br><span class="line">        thread-&gt;transaction_stack = t;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置事务的类型为BINDER_WORK_TRANSACTION</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    <span class="comment">// 将事务添加到target_list队列中，即target_list的待处理事务中</span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    <span class="comment">// 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE</span></span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    <span class="comment">// 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。</span></span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 唤醒目标进程</span></span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：这里的tr-&gt;target.handle=0，因此，会设置target_node为ServiceManager对应的Binder实体。下面是target_node,target_proc等值初始化之后的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target_node = binder_context_mgr_node; <span class="comment">// 目标节点为Service Manager对应的Binder实体</span></span><br><span class="line">target_proc = target_node-&gt;proc;       <span class="comment">// 目标进程为Service Manager对应的binder_proc进程上下文信息</span></span><br><span class="line">target_list = &amp;target_thread-&gt;todo;    <span class="comment">// 待处理事务队列</span></span><br><span class="line">target_wait = &amp;target_thread-&gt;wait;    <span class="comment">// 等待队列</span></span><br></pre></td></tr></table></figure>
<p>小结：<br>驱动接收到TestServer发送的数据后，驱动主要工作：<br>（1）根据Handle = 0 找到目的进程ServiceManager<br>（2）把数据通过copy_from_user()放到目的进程ServiceManager的空间（mmap）<br>（3）处理offs数据，即解析flat_binder_object结构体<br>a. 为TestServer构造binder_node<br>   node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);<br>b.构造binder_ref给目的进程ServiceManager<br>ref = binder_get_ref_for_node(target_proc, node);<br>c.增加引用计数TestServer<br>binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,<br>                       &amp;thread-&gt;todo);<br> 增加引用计数会添加work.entry（BR_INCREFS、BR_ACQUIR）到TestServer todod队列<br>list_add_tail(&amp;node-&gt;work.entry, target_list)</p>
<p>说明：就新建Binder实体的引用，并将其添加到target_proc-&gt;refs_by_node红黑树 和 target_proc-&gt;refs_by_desc红黑树中。 这样，ServiceManager的进程上下文中就存在Hello Service的Binder引用，ServiceManager也就可以对Hello Service进行管理了！然后，修改fp-&gt;type=BINDER_TYPE_HANDLE，并使fp-&gt;handle = ref-&gt;desc。</p>
<p>（4)新建一个待处理事务t和待完成的工作tcomplete，并对它们进行初始化。待处理事务t会被提交给目标(即ServiceManager对应的Binder实体)进行处理；而待完成的工作tcomplete则是为了反馈给TestServer服务，告诉TestServer它的请求Binder驱动已经收到了。注意，这里仅仅是告诉TestServer该请求已经被收到，而不是处理完毕！待ServiceManager处理完毕该请求之后，Binder驱动会再次反馈相应的消息给TestServer。<br>（5）binder_thread_write()中执行binder_transaction()后，会更新*consumed的值，即bwr.write_consumed的值<br>（6）此时，TestServer进程还会继续运行，而且它也通过wake_up_interruptible()唤醒了ServiceManager进程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">*consumed = ptr - buffer;</span><br></pre></td></tr></table></figure>
<p>接下来，ioctl()会执行binder_thread_read()来设置反馈数据给TestServer进程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区</span></span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程的"待完成工作"不为空，则取出待完成工作。</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123;</span><br><span class="line">            cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">            <span class="comment">// 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中</span></span><br><span class="line">            <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 更新bwr.read_consumed的值</span></span><br><span class="line">    *consumed = ptr - buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先发送BR_NOOP给TestServer，然后处理todo队列，处理完成后会发送BR_TRANSACTION_COMPLETE。</p>
<p>现在内核已经处理完数据，我们从log看看数据发生了哪些变化：<br>我们发现flat_binder_object结构体的type值发生了变化，binder变成了Handle，看一下结构体，handler 和 binder是一个union，占用同一个位置；Handle为1代表第一个引用，意思是在ServiceManager进程里面根据1能找到第一个binder_ref，根据binder_ref能找到服务hello的binder_node实体。<br><a href="https://postimg.org/image/5rvtze0tb/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/y4rbpumjn/38-_Android-binder-flat_binder_object.png" alt="38-_Android-binder-flat_binder_object.png"></a></p>
<p><a href="https://postimg.org/image/52d1n22un/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/402v4ik1f/39-_Android-binder-_Binder-io-transaction-data.jpg" alt="39-_Android-binder-_Binder-io-transaction-data.jpg"></a></p>
<p>接下来就等待ServiceManager处理完成后，回复消息。</p>
<h5 id="1-3、唤醒ServiceManager执行添加“hello”服务"><a href="#1-3、唤醒ServiceManager执行添加“hello”服务" class="headerlink" title="1.3、唤醒ServiceManager执行添加“hello”服务"></a>1.3、唤醒ServiceManager执行添加“hello”服务</h5><p>前面驱动已经创建好TestServer的binder_node，现在唤醒ServiceManager添加svcinfo<br>看看ServiceManager被唤醒后，会干些什么。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">				list_empty(&amp;thread-&gt;todo);</span><br><span class="line">				</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程的"待完成工作"不为空，则取出待完成工作。</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_TRANSACTION: &#123;</span><br><span class="line">                t = container_of(w, struct binder_transaction, work);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// t-&gt;buffer-&gt;target_node是目标节点。</span></span><br><span class="line">        <span class="comment">// 这里，addService请求的目标是ServiceManager，因此target_node是ServiceManager对应的节点；</span></span><br><span class="line">        <span class="comment">// 它的值在事务交互时(binder_transaction中)，被赋值为ServiceManager对应的Binder实体。  </span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">            <span class="comment">// 事务目标对应的Binder实体(即，ServiceManager对应的Binder实体)</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">t</span>-&gt;<span class="title">buffer</span>-&gt;<span class="title">target_node</span>;</span></span><br><span class="line">            <span class="comment">// Binder实体在用户空间的地址(ServiceManager的ptr为NULL)</span></span><br><span class="line">            tr.target.ptr = target_node-&gt;ptr;</span><br><span class="line">            <span class="comment">// Binder实体在用户空间的其它数据(ServiceManager的cookie为NULL)</span></span><br><span class="line">            tr.cookie =  target_node-&gt;cookie;</span><br><span class="line">            t-&gt;saved_priority = task_nice(current);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;</span><br><span class="line">                !(t-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">                binder_set_nice(t-&gt;priority);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY) ||</span><br><span class="line">                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)</span><br><span class="line">                binder_set_nice(target_node-&gt;min_priority);</span><br><span class="line">            **cmd = BR_TRANSACTION;<span class="comment">//将命令改为BR_TRANSACTION</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tr.target.ptr = <span class="literal">NULL</span>;</span><br><span class="line">            tr.cookie = <span class="literal">NULL</span>;</span><br><span class="line">            cmd = BR_REPLY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交易码</span></span><br><span class="line">        tr.code = t-&gt;code;</span><br><span class="line">        tr.flags = t-&gt;flags;</span><br><span class="line">        tr.sender_euid = t-&gt;sender_euid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;from) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">sender</span> = <span class="title">t</span>-&gt;<span class="title">from</span>-&gt;<span class="title">proc</span>-&gt;<span class="title">tsk</span>;</span></span><br><span class="line">            tr.sender_pid = task_tgid_nr_ns(sender,</span><br><span class="line">                            current-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据大小</span></span><br><span class="line">        tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">        <span class="comment">// 数据中对象的偏移数组的大小(即对象的个数)</span></span><br><span class="line">        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">        <span class="comment">// 数据</span></span><br><span class="line">        tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data +</span><br><span class="line">                    proc-&gt;user_buffer_offset;</span><br><span class="line">        <span class="comment">// 数据中对象的偏移数组</span></span><br><span class="line">        tr.data.ptr.offsets = tr.data.ptr.buffer +</span><br><span class="line">                    ALIGN(t-&gt;buffer-&gt;data_size,</span><br><span class="line">                        <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将cmd指令写入到ptr，即传递到用户空间</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="comment">// 将tr数据拷贝到用户空间</span></span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 删除已处理的事务</span></span><br><span class="line">        list_del(&amp;t-&gt;work.entry);</span><br><span class="line">        t-&gt;buffer-&gt;allow_user_free = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置回复信息</span></span><br><span class="line">        <span class="keyword">if</span> (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">            <span class="comment">// 该事务会发送给Service Manager守护进程进行处理。</span></span><br><span class="line">            <span class="comment">// Service Manager处理之后，还需要给Binder驱动回复处理结果。</span></span><br><span class="line">            <span class="comment">// 这里设置Binder驱动回复信息。</span></span><br><span class="line">            t-&gt;to_parent = thread-&gt;transaction_stack;</span><br><span class="line">            <span class="comment">// to_thread表示Service Manager反馈后，将反馈结果交给当前thread进行处理</span></span><br><span class="line">            t-&gt;to_thread = thread;</span><br><span class="line">            <span class="comment">// transaction_stack交易栈保存当前事务。用于之处反馈是针对哪个事务的。</span></span><br><span class="line">            thread-&gt;transaction_stack = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新bwr.read_consumed的值</span></span><br><span class="line">    *consumed = ptr - buffer;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：ServiceManager进程在调用wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread))进入等待之后，被TestServer进程唤醒。唤醒之后，binder_has_thread_work()为true，因为ServiceManager的待处理事务队列中有个待处理事务(即，TestServer添加服务的请求)。<br>(01) 进入while循环后，首先取出待处理事务。<br>(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction*类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让ServiceManager读取后进行处理。</p>
<p>Service Manager守护进程在处理完事务之后，需要反馈结果给Binder驱动。因此，接下来会设置t-&gt;to_thread和t-&gt;transaction_stack等成员。最后，修改*consumed的值，即bwr.read_consumed的值，表示待读取内容的大小。<br>执行完binder_thread_read()之后，回到binder_ioctl()中，执行copy_to_user()将数据拷贝到用户空间。接下来，就回到了Service Manager的守护进程当中，即回到binder_loop()中。<br>binder_loop()会将ioctl()反馈的数据发送给binder_parse()进行解析。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_parse</span><span class="params">(struct binder_state *bs, struct binder_io *bio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">uintptr_t</span> ptr, <span class="keyword">size_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_NOOP:</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">txn</span> = (<span class="title">struct</span> <span class="title">binder_transaction_data</span> *) <span class="title">ptr</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) &lt; <span class="keyword">sizeof</span>(*txn)) &#123;</span><br><span class="line">                ALOGE(<span class="string">"parse: txn too small!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先会调用svcmgr_handler()-&gt;do_add_service()<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">uint16_t</span> *s, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint32_t</span> handle, <span class="keyword">uid_t</span> uid, <span class="keyword">int</span> allow_isolated,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">pid_t</span> spid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line">    <span class="keyword">if</span> (si) &#123;</span><br><span class="line">        <span class="keyword">if</span> (si-&gt;handle) &#123;</span><br><span class="line">                    svcinfo_death(bs, si);</span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">        si-&gt;len = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        si-&gt;name[len] = <span class="string">'\0'</span>;</span><br><span class="line">        si-&gt;death.func = (<span class="keyword">void</span>*) svcinfo_death;</span><br><span class="line">        si-&gt;death.ptr = si;</span><br><span class="line">        si-&gt;allow_isolated = allow_isolated;</span><br><span class="line">        si-&gt;next = svclist;</span><br><span class="line">        svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_acquire(bs, handle);</span><br><span class="line">    binder_link_to_death(bs, handle, &amp;si-&gt;death);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到首先为hello服务新分配一个结构体svcinfo，然后将handle赋值给svcinfo，这也是以后我们查找服务所得到的handle。<br>然后调动了binder_acquire、binder_link_to_death发送信息给驱动。<br>[   38.467270] service_manager (1362, 1362), binder_thread_write : BC_ACQUIRE<br>[   38.480122] service_manager (1362, 1362), binder_thread_write : BC_REQUEST_DEATH_NOTIFICATION<br>接着看binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_send_reply</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct binder_io *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">binder_uintptr_t</span> buffer_to_free,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    data.cmd_free = BC_FREE_BUFFER;</span><br><span class="line">    data.buffer = buffer_to_free;</span><br><span class="line">    data.cmd_reply = BC_REPLY;</span><br><span class="line">    data.txn.target.ptr = <span class="number">0</span>;</span><br><span class="line">    data.txn.cookie = <span class="number">0</span>;</span><br><span class="line">    data.txn.code = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    binder_write(bs, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到有BC_FREE_BUFFER、BC_REPLY，通过binder_write(bs, &amp;data, sizeof(data))回复BC_REPLY到驱动。</p>
<p>驱动处理消息跟之前流程类似，这里不再分析。简单总结：<br>1、驱动接收到BC_REPLY请求，会新建一个待处理事务t（TestServer处理）和待完成的工作tcomplete（service_manager处理）<br>2、然后唤醒TestServer处理BC_REPLY请求<br>至此，已经成功添加Hello Service<br>svcmgr: add_service(‘hello’), handle = 1</p>
<h4 id="（2）、Binder系统驱动情景分析—TestClent获取“Hello”服务过程"><a href="#（2）、Binder系统驱动情景分析—TestClent获取“Hello”服务过程" class="headerlink" title="（2）、Binder系统驱动情景分析—TestClent获取“Hello”服务过程"></a>（2）、Binder系统驱动情景分析—TestClent获取“Hello”服务过程</h4><p><a href="https://postimg.org/image/p9qhfg82n/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/3nbgyf9ib/40-_Android-binder-binder_get_service.png" alt="40-_Android-binder-binder_get_service.png"></a></p>
<h5 id="2-0、构造数据"><a href="#2-0、构造数据" class="headerlink" title="2.0、构造数据"></a>2.0、构造数据</h5><p><a href="https://postimg.org/image/a10k1ledb/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/xf8jdiwar/41-_Android-binder-get_Svr-_Binder-io-transaction-data.jpg" alt="41-_Android-binder-get_Svr-_Binder-io-transaction-data.jpg"></a></p>
<h5 id="2-1、发送数据给ServiceManager"><a href="#2-1、发送数据给ServiceManager" class="headerlink" title="2.1、发送数据给ServiceManager"></a>2.1、发送数据给ServiceManager</h5><p>bwr初始化完成之后，调用ioctl(,BINDER_WRITE_READ,)和Binder驱动进行交互。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">  <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">  <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">      <span class="comment">// 将binder_write_read从"用户空间" 拷贝到 "内核空间"</span></span><br><span class="line">      <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果write_size&gt;0，则进行写操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果read_size&gt;0，则进行读操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">          ret = -EFAULT;</span><br><span class="line">          <span class="keyword">goto</span> err;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，会将binder_write_read从用户空间拷贝到内核空间之后。拷贝之后，读取出来的bwr.write_size和bwr.read_size都&gt;0，因此先写后读。即，先执行binder_thread_write()，然后执行binder_thread_read()。</p>
<h5 id="2-2、binder-thread-write-处理数据"><a href="#2-2、binder-thread-write-处理数据" class="headerlink" title="2.2、binder_thread_write()处理数据"></a>2.2、binder_thread_write()处理数据</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取binder_write_read.write_buffer中的内容。</span></span><br><span class="line">  <span class="comment">// 每次读取32bit(即4个字节)</span></span><br><span class="line">  <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">      <span class="comment">// 从用户空间读取32bit到内核中，并赋值给cmd。</span></span><br><span class="line">      <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">      ...</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">      *consumed = ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：MediaPlayer发送的指令是BC_TRANSACTION，这里只关心与BC_TRANSACTION相关的部分。在通过copy_from_user()将数据拷贝从用户空间拷贝到内核空间之后，就调用binder_transaction()进行处理。</p>
<h5 id="2-3、Binder驱动中binder-transaction-的源码"><a href="#2-3、Binder驱动中binder-transaction-的源码" class="headerlink" title="2.3、Binder驱动中binder_transaction()的源码"></a>2.3、Binder驱动中binder_transaction()的源码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该getService是从ServiceManager中获取MediaPlayer；</span></span><br><span class="line">            <span class="comment">// 因此事务目标对象是ServiceManager的binder实体。</span></span><br><span class="line">            target_node = binder_context_mgr_node;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 设置处理事务的目标进程</span></span><br><span class="line">        target_proc = target_node-&gt;proc;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target_list = &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待处理的事务t，t是binder事务(binder_transaction对象)</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。</span></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    t-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置from，表示该事务是MediaPlayer线程发起的</span></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 下面的一些赋值是初始化事务t</span></span><br><span class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</span><br><span class="line">    <span class="comment">// 事务将交给target_proc进程进行处理</span></span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    <span class="comment">// 事务将交给target_thread线程进行处理</span></span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    <span class="comment">// 事务编码</span></span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    <span class="comment">// 事务标志</span></span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    <span class="comment">// 事务优先级</span></span><br><span class="line">    t-&gt;priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    ...</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    <span class="comment">// 保存事务</span></span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    <span class="comment">// 保存事务的目标对象(即处理该事务的binder对象)</span></span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">    trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将"用户空间的数据"拷贝到内核中</span></span><br><span class="line">    <span class="comment">// tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将"用户空间的数据中所含对象的偏移地址"拷贝到内核中</span></span><br><span class="line">    <span class="comment">// MediaPlayer中不包含对象, offp=null</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// MediaPlayer中不包含对象, off_end为null</span></span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line">    <span class="comment">// MediaPlayer中不包含对象, offp=off_end</span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ..</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">        t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">        <span class="comment">// 将当前事务添加到当前线程的事务栈中</span></span><br><span class="line">        thread-&gt;transaction_stack = t;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置事务的类型为BINDER_WORK_TRANSACTION</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    <span class="comment">// 将事务添加到target_list队列中，即target_list的待处理事务中</span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    <span class="comment">// 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE</span></span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    <span class="comment">// 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。</span></span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 唤醒目标进程</span></span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：参数reply=0，表明这是个请求事务，而不是反馈。binder_transaction新建会新建”一个待处理事务t”和”待完成的工作tcomplete”，并根据请求的数据对它们进行初始化。<br>(01) TestClent的getService请求是提交给ServiceManager进行处理的，因此，”待处理事务t”会被添加到ServiceManager的待处理事务队列中。此时的target_thread是ServiceManager对应的线程，而target_proc则是ServiceManager对应的进程上下文环境。<br>(02) 此时，Binder驱动已经收到了TestClent的getService请求；于是，将一个BINDER_WORK_TRANSACTION_COMPLETE类型的”待完成工作tcomplete”添加到当前线程(即，TestClent线程)的待处理事务队列中。目的是告诉TestClent，Binder驱动已经收到它的getService请求了。<br>(03) 最后，调用wake_up_interruptible(target_wait)将ServiceManager唤醒。</p>
<p>接下来，还是先分析完TestClent线程，再看ServiceManager被唤醒后做了些什么。</p>
<p>binder_transaction()执行完毕之后，就会返回到binder_thread_write()中。binder_thread_write()更新bwr.write_consumed的值后，就返回到binder_ioctl()继续执行”读”动作。即执行binder_thread_read()。</p>
<h5 id="2-4、Binder驱动中binder-thread-read-的源码"><a href="#2-4、Binder驱动中binder-thread-read-的源码" class="headerlink" title="2.4、Binder驱动中binder_thread_read()的源码"></a>2.4、Binder驱动中binder_thread_read()的源码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区</span></span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 等待proc进程的事务标记。</span></span><br><span class="line">    <span class="comment">// 当线程的事务栈为空 并且 待处理事务队列为空时，该标记位true。</span></span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                list_empty(&amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程的"待完成工作"不为空，则取出待完成工作。</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123;</span><br><span class="line">            cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">            <span class="comment">// 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中</span></span><br><span class="line">            <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 待完成事务已经处理完毕，将其从待完成事务队列中删除。</span></span><br><span class="line">            list_del(&amp;w-&gt;entry);</span><br><span class="line">            kfree(w);</span><br><span class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!t)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 更新bwr.read_consumed的值</span></span><br><span class="line">    *consumed = ptr - buffer;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：<br>(01) bwr.read_consumed=0，即if (*consumed == 0)为true。因此，会将BR_NOOP写入到bwr.read_buffer中。<br>(02) thread-&gt;transaction_stack不为空，thread-&gt;todo也不为空。因为，前面在binder_transaction()中有将一个BINDER_WORK_TRANSACTION_COMPLETE类型的待完成工作添加到thread的待完成工作队列中。因此，wait_for_proc_work为false。<br>(03) binder_has_thread_work(thread)为true。因此，在调用wait_event_interruptible()时，不会进入等待状态，而是继续运行。<br>(04) 进入while循环后，通过list_first_entry()取出待完成工作w。w的类型w-&gt;type=BINDER_WORK_TRANSACTION_COMPLETE，进入到对应的switch分支。随后，将BR_TRANSACTION_COMPLETE写入到bwr.read_buffer中。此时，待处理工作已经完成，将其从当前线程的待处理工作队列中删除。<br>(05) 最后，更新bwr.read_consumed的值。</p>
<p>经过binder_thread_read()处理之后，bwr.read_buffer中包含了两个指令：BR_NOOP和BR_TRANSACTION_COMPLETE。</p>
<h5 id="2-5、ServiceManager处理getService请求"><a href="#2-5、ServiceManager处理getService请求" class="headerlink" title="2.5、ServiceManager处理getService请求"></a>2.5、ServiceManager处理getService请求</h5><p>下面看看ServiceManager被唤醒之后，是如何处理getService请求的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int binder_parse(struct binder_state *bs, struct binder_io *bio,</span><br><span class="line">                 uint32_t *ptr, uint32_t size, binder_handler func)</span><br><span class="line">&#123;</span><br><span class="line">    while (ptr &lt; end) &#123;</span><br><span class="line">        case BR_TRANSACTION: &#123;</span><br><span class="line">            struct binder_txn *txn = (void *) ptr;</span><br><span class="line">            ...</span><br><span class="line">            if (func) &#123;</span><br><span class="line">                unsigned rdata[256/4];</span><br><span class="line">                struct binder_io msg;   // 用于保存&quot;Binder驱动反馈的信息&quot;</span><br><span class="line">                struct binder_io reply; // 用来保存&quot;回复给Binder驱动的信息&quot;</span><br><span class="line">                int res;</span><br><span class="line"></span><br><span class="line">                // 初始化reply</span><br><span class="line">                bio_init(&amp;reply, rdata, sizeof(rdata), 4);</span><br><span class="line">                // 根据txt(Binder驱动反馈的信息)初始化msg</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                // 消息处理</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                // 反馈消息给Binder驱动。</span><br><span class="line">                binder_send_reply(bs, &amp;reply, txn-&gt;data, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>binder_send_reply(bs, &amp;reply, txn-&gt;data, res);-&gt;binder_write()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">binder_write()</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_write</span><span class="params">(struct binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    bwr.write_size = len;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">unsigned</span>) data;</span><br><span class="line">    bwr.read_size = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder_write: ioctl failed (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：binder_write()会将数据封装到binder_write_read的变量bwr中；其中，bwr.read_size=0，而bwr.write_size&gt;0。接着，便通过ioctl(,BINDER_WRITE_READ,)和Binder驱动交互，将数据反馈给Binder驱动。</p>
<p>再次回到Binder驱动的binder_ioctl()对应的BINDER_WRITE_READ分支中。此时，由于bwr.read_size=0，而bwr.write_size&gt;0；因此，Binder驱动只调用binder_thread_write进行写操作，而不会进行读。</p>
<p>返回数据：</p>
<p><a href="https://postimg.org/image/pz99rp60f/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/htr7tjhrn/42-_Android-binder-_Binder-io-transaction-data.jpg" alt="42-_Android-binder-_Binder-io-transaction-data.jpg"></a></p>
<p>handle = 1 代表第一个</p>
<h6 id="2-6、Binder驱动中处理ServiceManager返回数据"><a href="#2-6、Binder驱动中处理ServiceManager返回数据" class="headerlink" title="2.6、Binder驱动中处理ServiceManager返回数据"></a>2.6、Binder驱动中处理ServiceManager返回数据</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取binder_write_read.write_buffer中的内容。</span></span><br><span class="line">  <span class="comment">// 每次读取32bit(即4个字节)</span></span><br><span class="line">  <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">      <span class="comment">// 从用户空间读取32bit到内核中，并赋值给cmd。</span></span><br><span class="line">      <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BC_FREE_BUFFER: </span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">      *consumed = ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>binder_thread_write()进入BC_REPLY之后，会将数据拷贝到内核空间，然后调用binder_transaction()进行处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        <span class="comment">// 事务栈</span></span><br><span class="line">        in_reply_to = thread-&gt;transaction_stack;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 设置优先级</span></span><br><span class="line">        binder_set_nice(in_reply_to-&gt;saved_priority);</span><br><span class="line">        ...</span><br><span class="line">        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">        <span class="comment">// 发起请求的线程，即MediaPlayer所在线程。</span></span><br><span class="line">        <span class="comment">// from的值，是MediaPlayer发起请求时在binder_transaction()中赋值的。</span></span><br><span class="line">        target_thread = in_reply_to-&gt;from;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// MediaPlayer对应的进程</span></span><br><span class="line">        target_proc = target_thread-&gt;proc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        e-&gt;to_thread = target_thread-&gt;pid;</span><br><span class="line">        target_list = &amp;target_thread-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;to_proc = target_proc-&gt;pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待处理的事务t，t是binder事务(binder_transaction对象)</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_t_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。</span></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (tcomplete == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_tcomplete_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line"></span><br><span class="line">    t-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    e-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 下面的一些赋值是初始化事务t</span></span><br><span class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</span><br><span class="line">    <span class="comment">// 事务将交给target_proc进程进行处理</span></span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    <span class="comment">// 事务将交给target_thread线程进行处理</span></span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    <span class="comment">// 事务编码</span></span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    <span class="comment">// 事务标志</span></span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    <span class="comment">// 事务优先级</span></span><br><span class="line">    t-&gt;priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_binder_alloc_buf_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    <span class="comment">// 保存事务</span></span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    <span class="comment">// target_node为NULL</span></span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">    trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将"用户传入的数据"保存到事务中</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将"用户传入的数据偏移地址"保存到事务中</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line">    <span class="comment">// 将flat_binder_object对象读取出来，</span></span><br><span class="line">    <span class="comment">// 这里就是Service Manager中反馈的MediaPlayerService对象。</span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line">        ...</span><br><span class="line">        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">                <span class="comment">// 根据handle获取对应的Binder引用，即得到MediaPlayerService的Binder引用</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span> = <span class="title">binder_get_ref</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">handle</span>);</span></span><br><span class="line">                <span class="keyword">if</span> (ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ref-&gt;node-&gt;proc是MediaPlayerService的进程上下文环境，</span></span><br><span class="line">                <span class="comment">// 而target_proc是MediaPlayer的进程上下文环境</span></span><br><span class="line">                <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    struct binder_ref *new_ref;</span><br><span class="line">                    <span class="comment">// 在MediaPlayer进程中引用"MediaPlayerService"。</span></span><br><span class="line">                    <span class="comment">// 表现为，执行binder_get_ref_for_node()会，会先在MediaPlayer进程中查找是否存在MediaPlayerService对应的Binder引用；</span></span><br><span class="line">                    <span class="comment">// 很显然是不存在的。于是，并新建MediaPlayerService对应的Binder引用，并将其添加到MediaPlayer的Binder引用红黑树中。</span></span><br><span class="line">                    new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">                    <span class="keyword">if</span> (new_ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将new_ref的引用描述复制给fp-&gt;handle。</span></span><br><span class="line">                    fp-&gt;handle = new_ref-&gt;desc;</span><br><span class="line">                    binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, <span class="literal">NULL</span>);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置事务的类型为BINDER_WORK_TRANSACTION</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    <span class="comment">// 将事务添加到target_list队列中，即target_list的待处理事务中</span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    <span class="comment">// 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE</span></span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    <span class="comment">// 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。</span></span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 唤醒目标进程</span></span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：reply=1，这里只关注reply部分。<br>(01) 此反馈最终是要回复给TestClient的。因此，target_thread被赋值为TestServer所在的线程，target_proc则是TestClient对应的进程，target_node为null。<br>(02) 这里，先看看for循环里面的内容，取出BR_REPLY指令所发送的数据，然后获取数据中的flat_binder_object变量fp。因为fp-&gt;type为BINDER_TYPE_HANDLE，因此进入BINDER_TYPE_HANDLE对应的分支。接着，通过binder_get_ref()获取Hello Service对应的Binder引用；很明显，能够正常获取到Hello Service的Binder引用。因为在Hello Service调用addService请求时，已经创建了它的Binder引用。 binder_get_ref_for_node()的作用是在TestClent进程上下文中添加”TestServer对应的Binder引用”。这样，后面就可以根据该Binder引用一步步的获取TestServer对象。 最后，将Binder引用的描述赋值给fp-&gt;handle。<br>(03) 此时，Service Manager已经处理了getService请求。便调用binder_pop_transaction(target_thread, in_reply_to)将事务从”target_thread的事务栈”中删除，即从MediaPlayer线程的事务栈中删除该事务。<br>(04) 新建的”待处理事务t”的type为设为BINDER_WORK_TRANSACTION后，会被添加到MediaPlayer的待处理事务队列中。<br>(05) 此时，Service Manager已经处理了getService请求，而Binder驱动在等待它的回复。于是，将一个BINDER_WORK_TRANSACTION_COMPLETE类型的”待完成工作tcomplete”(作为回复)添加到当前线程(即，Service Manager线程)的待处理事务队列中。<br>(06) 最后，调用wake_up_interruptible()唤醒TestServer。TestServer被唤醒后，会对事务BINDER_WORK_TRANSACTION进行处理。</p>
<p>OK，到现在为止，还有两个待处理事务：(01) ServiceManager待处理事务列表中有个BINDER_WORK_TRANSACTION_COMPLETE类型的事务 (02) TestServer待处理事务列表中有个BINDER_WORK_TRANSACTION事务。</p>
<h5 id="2-7-Testclient获取handle"><a href="#2-7-Testclient获取handle" class="headerlink" title="2.7. Testclient获取handle"></a>2.7. Testclient获取handle</h5><p><a href="https://postimg.org/image/qos248ebj/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/4cu9auf7n/43-_Android-binder-binder_use_service.png" alt="43-_Android-binder-binder_use_service.png"></a></p>
<h4 id="（3）、Binder系统驱动情景分析—TestClent使用“Hello”服务过程"><a href="#（3）、Binder系统驱动情景分析—TestClent使用“Hello”服务过程" class="headerlink" title="（3）、Binder系统驱动情景分析—TestClent使用“Hello”服务过程"></a>（3）、Binder系统驱动情景分析—TestClent使用“Hello”服务过程</h4><p>构造数据发送数据”weidongshan”<br><a href="https://postimg.org/image/tvmlnoypr/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/dkmhrdm83/44-_Android-binder-_Binder-io-transaction-data.jpg" alt="44-_Android-binder-_Binder-io-transaction-data.jpg"></a></p>
<h3 id="四、Android-Binder系统-Native层"><a href="#四、Android-Binder系统-Native层" class="headerlink" title="四、Android Binder系统-Native层"></a>四、Android Binder系统-Native层</h3><p>前面我们分析内核驱动Binder使用过程，可以看到，binder系统在内核能正常完成IPC通信，接下来分析Android framwork层，最后是App层。</p>
<p>Framework是一个中间层，它对接了底层实现，封装了复杂的内部逻辑，并提供供外部使用的接口。Framework层是应用程序开发的基础。</p>
<p>Binder Framework层分为C++和Java两个部分，为了达到功能的复用，中间通过JNI进行衔接。</p>
<p>Binder Framework的C++部分，头文件位于这个路径：/frameworks/native/include/binder/，实现位于这个路径：/frameworks/native/libs/binder/ 。Binder库最终会编译成一个动态链接库：libbinder.so，供其他进程链接使用。</p>
<p>为了便于说明，下文中我们将Binder Framework 的C++部分称之为libbinder。首先说一下ServiceManager，然后详细介绍。</p>
<h4 id="1-、ServiceManager类图-Native层"><a href="#1-、ServiceManager类图-Native层" class="headerlink" title="(1)、ServiceManager类图(Native层)"></a>(1)、ServiceManager类图(Native层)</h4><p>IServiceManager相关类如下图所示：<br><a href="https://postimg.org/image/b3aqk54wf/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/sgl0z007n/45-_Android-native_binder_framework_servicemananger.png" alt="45-_Android-native_binder_framework_servicemananger.png"></a></p>
<p>IServiceManager是表示servicemanager的接口，有如下方法：</p>
<p>1) getService获得binder service引用，</p>
<p>2) checkService获得binder service引用，</p>
<p>3) addService添加binder service，</p>
<p>4) listServices 列举所有binder service。</p>
<p>servicemanager的binder service服务端其实是在frameworks/base/cmds/servicemanager 里实现，BnServiceMananger实际上并未使用。BpServiceMananger就是利用获得的IBinder指针建立的IServiceMananger对象的实际类型。</p>
<h4 id="2-、Binder框架Native层"><a href="#2-、Binder框架Native层" class="headerlink" title="(2)、Binder框架Native层"></a>(2)、Binder框架Native层</h4><p>libbinder中，将实现分为Proxy和Native两端。Proxy对应了上文提到的Client端，是服务对外提供的接口。而Native是服务实现的一端，对应了上文提到的Server端。类名中带有小写字母p的（例如BpInterface），就是指Proxy端。类名带有小写字母n的（例如BnInterface），就是指Native端。</p>
<p>Proxy代表了调用方，通常与服务的实现不在同一个进程，因此下文中，我们也称Proxy端为“远程”端。Native端是服务实现的自身，因此下文中，我们也称Native端为”本地“端。</p>
<p>这里，我们先对libbinder中的主要类做一个简要说明，了解一下它们的关系，然后再详细的讲解。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">BpRefBase</td>
<td style="text-align:left">RefBase的子类，提供remote()方法获取远程Binder</td>
</tr>
<tr>
<td style="text-align:left">IInterface</td>
<td style="text-align:left">Binder服务接口的基类，Binder服务通常需要同时提供本地接口和远程接口</td>
</tr>
<tr>
<td style="text-align:left">BpInterface</td>
<td style="text-align:left">远程接口的基类，远程接口是供客户端调用的接口集</td>
</tr>
<tr>
<td style="text-align:left">BnInterface</td>
<td style="text-align:left">本地接口的基类，本地接口是需要服务中真正实现的接口集</td>
</tr>
<tr>
<td style="text-align:left">IBiner</td>
<td style="text-align:left">Binder对象的基类，BBinder和BpBinder都是这个类的子类</td>
</tr>
<tr>
<td style="text-align:left">BpBinder</td>
<td style="text-align:left">远程Binder，这个类提供transact方法来发送请求，BpXXX实现中会用到</td>
</tr>
<tr>
<td style="text-align:left">BBinder</td>
<td style="text-align:left">本地Binder，服务实现方的基类，提供了onTransact接口来接收请求</td>
</tr>
<tr>
<td style="text-align:left">ProcessState</td>
<td style="text-align:left">代表了使用Binder的进程</td>
</tr>
<tr>
<td style="text-align:left">IPCThreadState</td>
<td style="text-align:left">代表了使用Binder的线程，这个类中封装了与Binder驱动通信的逻辑</td>
</tr>
<tr>
<td style="text-align:left">Parcel</td>
<td style="text-align:left">在Binder上传递的数据的包装器</td>
</tr>
</tbody>
</table>
<p>下图描述了这些类之间的关系：<br><a href="https://postimg.org/image/897l6r067/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/stcf58fxf/46-_Androi-binder_middleware.png" alt="46-_Androi-binder_middleware.png"></a></p>
<p>另外说明一下，Binder服务的实现类（图中紫色部分）通常都会遵守下面的命名规则：</p>
<p>☯ 服务的接口使用I字母作为前缀<br>☯ 远程接口使用Bp作为前缀<br>☯ 本地接口使用Bn作为前缀</p>
<p>看了上面这些介绍，你可能还是不太容易理解。不过不要紧，下面我们会逐步拆分讲解这些内容。</p>
<p>在这幅图中，浅黄色部分的结构是最难理解的，因此我们先从它们着手。</p>
<p>我们先来看看IBinder这个类。这个类描述了所有在Binder上传递的对象，它既是Binder本地对象BBinder的父类，也是Binder远程对象BpBinder的父类。这个类中的主要方法说明如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">localBinder</td>
<td style="text-align:left">获取本地Binder对象</td>
</tr>
<tr>
<td style="text-align:left">remoteBinder</td>
<td style="text-align:left">获取远程Binder对象</td>
</tr>
<tr>
<td style="text-align:left">transact</td>
<td style="text-align:left">进行一次Binder操作</td>
</tr>
<tr>
<td style="text-align:left">queryLocalInterface</td>
<td style="text-align:left">尝试获取本地Binder，如何失败返回NULL</td>
</tr>
<tr>
<td style="text-align:left">getInterfaceDescriptor</td>
<td style="text-align:left">获取Binder的服务接口描述，其实就是Binder服务的唯一标识</td>
</tr>
<tr>
<td style="text-align:left">isBinderAlive</td>
<td style="text-align:left">查询Binder服务是否还活着</td>
</tr>
<tr>
<td style="text-align:left">pingBinder</td>
<td style="text-align:left">发送PING_TRANSACTION给Binder服务</td>
</tr>
</tbody>
</table>
<p>BpBinder的实例代表了远程Binder，这个类的对象将被客户端调用。其中handle方法会返回指向Binder服务实现者的句柄，这个类最重要就是提供了transact方法，这个方法会将远程调用的参数封装好发送的Binder驱动。</p>
<p>由于每个Binder服务通常都会提供多个服务接口，而这个方法中的uint32_t code参数就是用来对服务接口进行编号区分的。Binder服务的每个接口都需要指定一个唯一的code，这个code要在Proxy和Native端配对好。当客户端将请求发送到服务端的时候，服务端根据这个code（onTransact方法中）来区分调用哪个接口方法。</p>
<p>BBinder的实例代表了本地Binder，它描述了服务的提供方，所有Binder服务的实现者都要继承这个类（的子类），在继承类中，最重要的就是实现onTransact方法，因为这个方法是所有请求的入口。因此，这个方法是和BpBinder中的transact方法对应的，这个方法同样也有一个uint32_t code参数，在这个方法的实现中，由服务提供者通过code对请求的接口进行区分，然后调用具体实现服务的方法。</p>
<p>IBinder中定义了uint32_t code允许的范围：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIRST_CALL_TRANSACTION  = <span class="number">0x00000001</span>,</span><br><span class="line">LAST_CALL_TRANSACTION   = <span class="number">0x00ffffff</span>,</span><br></pre></td></tr></table></figure>
<p>Binder服务要保证自己提供的每个服务接口有一个唯一的code，例如hello服务:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_SVR_CMD_SAYHELLO     1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_SVR_CMD_SAYHELLO_TO  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_SVR_CMD_GET_FD       3</span></span><br></pre></td></tr></table></figure>
<p>讲完了IBinder，BpBinder和BBinder三个类，我们再来看看BpReBase，IInterface，BpInterface和BnInterface。</p>
<p>每个Binder服务都是为了某个功能而实现的，因此其本身会定义一套接口集（通常是C++的一个类）来描述自己提供的所有功能。而Binder服务既有自身实现服务的类，也要有给客户端进程调用的类。为了便于开发，这两中类里面的服务接口应当是一致的，例如：假设服务实现方提供了一个接口为sayhello(void)的服务方法，那么其远程接口中也应当有一个sayhello(void)方法。因此为了实现方便，本地实现类和远程接口类需要有一个公共的描述服务接口的基类（即上图中的IXXXService）来继承。而这个基类通常是IInterface的子类，IInterface的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IInterface</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">            IInterface();</span><br><span class="line">            <span class="keyword">static</span> sp&lt;IBinder&gt;  asBinder(<span class="keyword">const</span> IInterface*);</span><br><span class="line">            <span class="keyword">static</span> sp&lt;IBinder&gt;  asBinder(<span class="keyword">const</span> sp&lt;IInterface&gt;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span>                     ~IInterface();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之所以要继承自IInterface类是因为这个类中定义了onAsBinder让子类实现。onAsBinder在本地对象的实现类中返回的是本地对象，在远程对象的实现类中返回的是远程对象。onAsBinder方法被两个静态方法asBinder方法调用。有了这些接口之后，在代码中便可以直接通过IXXX::asBinder方法获取到不用区分本地还是远程的IBinder对象。这个在跨进程传递Binder对象的时候有很大的作用（因为不用区分具体细节，只要直接调用和传递就好）。</p>
<p>下面，我们来看一下BpInterface和BnInterface的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BnInterface</span> :</span> <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BBinder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IInterface&gt;      queryLocalInterface(<span class="keyword">const</span> String16&amp; _descriptor);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> String16&amp;     <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpInterface</span> :</span> <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BpRefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">                                BpInterface(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; remote);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这两个类都是模板类，它们在继承自INTERFACE的基础上各自继承了另外一个类。这里的INTERFACE便是我们Binder服务接口的基类。另外，BnInterface继承了BBinder类，由此可以通过复写onTransact方法来提供实现。BpInterface继承了BpRefBase，通过这个类的remote方法可以获取到指向服务实现方的句柄。在客户端接口的实现类中，每个接口在组装好参数之后，都会调用remote()-&gt;transact来发送请求，而这里其实就是调用的BpBinder的transact方法，这样请求便通过Binder到达了服务实现方的onTransact中。这个过程如下图所示：<br><a href="https://postimg.org/image/nuowqoh9b/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/pz99rriw3/47-_Android-_Binder-_IPCall.png" alt="47-_Android-_Binder-_IPCall.png"></a></p>
<p>基于Binder框架开发的服务，除了满足上文提到的类名规则之外，还需要遵守其他一些共同的规约：</p>
<p>☯为了进行服务的区分，每个Binder服务需要指定一个唯一的标识，这个标识通过getInterfaceDescriptor返回，类型是一个字符串。通常，Binder服务会在类中定义static const android::String16 descriptor;这样一个常量来描述这个标识符，然后在getInterfaceDescriptor方法中返回这个常量。<br>☯为了便于调用者获取到调用接口，服务接口的公共基类需要提供一个android::sp<ixxx> asInterface方法来返回基类对象指针。<br>由于上面提到的这两点对于所有Binder服务的实现逻辑都是类似的。为了简化开发者的重复工作，在libbinder中，定义了两个宏来简化这些重复工作，它们是：</ixxx></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                            \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> android::String16 descriptor;                       \</span><br><span class="line">    <span class="keyword">static</span> android::sp&lt;I##INTERFACE&gt; asInterface(                    \</span><br><span class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj);               \</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> android::<span class="function">String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>; \</span><br><span class="line">    I##INTERFACE();                                                  \</span><br><span class="line">    <span class="keyword">virtual</span> ~I##INTERFACE();                                         \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                    \</span></span><br><span class="line">    <span class="keyword">const</span> android::String16 I##INTERFACE::descriptor(NAME);          \</span><br><span class="line">    <span class="keyword">const</span> android::String16&amp;                                         \</span><br><span class="line">            I##INTERFACE::getInterfaceDescriptor() <span class="keyword">const</span> &#123;           \</span><br><span class="line">        <span class="keyword">return</span> I##INTERFACE::descriptor;                             \</span><br><span class="line">    &#125;                                                                \</span><br><span class="line">    android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(             \</span><br><span class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj)                \</span><br><span class="line">    &#123;                                                                \</span><br><span class="line">        android::sp&lt;I##INTERFACE&gt; intr;                              \</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;                                           \</span><br><span class="line">            intr = <span class="keyword">static_cast</span>&lt;I##INTERFACE*&gt;(                       \</span><br><span class="line">                obj-&gt;queryLocalInterface(                            \</span><br><span class="line">                        I##INTERFACE::descriptor).get());            \</span><br><span class="line">            <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;                                      \</span><br><span class="line">                intr = <span class="keyword">new</span> Bp##INTERFACE(obj);                       \</span><br><span class="line">            &#125;                                                        \</span><br><span class="line">        &#125;                                                            \</span><br><span class="line">        <span class="keyword">return</span> intr;                                                 \</span><br><span class="line">    &#125;                                                                \</span><br><span class="line">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                 \</span><br><span class="line">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                \</span><br></pre></td></tr></table></figure>
<p>有了这两个宏之后，开发者只要在接口基类（IXXX）头文件中，使用DECLARE_META_INTERFACE宏便完成了需要的组件的声明。然后在cpp文件中使用IMPLEMENT_META_INTERFACE便完成了这些组件的实现。</p>
<h5 id="2-1、Binder的初始化ProcessState"><a href="#2-1、Binder的初始化ProcessState" class="headerlink" title="2.1、Binder的初始化ProcessState"></a>2.1、<strong>Binder的初始化ProcessState</strong></h5><p>在讲解Binder驱动的时候我们就提到：任何使用Binder机制的进程都必须要对/dev/binder设备进行open以及mmap之后才能使用，这部分逻辑是所有使用Binder机制进程共同的。对于这种共同逻辑的封装便是Framework层的职责之一。libbinder中，ProcessState类封装了这个逻辑，相关代码见下文。</p>
<p>这里是ProcessState构造函数，在这个函数中，初始化mDriverFD的时候调用了open_driver方法打开binder设备，然后又在函数体中，通过mmap进行内存映射。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState()</span><br><span class="line">    : mDriverFD(open_driver())</span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>open_driver的函数实现如下所示。在这个函数中完成了三个工作：</p>
<p>☯首先通过open系统调用打开了dev/binder设备<br>☯然后通过ioctl获取Binder实现的版本号，并检查是否匹配<br>☯最后通过ioctl设置进程支持的最大线程数量<br>关于这部分逻辑背后的处理，在讲解Binder驱动的时候，我们已经讲解过了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProcessState是一个Singleton（单例）类型的类，在一个进程中，只会存在一个实例。通过ProcessState::self()接口获取这个实例。一旦获取这个实例，便会执行其构造函数，由此完成了对于Binder设备的初始化工作。</p>
<h5 id="2-2、关于Binder传递数据的大小限制"><a href="#2-2、关于Binder传递数据的大小限制" class="headerlink" title="2.2、关于Binder传递数据的大小限制"></a>2.2、<strong>关于Binder传递数据的大小限制</strong></h5><p>由于Binder的数据需要跨进程传递，并且还需要在内核上开辟空间，因此允许在Binder上传递的数据并不是无无限大的。mmap中指定的大小便是对数据传递的大小限制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VM_SIZE ((1*1024*1024) - (4096 *2)) <span class="comment">// 1M - 8k</span></span></span><br><span class="line">mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这里我们看到，在进行mmap的时候，指定了最大size为BINDER_VM_SIZE，即 1M - 8k的大小。 因此我们在开发过程中，一次Binder调用的数据总和不能超过这个大小。</p>
<p>对于这个区域的大小，我们也可以在设备上进行确认。这里我们还之前提到的system_server为例。上面我们讲解了通过procfs来获取映射的内存地址，除此之外，我们也可以通过showmap命令，来确定这块区域的大小，相关命令如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">angler:/ <span class="meta"># ps  | grep system_server                                            </span></span><br><span class="line">system    <span class="number">1889</span>  <span class="number">526</span>   <span class="number">2353404</span> <span class="number">135968</span> SyS_epoll_ <span class="number">72972</span>eeaf4 S system_server</span><br><span class="line">angler:/ <span class="meta"># showmap 1889 | grep <span class="meta-string">"/dev/binder"</span>                                   </span></span><br><span class="line">    <span class="number">1016</span>        <span class="number">4</span>        <span class="number">4</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">4</span>        <span class="number">0</span>        <span class="number">0</span>    <span class="number">1</span> /dev/binder</span><br></pre></td></tr></table></figure>
<p>这里可以看到，这块区域的大小正是 1M - 8K = 1016k。</p>
<p>Tips: 通过showmap命令可以看到进程的详细内存占用情况。在实际的开发过程中，当我们要对某个进程做内存占用分析的时候，这个命令是相当有用的。建议读者尝试通过showmap命令查看system_server或其他感兴趣进程的完整map，看看这些进程都依赖了哪些库或者模块，以及内存占用情况是怎样的。</p>
<h5 id="2-3、与驱动的通信IPCThreadState"><a href="#2-3、与驱动的通信IPCThreadState" class="headerlink" title="2.3、与驱动的通信IPCThreadState"></a>2.3、<strong>与驱动的通信IPCThreadState</strong></h5><p>上文提到ProcessState是一个单例类，一个进程只有一个实例。而负责与Binder驱动通信的IPCThreadState也是一个单例类。但这个类不是一个进程只有一个实例，而是一个线程有一个实例。</p>
<p>IPCThreadState负责了与驱动通信的细节处理。这个类中的关键几个方法说明如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">transact</td>
<td style="text-align:left">公开接口。供Proxy发送数据到驱动，并读取返回结果</td>
</tr>
<tr>
<td style="text-align:left">sendReply</td>
<td style="text-align:left">供Server端写回请求的返回结果</td>
</tr>
<tr>
<td style="text-align:left">waitForResponse</td>
<td style="text-align:left">发送请求后等待响应结果</td>
</tr>
<tr>
<td style="text-align:left">talkWithDriver</td>
<td style="text-align:left">通过ioctl BINDER_WRITE_READ来与驱动通信</td>
</tr>
<tr>
<td style="text-align:left">writeTransactionData</td>
<td style="text-align:left">写入一次事务的数据</td>
</tr>
<tr>
<td style="text-align:left">executeCommand</td>
<td style="text-align:left">处理binder_driver_return_protocol协议命令</td>
</tr>
<tr>
<td style="text-align:left">freeBuffer</td>
<td style="text-align:left">通过BC_FREE_BUFFER命令释放Buffer</td>
</tr>
</tbody>
</table>
<p>BpBinder::transact方法在发送请求的时候，其实就是直接调用了IPCThreadState对应的方法来发送请求到Binder驱动的，相关代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BpBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而IPCThreadState::transact方法主要逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码应该还是比较好理解的：首先通过writeTransactionData写入数据，然后通过waitForResponse等待返回结果。TF_ONE_WAY表示此次请求是单向的，即：不用真正等待结果即可返回。</p>
<p>而writeTransactionData方法其实就是在组装binder_transaction_data数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于binder_transaction_data在讲解Binder驱动的时候我们已经详细讲解过了。而这里的Parcel我们还不了解，那么接下来我们马上就来看一下这个类。</p>
<p>数据包装器：Parcel<br>Binder上提供的是跨进程的服务，每个服务包含了不同的接口，每个接口的参数数量和类型都不一样。那么当客户端想要调用服务端的接口，参数是如何跨进程传递给服务端的呢？除此之外，服务端想要给客户端返回结果，结果又是如何传递回来的呢？</p>
<p>这些问题的答案就是：Parcel。Parcel就像一个包装器，调用者可以以任意顺序往里面放入需要的数据，所有写入的数据就像是被打成一个整体的包，然后可以直接在Binde上传输。</p>
<p>Parcel提供了所有基本类型的写入和读出接口，下面是其中的一部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">status_t</span>            writeInt32(<span class="keyword">int32_t</span> val);</span><br><span class="line"><span class="keyword">status_t</span>            writeUint32(<span class="keyword">uint32_t</span> val);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">status_t</span>            readUtf8FromUtf16(<span class="built_in">std</span>::<span class="built_in">string</span>* str) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">status_t</span>            readUtf8FromUtf16(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;* str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>*         <span class="title">readCString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>因此对于基本类型，开发者可以直接调用接口写入和读出。而对于非基本类型，需要由开发者将其拆分成基本类型然后写入到Parcel中（读出的时候也是一样）。 Parcel会将所有写入的数据进行打包，Parcel本身可以作为一个整体在进程间传递。接收方在收到Parcel之后，只要按写入同样的顺序读出即可。</p>
<p>这个过程，和我们现实生活中寄送包裹做法是一样的：我们将需要寄送的包裹放到硬纸盒中交给快递公司。快递公司将所有的包裹进行打包，然后集中放到运输车中送到目的地，到了目的地之后然后再进行拆分。</p>
<p>Parcel既包含C++部分的实现，也同时提供了Java的接口，中间通过JNI衔接。Java层的接口其实仅仅是一层包装，真正的实现都是位于C++部分中。<br>特别需要说明一下的是，Parcel类除了可以传递基本数据类型，还可以传递Binder对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Parcel::writeStrongBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法写入的是sp<ibinder>类型的对象，而IBinder既可能是本地Binder，也可能是远程Binder，这样我们就不可以不用关心具体细节直接进行Binder对象的传递。</ibinder></p>
<p>这也是为什么IInterface中定义了两个asBinder的static方法，如果你不记得了，请回忆一下这两个方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> sp&lt;IBinder&gt;  asBinder(<span class="keyword">const</span> IInterface*);</span><br><span class="line"><span class="keyword">static</span> sp&lt;IBinder&gt;  asBinder(<span class="keyword">const</span> sp&lt;IInterface&gt;&amp;);</span><br></pre></td></tr></table></figure>
<p>而对于Binder驱动，我们前面已经讲解过：Binder驱动并不是真的将对象在进程间序列化传递，而是由Binder驱动完成了对于Binder对象指针的解释和翻译，使调用者看起来就像在进程间传递对象一样。</p>
<h5 id="2-4、Framework层的线程管理"><a href="#2-4、Framework层的线程管理" class="headerlink" title="2.4、Framework层的线程管理"></a>2.4、<strong>Framework层的线程管理</strong></h5><p>在讲解Binder驱动的时候，我们就讲解过驱动中对应线程的管理。这里我们再来看看，Framework层是如何与驱动层对接进行线程管理的。</p>
<p>ProcessState::setThreadPoolMaxThreadCount 方法中，会通过BINDER_SET_MAX_THREADS命令设置进程支持的最大线程数量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MAX_BINDER_THREADS 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> ProcessState::setThreadPoolMaxThreadCount(<span class="keyword">size_t</span> maxThreads) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(mDriverFD, BINDER_SET_MAX_THREADS, &amp;maxThreads) != <span class="number">-1</span>) &#123;</span><br><span class="line">        mMaxThreads = maxThreads;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = -errno;</span><br><span class="line">        ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(-result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此驱动便知道了该Binder服务支持的最大线程数。驱动在运行过程中，会根据需要，并在没有超过上限的情况下，通过BR_SPAWN_LOOPER命令通知进程创建线程：</p>
<p>IPCThreadState在收到BR_SPAWN_LOOPER请求之后，便会调用ProcessState::spawnPooledThread来创建线程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(<span class="keyword">int32_t</span> cmd)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> BR_SPAWN_LOOPER:</span><br><span class="line">        mProcess-&gt;spawnPooledThread(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProcessState::spawnPooledThread方法负责为线程设定名称并创建线程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ProcessState::spawnPooledThread(<span class="keyword">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name = makeBinderThreadName();</span><br><span class="line">        ALOGV(<span class="string">"Spawning new pooled thread, name=%s\n"</span>, name.<span class="built_in">string</span>());</span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> PoolThread(isMain);</span><br><span class="line">        t-&gt;run(name.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程在run之后，会调用threadLoop将自身添加的线程池中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而IPCThreadState::joinThreadPool方法中，会根据当前线程是否是主线程发送BC_ENTER_LOOPER或者BC_REGISTER_LOOPER命令告知驱动线程已经创建完毕。整个调用流程如下图所示：</p>
<p><a href="https://postimg.org/image/mfnc1xlb3/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/ija05y0bn/48-_Android-binder_thread_create.jpg" alt="48-_Android-binder_thread_create.jpg"></a></p>
<h4 id="（3）、Android-Binder系统-Native层添加hello服务"><a href="#（3）、Android-Binder系统-Native层添加hello服务" class="headerlink" title="（3）、Android Binder系统-Native层添加hello服务"></a>（3）、Android Binder系统-Native层添加hello服务</h4><h5 id="3-1、Client构造数据，发送数据给驱动"><a href="#3-1、Client构造数据，发送数据给驱动" class="headerlink" title="3.1、Client构造数据，发送数据给驱动"></a>3.1、<strong>Client构造数据，发送数据给驱动</strong></h5><p>首先看一下Native ServiceManager架构图</p>
<p>只讲数据构造过程。。</p>
<p><a href="https://postimg.org/image/n564eb1a7/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/hgztnewxv/49-_Android-add_Service.jpg" alt="49-_Android-add_Service.jpg"></a></p>
<p><a href="https://postimg.org/image/ezo2g55bj/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/m2vxvrar7/50-_Android-binder-_Bp_Binder.png" alt="50-_Android-binder-_Bp_Binder.png"></a></p>
<p>构造：<br>[-&gt; IServiceManager.cpp ::BpServiceManager]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service, <span class="keyword">bool</span> allowIsolated)</span> </span>&#123;</span><br><span class="line">    Parcel data, reply; <span class="comment">//Parcel是数据通信包</span></span><br><span class="line">    <span class="comment">//写入头信息"android.os.IServiceManager"</span></span><br><span class="line">    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());   </span><br><span class="line">    data.writeString16(name);        <span class="comment">// name为 "hello"</span></span><br><span class="line">    data.writeStrongBinder(service); <span class="comment">// HelloService对象，把一个binder实体“打扁”并写入parcel</span></span><br><span class="line">    data.writeInt32(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>); <span class="comment">// allowIsolated= false</span></span><br><span class="line">    <span class="comment">//remote()指向的是BpBinder对象</span></span><br><span class="line">    <span class="keyword">status_t</span> err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务注册过程：向ServiceManager注册服务hello Service，服务名为”hello”；<br>请大家注意上面data.writeStrongBinder()一句，它专门负责把一个binder实体“打扁”并写入parcel。其代码如下：</p>
<h5 id="3-2-1、-writeStrongBinder"><a href="#3-2-1、-writeStrongBinder" class="headerlink" title="3.2.1、* writeStrongBinder()"></a>3.2.1、<em>* writeStrongBinder()</em></h5><p>[-&gt; parcel.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Parcel::writeStrongBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-2、flatten-binder"><a href="#3-2-2、flatten-binder" class="headerlink" title="3.2.2、flatten_binder()"></a>3.2.2、<strong>flatten_binder()</strong></h5><p>[-&gt; parcel.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> flatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; <span class="comment">/*proc*/</span>,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line"></span><br><span class="line">    obj.flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder *local = binder-&gt;localBinder(); <span class="comment">//本地Binder不为空</span></span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            BpBinder *proxy = binder-&gt;remoteBinder();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> handle = proxy ? proxy-&gt;handle() : <span class="number">0</span>;</span><br><span class="line">            obj.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = <span class="number">0</span>;</span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//进入该分支</span></span><br><span class="line">            obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local-&gt;getWeakRefs());</span><br><span class="line">            obj.cookie = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://postimg.org/image/pz99rrqlr/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/64n85nbeb/51-_Android-_Binder-flatten_binder.png" alt="51-_Android-_Binder-flatten_binder.png"></a></p>
<p><a href="https://postimg.org/image/402v4khhb/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/76xeo71xf/52-_Android-_Binder-flatten_binder.png" alt="52-_Android-_Binder-flatten_binder.png"></a></p>
<p>将Binder对象扁平化，转换成flat_binder_object对象。<br>看到了吗？“打扁”的意思就是把binder对象整理成flat_binder_object变量，如果打扁的是binder实体，那么flat_binder_object用cookie域记录binder实体的指针，即BBinder指针，而如果打扁的是binder代理，那么flat_binder_object用handle域记录的binder代理的句柄值。</p>
<blockquote>
<p>总结：Parcel的数据区域分两个部分：mData和mObjects，所有的数据不管是基础数据类型还是对象实体，全都追加到mData里，mObjects是一个偏移量数组，记录所有存放在mData中的flat_binder_object实体的偏移量。</p>
</blockquote>
<h5 id="3-2-3、finish-flatten-binder"><a href="#3-2-3、finish-flatten-binder" class="headerlink" title="3.2.3、finish_flatten_binder()"></a>3.2.3、<strong>finish_flatten_binder()</strong></h5><p>将flat_binder_object写入out。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> status_t <span class="title">finish_flatten_binder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; , <span class="keyword">const</span> flat_binder_object&amp; flat, Parcel* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> out-&gt;writeObject(flat, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后flatten_binder()调用了一个关键的finish_flatten_binder()函数。这个函数内部会记录下刚刚被扁平化的flat_binder_object在parcel中的位置。说得更详细点儿就是，parcel对象内部会有一个buffer，记录着parcel中所有扁平化的数据，有些扁平数据是普通数据，而另一些扁平数据则记录着binder对象。所以parcel中会构造另一个mObjects数组，专门记录那些binder扁平数据所在的位置，示意图如下：</p>
<p><a href="https://postimg.org/image/bg24qci1b/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/fcfgmc30z/53-_Android-_Binder-parcel.png" alt="53-_Android-_Binder-parcel.png"></a></p>
<p>一旦到了向驱动层传递数据的时候，IPCThreadState::writeTransactionData()会先把Parcel数据整理成一个binder_transaction_data数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://postimg.org/image/z71i8hd3j/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/hgztnfzir/54-_Android-binder-write_Transaction_Data.png" alt="54-_Android-binder-write_Transaction_Data.png"></a></p>
<h5 id="3-2-4-、waitForResponse"><a href="#3-2-4-、waitForResponse" class="headerlink" title="3.2.4 、waitForResponse()"></a>3.2.4 、<strong>waitForResponse()</strong></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;<span class="comment">//目的就是把上面打包的mOut数据给kernel,接着看taklWithDriver();</span></span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">finish:</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数是与serviceManager通信的主要函数，首先会调用talkWithDriver()方法，将之前的打包在mOut中的数据打包成struct binder_write_read 对象，并通过ioctrl发送给kernel。</p>
<h5 id="3-2-5、-IPCThreadState-talkWithDriver"><a href="#3-2-5、-IPCThreadState-talkWithDriver" class="headerlink" title="3.2.5、  IPCThreadState::talkWithDriver"></a>3.2.5、 <strong> IPCThreadState::talkWithDriver</strong></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//doReceive参数，默认是为true,上面我们看到没有传参数，那么doReceive = 1； </span></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data(); <span class="comment">//将mOut数据指针存放到这里,这就是我们上面打包的数据。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity(); <span class="comment">//注意这里数据的大小，在我们new IPCThreadState对象时，已经初始化为256.</span></span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data(); <span class="comment">//mIn数据指针，放到这里</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>) <span class="comment">//这里通过ioctl将数据写给kernel</span></span><br><span class="line">      .....</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  该函数的作用就是将之前打包的数据通过系统调用ioctl发送给kernel，最终发送给kernel的数据是struct binder_write_read对象。该对象已经被打包了3次，它们的包含关系如下所示。<br><a href="https://postimg.org/image/3nbgyf1sf/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/4plngyklv/55-_Android-binder-_Transaction_data.png" alt="55-_Android-binder-_Transaction_data.png"></a></p>
<h5 id="3-2-6、Client获取服务、处理回复数据过程"><a href="#3-2-6、Client获取服务、处理回复数据过程" class="headerlink" title="3.2.6、Client获取服务、处理回复数据过程"></a>3.2.6、<strong>Client获取服务、处理回复数据过程</strong></h5><p>内核会唤醒Client进程处理回复消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>; </span><br><span class="line">        ...</span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">          <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">          &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">            <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//当reply对象回收时，则会调用freeBuffer来回收内存</span></span><br><span class="line">                    reply-&gt;ipcSetDataReference(</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                        freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">          ...     </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-7、Parcel-ipcSetDataReference"><a href="#3-2-7、Parcel-ipcSetDataReference" class="headerlink" title="3.2.7、Parcel::ipcSetDataReference"></a>3.2.7、<strong>Parcel::ipcSetDataReference</strong></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Parcel::ipcSetDataReference(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> dataSize,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">binder_size_t</span>* objects, <span class="keyword">size_t</span> objectsCount, release_func relFunc, <span class="keyword">void</span>* relCookie)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">binder_size_t</span> minOffset = <span class="number">0</span>;</span><br><span class="line">    freeDataNoInit();</span><br><span class="line">    mError = NO_ERROR;</span><br><span class="line">    mData = <span class="keyword">const_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(data); <span class="comment">//这是有4个字节的buffer。且存放的数据是0</span></span><br><span class="line">    mDataSize = mDataCapacity = dataSize; <span class="comment">//之前申请的大小就是4个字节。</span></span><br><span class="line">    <span class="comment">//ALOGI("setDataReference Setting data size of %p to %lu (pid=%d)", this, mDataSize, getpid());</span></span><br><span class="line">    mDataPos = <span class="number">0</span>;</span><br><span class="line">    ALOGV(<span class="string">"setDataReference Setting data pos of %p to %zu"</span>, <span class="keyword">this</span>, mDataPos);</span><br><span class="line">    mObjects = <span class="keyword">const_cast</span>&lt;<span class="keyword">binder_size_t</span>*&gt;(objects); <span class="comment">//binder对象其实地址</span></span><br><span class="line">    mObjectsSize = mObjectsCapacity = objectsCount; <span class="comment">//binder对象的个数。</span></span><br><span class="line">    mNextObjectHint = <span class="number">0</span>;</span><br><span class="line">    mOwner = relFunc; <span class="comment">//释放内存的函数，后面我们就不进行了。</span></span><br><span class="line">    mOwnerCookie = relCookie;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mObjectsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">binder_size_t</span> offset = mObjects[i];</span><br><span class="line">        <span class="keyword">if</span> (offset &lt; minOffset) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: bad object offset %"</span>PRIu64<span class="string">" &lt; %"</span>PRIu64<span class="string">"\n"</span>,</span><br><span class="line">                  __func__, (<span class="keyword">uint64_t</span>)offset, (<span class="keyword">uint64_t</span>)minOffset);</span><br><span class="line">            mObjectsSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minOffset = offset + <span class="keyword">sizeof</span>(flat_binder_object);</span><br><span class="line">    &#125;</span><br><span class="line">    scanForFds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面做的工作只是将事务数据分别安放到当前Parcel对象的相应位置。其中scanForFds（）是为了查找返回来的数据中是否有binder对象，这个在获取代理对象时有用。</p>
<h5 id="3-2-8、readStrongBinder"><a href="#3-2-8、readStrongBinder" class="headerlink" title="3.2.8、readStrongBinder()"></a>3.2.8、<strong>readStrongBinder()</strong></h5><p>[-&gt; Parcel.java]</p>
<p>readStrongBinder的过程基本是writeStrongBinder逆过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr) &#123;</span><br><span class="line">    Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    if (parcel != NULL) &#123;</span><br><span class="line">        return javaObjectForIBinder(env, parcel-&gt;readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>javaObjectForIBinder 将native层BpBinder对象转换为Java层BinderProxy对象。</p>
<h5 id="3-2-9、readStrongBinder-C"><a href="#3-2-9、readStrongBinder-C" class="headerlink" title="3.2.9、readStrongBinder(C++)"></a>3.2.9、<strong>readStrongBinder(C++)</strong></h5><p>[-&gt; Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; Parcel::readStrongBinder() const</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; val;</span><br><span class="line">    unflatten_binder(ProcessState::self(), *this, &amp;val);</span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-10、unflatten-binder"><a href="#3-2-10、unflatten-binder" class="headerlink" title="3.2.10、unflatten_binder()"></a>3.2.10、<strong>unflatten_binder()</strong></h5><p>[-&gt; Parcel.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> unflatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc, <span class="keyword">const</span> Parcel&amp; in, sp&lt;IBinder&gt;* out) &#123;</span><br><span class="line">    <span class="keyword">const</span> flat_binder_object* flat = in.readObject(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">                *out = <span class="keyword">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(<span class="literal">NULL</span>, *flat, in);</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</span><br><span class="line">                <span class="comment">//创建BpBinder对象</span></span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：readObject()的作用是从Parcel中读取出它所保存的flat_binder_object类型的对象。该对象的类型是BINDER_TYPE_HANDLE，因此会指向BINDER_TYPE_HANDLE对应的switch分支。<br>(01) 这里的proc是ProcessState对象，执行proc-&gt;getStrongProxyForHandle()会将句柄(MediaPlayerService的Binder引用描述)保存到ProcessState的链表中，然后再创建并返回该句柄的BpBinder对象(即Binder的代理)。在Android Binder机制(四) defaultServiceManager()的实现中有getStrongProxyForHandle()的详细说明，下面只给出getStrongProxyForHandle()代码。<br>(02) finish_unflatten_binder()中只有return NO_ERROR。</p>
<h5 id="3-2-11、getStrongProxyForHandle"><a href="#3-2-11、getStrongProxyForHandle" class="headerlink" title="3.2.11、getStrongProxyForHandle()"></a>3.2.11、<strong>getStrongProxyForHandle()</strong></h5><p>[-&gt; ProcessState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    //查找handle对应的资源项</span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    if (e != NULL) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            //当handle值所对应的IBinder不存在或弱引用无效时，则创建BpBinder对象</span><br><span class="line">            b = new BpBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            if (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过该方法，最终创建了指向Binder服务端的BpBinder代理对象。</p>
<h4 id="（4）、Android-Binder系统-Native层获取hello服务"><a href="#（4）、Android-Binder系统-Native层获取hello服务" class="headerlink" title="（4）、Android Binder系统-Native层获取hello服务"></a>（4）、Android Binder系统-Native层获取hello服务</h4><p>经过前面的分析，知道流程基本类似，这里不再继续分析获取hello服务</p>
<h3 id="五、Android-Binder系统-Framwork-Java层"><a href="#五、Android-Binder系统-Framwork-Java层" class="headerlink" title="五、Android Binder系统-Framwork-Java层"></a>五、Android Binder系统-Framwork-Java层</h3><h4 id="（1）、Android-Binder系统Java层"><a href="#（1）、Android-Binder系统Java层" class="headerlink" title="（1）、Android Binder系统Java层"></a>（1）、Android Binder系统Java层</h4><p>主要结构<br>Android应用程序使用Java语言开发，Binder框架自然也少不了在Java层提供接口。</p>
<p>前文中我们看到，Binder机制在C++层已经有了完整的实现。因此Java层完全不用重复实现，而是通过JNI衔接了C++层以复用其实现。</p>
<p>下图描述了Binder Framework Java层到C++层的衔接关系。<br><a href="https://postimg.org/image/jybkur1fj/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/9bhrpbtab/56-_Android-_Binder_JNI.png" alt="56-_Android-_Binder_JNI.png"></a></p>
<p>这里对图中Java层和JNI层的几个类做一下说明( 关于C++层的讲解请看这里 )：</p>
<p>这里的IInterface，IBinder和C++层的两个类是同名的。这个同名并不是巧合：它们不仅仅同名，它们所起的作用，以及其中包含的接口都是几乎一样的，区别仅仅在于一个是C++层，一个是Java层而已。</p>
<p>除了IInterface，IBinder之外，这里Binder与BinderProxy类也是与C++的类对应的，下面列出了Java层和C++层类的对应关系：</p>
<p><a href="https://postimg.org/image/mseq868qn/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/52d1n4v5v/57-_Android-binder-_Java-class.png" alt="57-_Android-binder-_Java-class.png"></a><br>这里的IInterface，IBinder和C++层的两个类是同名的。这个同名并不是巧合：它们不仅仅同名，它们所起的作用，以及其中包含的接口都是几乎一样的，区别仅仅在于一个是C++层，一个是Java层而已。</p>
<p>除了IInterface，IBinder之外，这里Binder与BinderProxy类也是与C++的类对应的，下面列出了Java层和C++层类的对应关系：</p>
<p><a href="https://postimg.org/image/76xeo7p2n/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/ok7p32kdv/58-_Android-binder-_Java-c-class.png" alt="58-_Android-binder-_Java-c-class.png"></a></p>
<h4 id="（2）、JNI的衔接"><a href="#（2）、JNI的衔接" class="headerlink" title="（2）、JNI的衔接"></a>（2）、JNI的衔接</h4><p>JNI全称是Java Native Interface，这个是由Java虚拟机提供的机制。这个机制使得native代码可以和Java代码互相通讯。简单来说就是：我们可以在C/C++端调用Java代码，也可以在Java端调用C/C++代码。</p>
<p>关于JNI的详细说明，可以参见Oracle的官方文档：Java Native Interface ，这里不多说明。</p>
<p>实际上，在Android中很多的服务或者机制都是在C/C++层实现的，想要将这些实现复用到Java层，就必须通过JNI进行衔接。AOSP源码中，/frameworks/base/core/jni/ 目录下的源码就是专门用来对接Framework层的JNI实现的。</p>
<p>看一下Binder.java的实现就会发现，这里面有不少的方法都是用native关键字修饰的，并且没有方法实现体，这些方法其实都是在C++中android_util_Binder.cpp实现的：<br>那么，那么，C++是如何调用Java的呢？最关键的，libbinder中的BBinder::onTransact是如何能够调用到Java中的Binder::onTransact的呢？<br><a href="https://postimg.org/image/hgztnik3z/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/xf8jdnec3/59-_Android-binder-_Java_BBinder.png" alt="59-_Android-binder-_Java_BBinder.png"></a></p>
<p>这段逻辑就是android_util_Binder.cpp中JavaBBinder::onTransact中处理的了。JavaBBinder是BBinder子类，其类结构如下：libbinder中的BBinder::onTransact是如何能够调用到Java中的Binder::onTransact的呢？<br>JavaBBinder::onTransact关键代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   JNIEnv* env = javavm_to_jnienv(mVM);</span><br><span class="line"></span><br><span class="line">   IPCThreadState* thread_state = IPCThreadState::self();</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int32_t</span> strict_policy_before = thread_state-&gt;getStrictModePolicy();</span><br><span class="line"></span><br><span class="line">   jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">       code, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意这段代码中的这一行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">  code, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);</span><br></pre></td></tr></table></figure>
<p>这一行代码其实是在调用mObject上offset为mExecTransact的方法。这里的几个参数说明如下：</p>
<p>mObject 指向了Java端的Binder对象<br>gBinderOffsets.mExecTransact 指向了Binder类的execTransact方法<br>data 调用execTransact方法的参数<br>code, data, reply, flags都是传递给调用方法execTransact的参数<br>而JNIEnv.CallBooleanMethod这个方法是由虚拟机实现的。即：虚拟机会提供native方法来调用一个Java Object上的方法（关于Android上的Java虚拟机，今后我们会专门讲解）。</p>
<p>这样，就在C++层的JavaBBinder::onTransact中调用了Java层Binder::execTransact方法。而在Binder::execTransact方法中，又调用了自身的onTransact方法，由此保证整个过程串联了起来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> boolean <span class="title">execTransact</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">long</span> dataObj, <span class="keyword">long</span> replyObj,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">   Parcel data = Parcel.obtain(dataObj);</span><br><span class="line">   Parcel reply = Parcel.obtain(replyObj);</span><br><span class="line">   boolean res;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       res = onTransact(code, data, reply, flags);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RemoteException|RuntimeException e) &#123;</span><br><span class="line">       <span class="keyword">if</span> (LOG_RUNTIME_EXCEPTION) &#123;</span><br><span class="line">           Log.w(TAG, <span class="string">"Caught a RuntimeException from the binder stub implementation."</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((flags &amp; FLAG_ONEWAY) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (e instanceof RemoteException) &#123;</span><br><span class="line">               Log.w(TAG, <span class="string">"Binder call failed."</span>, e);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               Log.w(TAG, <span class="string">"Caught a RuntimeException from the binder stub implementation."</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           reply.setDataPosition(<span class="number">0</span>);</span><br><span class="line">           reply.writeException(e);</span><br><span class="line">       &#125;</span><br><span class="line">       res = <span class="literal">true</span>;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">       RuntimeException re = <span class="keyword">new</span> RuntimeException(<span class="string">"Out of memory"</span>, e);</span><br><span class="line">       reply.setDataPosition(<span class="number">0</span>);</span><br><span class="line">       reply.writeException(re);</span><br><span class="line">       res = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   checkParcel(<span class="keyword">this</span>, code, reply, <span class="string">"Unreasonably large binder reply buffer"</span>);</span><br><span class="line">   reply.recycle();</span><br><span class="line">   data.recycle();</span><br><span class="line"></span><br><span class="line">   StrictMode.clearGatheredViolations();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（3）、Java层的ServiceManager"><a href="#（3）、Java层的ServiceManager" class="headerlink" title="（3）、Java层的ServiceManager"></a>（3）、Java层的ServiceManager</h4><p><a href="https://postimg.org/image/ea5a3updb/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/z71i8ineb/60-_Android-binder-class_Service_Manager_java.jpg" alt="60-_Android-binder-class_Service_Manager_java.jpg"></a><br>有Java端的Binder服务，自然也少不了Java端的ServiceManager。我们先看一下Java端的ServiceManager的结构：</p>
<p><a href="https://postimg.org/image/8lyzczfvz/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/xf8jdmywj/61-_Android-binder-_Service_Manager_Java.png" alt="61-_Android-binder-_Service_Manager_Java.png"></a></p>
<p>通过这个类图我们看到，Java层的ServiceManager和C++层的接口是一样的。</p>
<p>通过这个类图我们看到，Java层的ServiceManager和C++层的接口是一样的。</p>
<p>然后我们再选取addService方法看一下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       getIServiceManager().addService(name, service, allowIsolated);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">       Log.e(TAG, <span class="string">"error in addService"</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> sServiceManager;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Find the service manager</span></span><br><span class="line">   sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">   <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，这段代码中，最关键就是下面这个调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br></pre></td></tr></table></figure>
<p>然后我们需要再看一下BinderInternal.getContextObject()和ServiceManagerNative.asInterface两个方法。</p>
<p>BinderInternal.getContextObject()是一个JNI方法，其实现代码在android_util_Binder.cpp中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL);</span><br><span class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而ServiceManagerNative.asInterface的实现和其他的Binder服务是一样的套路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IServiceManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   IServiceManager in =</span><br><span class="line">       (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">   <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> in;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ServiceManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先通过queryLocalInterface查看能不能获得本地Binder，如果无法获取，则创建并返回ServiceManagerProxy对象。</p>
<p>而ServiceManagerProxy自然也是和其他Binder Proxy一样的实现套路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">   Parcel data = Parcel.obtain();</span><br><span class="line">   Parcel reply = Parcel.obtain();</span><br><span class="line">   data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">   data.writeString(name);</span><br><span class="line">   data.writeStrongBinder(service);</span><br><span class="line">   data.writeInt(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">   mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">   reply.recycle();</span><br><span class="line">   data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的调用流程前面已经分析过了，在此就不再分析了。<br><a href="https://postimg.org/image/pz99rtvrj/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/3nbgyfwnn/62-_Android-binder-binder_ipc_process.jpg" alt="62-_Android-binder-binder_ipc_process.jpg"></a></p>
<h3 id="六、Android-Binder系统-AIDL"><a href="#六、Android-Binder系统-AIDL" class="headerlink" title="六、Android Binder系统-AIDL"></a>六、Android Binder系统-AIDL</h3><p>作为Binder机制的最后一个部分内容，我们来讲解一下开发者经常使用的AIDL机制是怎么回事。</p>
<p>AIDL全称是Android Interface Definition Language，它是Android SDK提供的一种机制。借助这个机制，应用可以提供跨进程的服务供其他应用使用。AIDL的详细说明可以参见官方开发文档：<a href="https://developer.android.com/guide/components/aidl.html" target="_blank" rel="noopener">https://developer.android.com/guide/components/aidl.html</a> 。</p>
<p>这里，我们就以官方文档上的例子看来一下AIDL与Binder框架的关系。</p>
<p>开发一个基于AIDL的Service需要三个步骤：</p>
<p>定义一个.aidl文件<br>实现接口<br>暴露接口给客户端使用<br>aidl文件使用Java语言的语法来定义，每个.aidl文件只能包含一个interface，并且要包含interface的所有方法声明。</p>
<p>默认情况下，AIDL支持的数据类型包括：</p>
<p>基本数据类型（即int，long，char，boolean等）<br>String<br>CharSequence<br>List（List的元素类型必须是AIDL支持的）<br>Map（Map中的元素必须是AIDL支持的）<br>对于AIDL中的接口，可以包含0个或多个参数，可以返回void或一个值。所有非基本类型的参数必须包含一个描述是数据流向的标签，可能的取值是：in，out或者inout。</p>
<p>下面是一个aidl文件的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// IRemoteService.aidl</span><br><span class="line">package com.example.android;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">/** Example service interface */</span><br><span class="line">interface IRemoteService &#123;</span><br><span class="line">    /** Request the process ID of this service, to do evil things with it. */</span><br><span class="line">    int getPid();</span><br><span class="line"></span><br><span class="line">    /** Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span><br><span class="line">    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">            double aDouble, String aString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个文件中包含了两个接口 ：</p>
<p>getPid 一个无参的接口，返回值类型为int<br>basicTypes，包含了几个基本类型作为参数的接口，无返回值<br>对于包含.aidl文件的工程，Android IDE（以前是Eclipse，现在是Android Studio）在编译项目的时候，会为aidl文件生成对应的Java文件。</p>
<p>针对上面这个aidl文件生成的java文件中包含的结构如下图所示：</p>
<p><a href="https://postimg.org/image/fp6usldlr/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/reaugk4kj/63-_Android-binder-aidl_java.png" alt="63-_Android-binder-aidl_java.png"></a></p>
<p>在这个生成的Java文件中，包括了：</p>
<p>一个名称为IRemoteService的interface，该interface继承自android.os.IInterface并且包含了我们在aidl文件中声明的接口方法<br>IRemoteService中包含了一个名称为Stub的静态内部类，这个类是一个抽象类，它继承自android.os.Binder并且实现了IRemoteService接口。这个类中包含了一个onTransact方法<br>Stub内部又包含了一个名称为Proxy的静态内部类，Proxy类同样实现了IRemoteService接口<br>仔细看一下Stub类和Proxy两个中包含的方法，是不是觉得很熟悉？是的，这里和前面介绍的服务实现是一样的模式。这里我们列一下各层类的对应关系：</p>
<table>
<thead>
<tr>
<th style="text-align:center">C++层</th>
<th style="text-align:center">Java层</th>
<th style="text-align:center">AIDL</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BpXXX</td>
<td style="text-align:center">XXXProxy</td>
<td style="text-align:center">IXXX.Stub.Proxy</td>
</tr>
<tr>
<td style="text-align:center">BnXXX</td>
<td style="text-align:center">XXXNative</td>
<td style="text-align:center">IXXX.Stub</td>
</tr>
</tbody>
</table>
<p>为了整个结构的完整性，最后我们还是来看一下生成的Stub和Proxy类中的实现逻辑。</p>
<p>Stub是提供给开发者实现业务的父类，而Proxy的实现了对外提供的接口。Stub和Proxy两个类都有一个asBinder的方法。</p>
<p>Stub类中的asBinder实现就是返回自身对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而Proxy中asBinder的实现是返回构造函数中获取的mRemote对象，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">	mRemote = remote;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Override</span><br><span class="line"><span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mRemote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这里的mRemote对象其实就是远程服务在当前进程的标识。</p>
<p>上文我们说了，Stub类是用来提供给开发者实现业务逻辑的父类，开发者者继承自Stub然后完成自己的业务逻辑实现，例如这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IRemoteService.Stub mBinder = <span class="keyword">new</span> IRemoteService.Stub() &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Process.myPid();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Does something</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而这个Proxy类，就是用来给调用者使用的对外接口。我们可以看一下Proxy中的接口到底是如何实现的：</p>
<p>Proxy中getPid方法实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">	android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">	android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">	<span class="keyword">int</span> _result;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		_data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">		mRemote.transact(Stub.TRANSACTION_getPid, _data, _reply, <span class="number">0</span>);</span><br><span class="line">		_reply.readException();</span><br><span class="line">		_result = _reply.readInt();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		_reply.recycle();</span><br><span class="line">		_data.recycle();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是通过Parcel对象以及transact调用对应远程服务的接口。而在Stub类中，生成的onTransact方法对应的处理了这里的请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">	<span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">		reply.writeString(DESCRIPTOR);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> TRANSACTION_getPid: &#123;</span><br><span class="line">		data.enforceInterface(DESCRIPTOR);</span><br><span class="line">		<span class="keyword">int</span> _result = <span class="keyword">this</span>.getPid();</span><br><span class="line">		reply.writeNoException();</span><br><span class="line">		reply.writeInt(_result);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> TRANSACTION_basicTypes: &#123;</span><br><span class="line">		data.enforceInterface(DESCRIPTOR);</span><br><span class="line">		<span class="keyword">int</span> _arg0;</span><br><span class="line">		_arg0 = data.readInt();</span><br><span class="line">		<span class="keyword">long</span> _arg1;</span><br><span class="line">		_arg1 = data.readLong();</span><br><span class="line">		<span class="keyword">boolean</span> _arg2;</span><br><span class="line">		_arg2 = (<span class="number">0</span> != data.readInt());</span><br><span class="line">		<span class="keyword">float</span> _arg3;</span><br><span class="line">		_arg3 = data.readFloat();</span><br><span class="line">		<span class="keyword">double</span> _arg4;</span><br><span class="line">		_arg4 = data.readDouble();</span><br><span class="line">		java.lang.String _arg5;</span><br><span class="line">		_arg5 = data.readString();</span><br><span class="line">		<span class="keyword">this</span>.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">		reply.writeNoException();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onTransact()所要做的就是：</p>
<p>根据code区分请求的是哪个接口<br>通过data来获取请求的参数<br>调用由子类实现的抽象方法<br>有了前文的讲解，对于这部分内容应当不难理解了。</p>
<p>到这里，我们终于讲解完Binder了。</p>
<p>完整框架：<br><a href="https://postimg.org/image/l0lrdbujj/" target="_blank" rel="noopener"><img src="https://s19.postimg.org/fp6usm8gz/64-_Android-_Binder-_IPCall.png" alt="64-_Android-_Binder-_IPCall.png"></a></p>
<h3 id="七、参考文档-特别感谢各位前辈的分析和图示-："><a href="#七、参考文档-特别感谢各位前辈的分析和图示-：" class="headerlink" title="七、参考文档(特别感谢各位前辈的分析和图示)："></a>七、参考文档(特别感谢各位前辈的分析和图示)：</h3><p><a href="https://github.com/xdtianyu/SourceAnalysis/blob/master/Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">Binder源码分析</a><br><a href="http://blog.csdn.net/yangwen123/article/category/1609389" target="_blank" rel="noopener">深入分析Android Binder </a><br><a href="http://gityuan.com/tags/#binder" target="_blank" rel="noopener">Binder系列 - Gityuan博客 | 袁辉辉博客</a><br><a href="http://qiangbo.space/tags/#Android" target="_blank" rel="noopener"> 理解Android Binder机制 - Qiangbo.space博客</a><br><a href="https://wangkuiwu.github.io/page2/" target="_blank" rel="noopener">Android Binder机制(1) ~ (12) - Wangkuiwu.github.io</a><br><a href="http://www.jcodecraeer.com/tags.php?/Binder/" target="_blank" rel="noopener">Binder机制-关于Binder的文章 - 泡在网上的日子</a><br><a href="https://my.oschina.net/youranhongcha/blog?catalog=373547&amp;temp=1505099522160" target="_blank" rel="noopener">红茶一杯话Binder - 悠然红茶</a><br><a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-22/Binder%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90.md" target="_blank" rel="noopener">Binder框架解析</a><br><a href="https://mr-cao.gitbooks.io/android/content/android-binder.html" target="_blank" rel="noopener">Android Binder详解</a><br><a href="http://blog.csdn.net/carson_ho/article/details/73560642" target="_blank" rel="noopener">图文详解 Android Binder跨进程通信机制 原理</a><br><a href="http://qiangbo.space/2017-01-15/AndroidAnatomy_Binder_Driver/" target="_blank" rel="noopener">理解Android Binder机制(1/3)：驱动篇-qiangbo.space</a><br><a href="http://qiangbo.space/2017-02-12/AndroidAnatomy_Binder_CPP/" target="_blank" rel="noopener">理解Android Binder机制(2/3)：C++层-qiangbo.space</a><br><a href="http://qiangbo.space/2017-03-15/AndroidAnatomy_Binder_Java/" target="_blank" rel="noopener">理解Android Binder机制(3/3)：Java层-qiangbo.space</a><br><a href="http://light3moon.com/1986/12/20/%E6%96%87%E7%AB%A0%E7%B4%A2%E5%BC%95/#" target="_blank" rel="noopener">Android Binder 分析–系列-light3moon</a><br><a href="http://palanceli.com/categories/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/page/2/" target="_blank" rel="noopener"> Android学习笔记-Binder | Palance’s Blog</a><br><a href="http://blog.csdn.net/armwind/article/category/6282972" target="_blank" rel="noopener">android系统 -Binder - armwind的专栏 - CSDN博客</a><br><a href="http://blog.csdn.net/Bettarwang/article/category/2276043" target="_blank" rel="noopener">Bettarwang的专栏 -Android Binder机制</a><br><a href="http://blog.csdn.net/yangwen123/article/category/1609389" target="_blank" rel="noopener">深入剖析Android系统 - binder -  CSDN博客</a></p>
</div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><elif theme.sharejs && theme.sharejs.enable></elif></article><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-系统分析/"><i class="fa fa-chevron-left">  </i><span>Android 7.1.2 (Android N) Android Graphics 系统 分析 [i.wonder~]</span></a></div><div class="next-post pull-right"><a href="/2017/12/01/Android-7-1-2-Android-N-Android-输入子系统-Input-System/"><span>Android 7.1.2 (Android N) Android 输入子系统 - Input System 分析</span><i class="fa fa-chevron-right"></i></a></div></nav><elif theme.laibili && theme.laibili.enable></elif><elif theme.gitment && theme.gitment.enable></elif></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;1992 - 2018 By ๑Charles✦ˑ̫✦Vincent๑</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.4.1"></script><script src="/js/fancybox.js?version=1.4.1"></script><script src="/js/sidebar.js?version=1.4.1"></script><script src="/js/copy.js?version=1.4.1"></script><script src="/js/fireworks.js?version=1.4.1"></script><script src="/js/transition.js?version=1.4.1"></script><script src="/js/scroll.js?version=1.4.1"></script><script src="/js/head.js?version=1.4.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>